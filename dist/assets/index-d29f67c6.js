var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const main$1 = "";
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize(str)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style: style2 } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style2) {
    props.style = normalizeStyle(style2);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a2.length; i2++) {
    equal = looseEqual(a2[i2], b2[i2]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate(a2);
  let bValidType = isDate(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a2);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray(a2);
  bValidType = isArray(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject(a2);
  bValidType = isObject(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect$3(fn2, options) {
  if (fn2.effect) {
    fn2 = fn2.effect.fn;
  }
  const _effect = new ReactiveEffect(fn2);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const shallowReadonlyHandlers = /* @__PURE__ */ extend(
  {},
  readonlyHandlers,
  {
    get: shallowReadonlyGet
  }
);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size$1(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(
    source,
    key,
    defaultValue
  );
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function assertNumber(val, type) {
  return;
}
function callWithErrorHandling(fn2, instance, type, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn2.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end2 = queue.length;
  while (start2 < end2) {
    const middle = start2 + end2 >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start2 = middle + 1 : end2 = middle;
  }
  return start2;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff = getId(a2) - getId(b2);
  if (diff === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => isString(a2) ? a2.trim() : a2);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s2) {
  let block;
  if (isFunction(s2)) {
    const trackBlock = isBlockTreeEnabled && s2._c;
    if (trackBlock) {
      s2._d = false;
      openBlock();
    }
    s2 = s2();
    if (trackBlock) {
      s2._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s2)) {
    const singleChild = filterSingleRoot(s2);
    s2 = singleChild;
  }
  s2 = normalizeVNode(s2);
  if (block && !s2.dynamicChildren) {
    s2.dynamicChildren = block.filter((c2) => c2 !== s2);
  }
  return s2;
}
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v2, i2) => hasChanged(v2, oldValue[i2])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
          /* do not throw in dev if user provided error component */
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        isSVG,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys2.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max: max2 } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max2 && keys2.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_2, key) {
      const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
      return has2;
    }
  }
);
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props, name, options) {
  const i2 = getCurrentInstance();
  if (options && options.local) {
    const proxy = ref(props[name]);
    watch(
      () => props[name],
      (v2) => proxy.value = v2
    );
    watch(proxy, (value) => {
      if (value !== props[name]) {
        i2.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props[name];
      },
      set value(value) {
        i2.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip"))
      continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else
      ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a2, b2) {
  if (!a2 || !b2)
    return a2 || b2;
  if (isArray(a2) && isArray(b2))
    return a2.concat(b2);
  return extend({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b2));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn2) {
        currentApp = app;
        try {
          return fn2();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r2, i2) => setRef(
        r2,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            optimized
          );
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVGContainer(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(
                el,
                key,
                null,
                props[key],
                false,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props.onClick,
            false,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l2 = children.length;
    for (let i2 = 0; i2 < l2; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVGContainer(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end2 = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end2) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      isSVGContainer(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end2) => {
    let next;
    while (cur !== end2) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end2);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            true,
            !!child.dynamicChildren
          );
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s2) => s2(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h$1(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev.length; i2++) {
    if (hasChanged(prev[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.3.4";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start2, end2) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end2 || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end2 || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    new MutationObserver((mutations) => {
      for (const m2 of mutations) {
        this._setAttr(m2.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s2 = document.createElement("style");
        s2.textContent = css;
        this.shadowRoot.appendChild(s2);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style2 = el.style;
    for (const key in vars) {
      style2.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end2 = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end2();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end2();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style2 = el.style;
        addTransitionClass(el, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el._assign;
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
        (o2) => number ? looseToNumber(getValue(o2)) : getValue(o2)
      );
      el._assign(
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
    const option = el.options[i2];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2)
          el.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn2 = modelToUse[hook];
  fn2 && fn2(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn2(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  EffectScope,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  get devtools() {
    return devtools;
  },
  effect: effect$3,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h: h$1,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var interact_min = { exports: {} };
(function(module, exports) {
  !function(t) {
    module.exports = t();
  }(function() {
    var t = {};
    Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.default = function(t2) {
      return !(!t2 || !t2.Window) && t2 instanceof t2.Window;
    };
    var e = {};
    Object.defineProperty(e, "__esModule", { value: true }), e.getWindow = function(e2) {
      return (0, t.default)(e2) ? e2 : (e2.ownerDocument || e2).defaultView || r2.window;
    }, e.init = o2, e.window = e.realWindow = void 0;
    var n2 = void 0;
    e.realWindow = n2;
    var r2 = void 0;
    function o2(t2) {
      e.realWindow = n2 = t2;
      var o3 = t2.document.createTextNode("");
      o3.ownerDocument !== t2.document && "function" == typeof t2.wrap && t2.wrap(o3) === o3 && (t2 = t2.wrap(t2)), e.window = r2 = t2;
    }
    e.window = r2, "undefined" != typeof window && window && o2(window);
    var i2 = {};
    function a2(t2) {
      return a2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, a2(t2);
    }
    Object.defineProperty(i2, "__esModule", { value: true }), i2.default = void 0;
    var s2 = function(t2) {
      return !!t2 && "object" === a2(t2);
    }, l2 = function(t2) {
      return "function" == typeof t2;
    }, u2 = { window: function(n3) {
      return n3 === e.window || (0, t.default)(n3);
    }, docFrag: function(t2) {
      return s2(t2) && 11 === t2.nodeType;
    }, object: s2, func: l2, number: function(t2) {
      return "number" == typeof t2;
    }, bool: function(t2) {
      return "boolean" == typeof t2;
    }, string: function(t2) {
      return "string" == typeof t2;
    }, element: function(t2) {
      if (!t2 || "object" !== a2(t2))
        return false;
      var n3 = e.getWindow(t2) || e.window;
      return /object|function/.test("undefined" == typeof Element ? "undefined" : a2(Element)) ? t2 instanceof Element || t2 instanceof n3.Element : 1 === t2.nodeType && "string" == typeof t2.nodeName;
    }, plainObject: function(t2) {
      return s2(t2) && !!t2.constructor && /function Object\b/.test(t2.constructor.toString());
    }, array: function(t2) {
      return s2(t2) && void 0 !== t2.length && l2(t2.splice);
    } };
    i2.default = u2;
    var c2 = {};
    function f2(t2) {
      var e2 = t2.interaction;
      if ("drag" === e2.prepared.name) {
        var n3 = e2.prepared.axis;
        "x" === n3 ? (e2.coords.cur.page.y = e2.coords.start.page.y, e2.coords.cur.client.y = e2.coords.start.client.y, e2.coords.velocity.client.y = 0, e2.coords.velocity.page.y = 0) : "y" === n3 && (e2.coords.cur.page.x = e2.coords.start.page.x, e2.coords.cur.client.x = e2.coords.start.client.x, e2.coords.velocity.client.x = 0, e2.coords.velocity.page.x = 0);
      }
    }
    function d2(t2) {
      var e2 = t2.iEvent, n3 = t2.interaction;
      if ("drag" === n3.prepared.name) {
        var r3 = n3.prepared.axis;
        if ("x" === r3 || "y" === r3) {
          var o3 = "x" === r3 ? "y" : "x";
          e2.page[o3] = n3.coords.start.page[o3], e2.client[o3] = n3.coords.start.client[o3], e2.delta[o3] = 0;
        }
      }
    }
    Object.defineProperty(c2, "__esModule", { value: true }), c2.default = void 0;
    var p2 = { id: "actions/drag", install: function(t2) {
      var e2 = t2.actions, n3 = t2.Interactable, r3 = t2.defaults;
      n3.prototype.draggable = p2.draggable, e2.map.drag = p2, e2.methodDict.drag = "draggable", r3.actions.drag = p2.defaults;
    }, listeners: { "interactions:before-action-move": f2, "interactions:action-resume": f2, "interactions:action-move": d2, "auto-start:check": function(t2) {
      var e2 = t2.interaction, n3 = t2.interactable, r3 = t2.buttons, o3 = n3.options.drag;
      if (o3 && o3.enabled && (!e2.pointerIsDown || !/mouse|pointer/.test(e2.pointerType) || 0 != (r3 & n3.options.drag.mouseButtons)))
        return t2.action = { name: "drag", axis: "start" === o3.lockAxis ? o3.startAxis : o3.lockAxis }, false;
    } }, draggable: function(t2) {
      return i2.default.object(t2) ? (this.options.drag.enabled = false !== t2.enabled, this.setPerAction("drag", t2), this.setOnEvents("drag", t2), /^(xy|x|y|start)$/.test(t2.lockAxis) && (this.options.drag.lockAxis = t2.lockAxis), /^(xy|x|y)$/.test(t2.startAxis) && (this.options.drag.startAxis = t2.startAxis), this) : i2.default.bool(t2) ? (this.options.drag.enabled = t2, this) : this.options.drag;
    }, beforeMove: f2, move: d2, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function() {
      return "move";
    } }, v2 = p2;
    c2.default = v2;
    var h2 = {};
    Object.defineProperty(h2, "__esModule", { value: true }), h2.default = void 0;
    var g2 = { init: function(t2) {
      var e2 = t2;
      g2.document = e2.document, g2.DocumentFragment = e2.DocumentFragment || y2, g2.SVGElement = e2.SVGElement || y2, g2.SVGSVGElement = e2.SVGSVGElement || y2, g2.SVGElementInstance = e2.SVGElementInstance || y2, g2.Element = e2.Element || y2, g2.HTMLElement = e2.HTMLElement || g2.Element, g2.Event = e2.Event, g2.Touch = e2.Touch || y2, g2.PointerEvent = e2.PointerEvent || e2.MSPointerEvent;
    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };
    function y2() {
    }
    var m2 = g2;
    h2.default = m2;
    var b2 = {};
    Object.defineProperty(b2, "__esModule", { value: true }), b2.default = void 0;
    var x2 = { init: function(t2) {
      var e2 = h2.default.Element, n3 = t2.navigator || {};
      x2.supportsTouch = "ontouchstart" in t2 || i2.default.func(t2.DocumentTouch) && h2.default.document instanceof t2.DocumentTouch, x2.supportsPointerEvent = false !== n3.pointerEnabled && !!h2.default.PointerEvent, x2.isIOS = /iP(hone|od|ad)/.test(n3.platform), x2.isIOS7 = /iP(hone|od|ad)/.test(n3.platform) && /OS 7[^\d]/.test(n3.appVersion), x2.isIe9 = /MSIE 9/.test(n3.userAgent), x2.isOperaMobile = "Opera" === n3.appName && x2.supportsTouch && /Presto/.test(n3.userAgent), x2.prefixedMatchesSelector = "matches" in e2.prototype ? "matches" : "webkitMatchesSelector" in e2.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e2.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e2.prototype ? "oMatchesSelector" : "msMatchesSelector", x2.pEventTypes = x2.supportsPointerEvent ? h2.default.PointerEvent === t2.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, x2.wheelEvent = h2.default.document && "onmousewheel" in h2.default.document ? "mousewheel" : "wheel";
    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, w2 = x2;
    b2.default = w2;
    var _2 = {};
    function P2(t2) {
      var e2 = t2.parentNode;
      if (i2.default.docFrag(e2)) {
        for (; (e2 = e2.host) && i2.default.docFrag(e2); )
          ;
        return e2;
      }
      return e2;
    }
    function O2(t2, n3) {
      return e.window !== e.realWindow && (n3 = n3.replace(/\/deep\//g, " ")), t2[b2.default.prefixedMatchesSelector](n3);
    }
    Object.defineProperty(_2, "__esModule", { value: true }), _2.closest = function(t2, e2) {
      for (; i2.default.element(t2); ) {
        if (O2(t2, e2))
          return t2;
        t2 = P2(t2);
      }
      return null;
    }, _2.getActualElement = function(t2) {
      return t2.correspondingUseElement || t2;
    }, _2.getElementClientRect = j, _2.getElementRect = function(t2) {
      var n3 = j(t2);
      if (!b2.default.isIOS7 && n3) {
        var r3 = T2(e.getWindow(t2));
        n3.left += r3.x, n3.right += r3.x, n3.top += r3.y, n3.bottom += r3.y;
      }
      return n3;
    }, _2.getPath = function(t2) {
      for (var e2 = []; t2; )
        e2.push(t2), t2 = P2(t2);
      return e2;
    }, _2.getScrollXY = T2, _2.indexOfDeepestElement = function(t2) {
      for (var n3, r3 = [], o3 = 0; o3 < t2.length; o3++) {
        var i3 = t2[o3], a3 = t2[n3];
        if (i3 && o3 !== n3)
          if (a3) {
            var s3 = E2(i3), l3 = E2(a3);
            if (s3 !== i3.ownerDocument)
              if (l3 !== i3.ownerDocument)
                if (s3 !== l3) {
                  r3 = r3.length ? r3 : S2(a3);
                  var u3 = void 0;
                  if (a3 instanceof h2.default.HTMLElement && i3 instanceof h2.default.SVGElement && !(i3 instanceof h2.default.SVGSVGElement)) {
                    if (i3 === l3)
                      continue;
                    u3 = i3.ownerSVGElement;
                  } else
                    u3 = i3;
                  for (var c3 = S2(u3, a3.ownerDocument), f3 = 0; c3[f3] && c3[f3] === r3[f3]; )
                    f3++;
                  var d3 = [c3[f3 - 1], c3[f3], r3[f3]];
                  if (d3[0])
                    for (var p3 = d3[0].lastChild; p3; ) {
                      if (p3 === d3[1]) {
                        n3 = o3, r3 = c3;
                        break;
                      }
                      if (p3 === d3[2])
                        break;
                      p3 = p3.previousSibling;
                    }
                } else
                  v3 = i3, g3 = a3, (parseInt(e.getWindow(v3).getComputedStyle(v3).zIndex, 10) || 0) >= (parseInt(e.getWindow(g3).getComputedStyle(g3).zIndex, 10) || 0) && (n3 = o3);
              else
                n3 = o3;
          } else
            n3 = o3;
      }
      var v3, g3;
      return n3;
    }, _2.matchesSelector = O2, _2.matchesUpTo = function(t2, e2, n3) {
      for (; i2.default.element(t2); ) {
        if (O2(t2, e2))
          return true;
        if ((t2 = P2(t2)) === n3)
          return O2(t2, e2);
      }
      return false;
    }, _2.nodeContains = function(t2, e2) {
      if (t2.contains)
        return t2.contains(e2);
      for (; e2; ) {
        if (e2 === t2)
          return true;
        e2 = e2.parentNode;
      }
      return false;
    }, _2.parentNode = P2, _2.trySelector = function(t2) {
      return !!i2.default.string(t2) && (h2.default.document.querySelector(t2), true);
    };
    var E2 = function(t2) {
      return t2.parentNode || t2.host;
    };
    function S2(t2, e2) {
      for (var n3, r3 = [], o3 = t2; (n3 = E2(o3)) && o3 !== e2 && n3 !== o3.ownerDocument; )
        r3.unshift(o3), o3 = n3;
      return r3;
    }
    function T2(t2) {
      return { x: (t2 = t2 || e.window).scrollX || t2.document.documentElement.scrollLeft, y: t2.scrollY || t2.document.documentElement.scrollTop };
    }
    function j(t2) {
      var e2 = t2 instanceof h2.default.SVGElement ? t2.getBoundingClientRect() : t2.getClientRects()[0];
      return e2 && { left: e2.left, right: e2.right, top: e2.top, bottom: e2.bottom, width: e2.width || e2.right - e2.left, height: e2.height || e2.bottom - e2.top };
    }
    var M = {};
    Object.defineProperty(M, "__esModule", { value: true }), M.default = function(t2, e2) {
      for (var n3 in e2)
        t2[n3] = e2[n3];
      return t2;
    };
    var k2 = {};
    function I(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    function D2(t2, e2, n3) {
      return "parent" === t2 ? (0, _2.parentNode)(n3) : "self" === t2 ? e2.getRect(n3) : (0, _2.closest)(n3, t2);
    }
    Object.defineProperty(k2, "__esModule", { value: true }), k2.addEdges = function(t2, e2, n3) {
      t2.left && (e2.left += n3.x), t2.right && (e2.right += n3.x), t2.top && (e2.top += n3.y), t2.bottom && (e2.bottom += n3.y), e2.width = e2.right - e2.left, e2.height = e2.bottom - e2.top;
    }, k2.getStringOptionResult = D2, k2.rectToXY = function(t2) {
      return t2 && { x: "x" in t2 ? t2.x : t2.left, y: "y" in t2 ? t2.y : t2.top };
    }, k2.resolveRectLike = function(t2, e2, n3, r3) {
      var o3, a3 = t2;
      return i2.default.string(a3) ? a3 = D2(a3, e2, n3) : i2.default.func(a3) && (a3 = a3.apply(void 0, function(t3) {
        if (Array.isArray(t3))
          return I(t3);
      }(o3 = r3) || function(t3) {
        if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
          return Array.from(t3);
      }(o3) || function(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return I(t3, e3);
          var n4 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === n4 && t3.constructor && (n4 = t3.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(t3) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? I(t3, e3) : void 0;
        }
      }(o3) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }())), i2.default.element(a3) && (a3 = (0, _2.getElementRect)(a3)), a3;
    }, k2.tlbrToXywh = function(t2) {
      return !t2 || "x" in t2 && "y" in t2 || ((t2 = (0, M.default)({}, t2)).x = t2.left || 0, t2.y = t2.top || 0, t2.width = t2.width || (t2.right || 0) - t2.x, t2.height = t2.height || (t2.bottom || 0) - t2.y), t2;
    }, k2.xywhToTlbr = function(t2) {
      return !t2 || "left" in t2 && "top" in t2 || ((t2 = (0, M.default)({}, t2)).left = t2.x || 0, t2.top = t2.y || 0, t2.right = t2.right || t2.left + t2.width, t2.bottom = t2.bottom || t2.top + t2.height), t2;
    };
    var A2 = {};
    Object.defineProperty(A2, "__esModule", { value: true }), A2.default = function(t2, e2, n3) {
      var r3 = t2.options[n3], o3 = r3 && r3.origin || t2.options.origin, i3 = (0, k2.resolveRectLike)(o3, t2, e2, [t2 && e2]);
      return (0, k2.rectToXY)(i3) || { x: 0, y: 0 };
    };
    var z2 = {};
    function C2(t2) {
      return t2.trim().split(/ +/);
    }
    Object.defineProperty(z2, "__esModule", { value: true }), z2.default = function t2(e2, n3, r3) {
      if (r3 = r3 || {}, i2.default.string(e2) && -1 !== e2.search(" ") && (e2 = C2(e2)), i2.default.array(e2))
        return e2.reduce(function(e3, o4) {
          return (0, M.default)(e3, t2(o4, n3, r3));
        }, r3);
      if (i2.default.object(e2) && (n3 = e2, e2 = ""), i2.default.func(n3))
        r3[e2] = r3[e2] || [], r3[e2].push(n3);
      else if (i2.default.array(n3))
        for (var o3 = 0; o3 < n3.length; o3++) {
          var a3;
          a3 = n3[o3], t2(e2, a3, r3);
        }
      else if (i2.default.object(n3))
        for (var s3 in n3) {
          var l3 = C2(s3).map(function(t3) {
            return "".concat(e2).concat(t3);
          });
          t2(l3, n3[s3], r3);
        }
      return r3;
    };
    var R2 = {};
    Object.defineProperty(R2, "__esModule", { value: true }), R2.default = void 0, R2.default = function(t2, e2) {
      return Math.sqrt(t2 * t2 + e2 * e2);
    };
    var F2 = {};
    Object.defineProperty(F2, "__esModule", { value: true }), F2.default = function(t2, e2) {
      t2.__set || (t2.__set = {});
      var n3 = function(n4) {
        "function" != typeof t2[n4] && "__set" !== n4 && Object.defineProperty(t2, n4, { get: function() {
          return n4 in t2.__set ? t2.__set[n4] : t2.__set[n4] = e2[n4];
        }, set: function(e3) {
          t2.__set[n4] = e3;
        }, configurable: true });
      };
      for (var r3 in e2)
        n3(r3);
      return t2;
    };
    var X2 = {};
    function B2(t2) {
      return t2 instanceof h2.default.Event || t2 instanceof h2.default.Touch;
    }
    function Y(t2, e2, n3) {
      return t2 = t2 || "page", (n3 = n3 || {}).x = e2[t2 + "X"], n3.y = e2[t2 + "Y"], n3;
    }
    function W2(t2, e2) {
      return e2 = e2 || { x: 0, y: 0 }, b2.default.isOperaMobile && B2(t2) ? (Y("screen", t2, e2), e2.x += window.scrollX, e2.y += window.scrollY) : Y("page", t2, e2), e2;
    }
    function L2(t2, e2) {
      return e2 = e2 || {}, b2.default.isOperaMobile && B2(t2) ? Y("screen", t2, e2) : Y("client", t2, e2), e2;
    }
    function U2(t2) {
      var e2 = [];
      return i2.default.array(t2) ? (e2[0] = t2[0], e2[1] = t2[1]) : "touchend" === t2.type ? 1 === t2.touches.length ? (e2[0] = t2.touches[0], e2[1] = t2.changedTouches[0]) : 0 === t2.touches.length && (e2[0] = t2.changedTouches[0], e2[1] = t2.changedTouches[1]) : (e2[0] = t2.touches[0], e2[1] = t2.touches[1]), e2;
    }
    function V(t2) {
      for (var e2 = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, n3 = 0; n3 < t2.length; n3++) {
        var r3 = t2[n3];
        for (var o3 in e2)
          e2[o3] += r3[o3];
      }
      for (var i3 in e2)
        e2[i3] /= t2.length;
      return e2;
    }
    Object.defineProperty(X2, "__esModule", { value: true }), X2.coordsToEvent = function(t2) {
      return { coords: t2, get page() {
        return this.coords.page;
      }, get client() {
        return this.coords.client;
      }, get timeStamp() {
        return this.coords.timeStamp;
      }, get pageX() {
        return this.coords.page.x;
      }, get pageY() {
        return this.coords.page.y;
      }, get clientX() {
        return this.coords.client.x;
      }, get clientY() {
        return this.coords.client.y;
      }, get pointerId() {
        return this.coords.pointerId;
      }, get target() {
        return this.coords.target;
      }, get type() {
        return this.coords.type;
      }, get pointerType() {
        return this.coords.pointerType;
      }, get buttons() {
        return this.coords.buttons;
      }, preventDefault: function() {
      } };
    }, X2.copyCoords = function(t2, e2) {
      t2.page = t2.page || {}, t2.page.x = e2.page.x, t2.page.y = e2.page.y, t2.client = t2.client || {}, t2.client.x = e2.client.x, t2.client.y = e2.client.y, t2.timeStamp = e2.timeStamp;
    }, X2.getClientXY = L2, X2.getEventTargets = function(t2) {
      var e2 = i2.default.func(t2.composedPath) ? t2.composedPath() : t2.path;
      return [_2.getActualElement(e2 ? e2[0] : t2.target), _2.getActualElement(t2.currentTarget)];
    }, X2.getPageXY = W2, X2.getPointerId = function(t2) {
      return i2.default.number(t2.pointerId) ? t2.pointerId : t2.identifier;
    }, X2.getPointerType = function(t2) {
      return i2.default.string(t2.pointerType) ? t2.pointerType : i2.default.number(t2.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t2.pointerType] : /touch/.test(t2.type || "") || t2 instanceof h2.default.Touch ? "touch" : "mouse";
    }, X2.getTouchPair = U2, X2.getXY = Y, X2.isNativePointer = B2, X2.newCoords = function() {
      return { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 };
    }, X2.pointerAverage = V, Object.defineProperty(X2, "pointerExtend", { enumerable: true, get: function() {
      return F2.default;
    } }), X2.setCoordDeltas = function(t2, e2, n3) {
      t2.page.x = n3.page.x - e2.page.x, t2.page.y = n3.page.y - e2.page.y, t2.client.x = n3.client.x - e2.client.x, t2.client.y = n3.client.y - e2.client.y, t2.timeStamp = n3.timeStamp - e2.timeStamp;
    }, X2.setCoordVelocity = function(t2, e2) {
      var n3 = Math.max(e2.timeStamp / 1e3, 1e-3);
      t2.page.x = e2.page.x / n3, t2.page.y = e2.page.y / n3, t2.client.x = e2.client.x / n3, t2.client.y = e2.client.y / n3, t2.timeStamp = n3;
    }, X2.setCoords = function(t2, e2, n3) {
      var r3 = e2.length > 1 ? V(e2) : e2[0];
      W2(r3, t2.page), L2(r3, t2.client), t2.timeStamp = n3;
    }, X2.setZeroCoords = function(t2) {
      t2.page.x = 0, t2.page.y = 0, t2.client.x = 0, t2.client.y = 0;
    }, X2.touchAngle = function(t2, e2) {
      var n3 = e2 + "X", r3 = e2 + "Y", o3 = U2(t2), i3 = o3[1][n3] - o3[0][n3], a3 = o3[1][r3] - o3[0][r3];
      return 180 * Math.atan2(a3, i3) / Math.PI;
    }, X2.touchBBox = function(t2) {
      if (!t2.length)
        return null;
      var e2 = U2(t2), n3 = Math.min(e2[0].pageX, e2[1].pageX), r3 = Math.min(e2[0].pageY, e2[1].pageY), o3 = Math.max(e2[0].pageX, e2[1].pageX), i3 = Math.max(e2[0].pageY, e2[1].pageY);
      return { x: n3, y: r3, left: n3, top: r3, right: o3, bottom: i3, width: o3 - n3, height: i3 - r3 };
    }, X2.touchDistance = function(t2, e2) {
      var n3 = e2 + "X", r3 = e2 + "Y", o3 = U2(t2), i3 = o3[0][n3] - o3[1][n3], a3 = o3[0][r3] - o3[1][r3];
      return (0, R2.default)(i3, a3);
    };
    var N = {};
    function q2(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function G2(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(N, "__esModule", { value: true }), N.BaseEvent = void 0;
    var $ = function() {
      function t2(e3) {
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), G2(this, "immediatePropagationStopped", false), G2(this, "propagationStopped", false), this._interaction = e3;
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = true;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = true;
      } }]) && q2(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    N.BaseEvent = $, Object.defineProperty($.prototype, "interaction", { get: function() {
      return this._interaction._proxy;
    }, set: function() {
    } });
    var H2 = {};
    Object.defineProperty(H2, "__esModule", { value: true }), H2.remove = H2.merge = H2.from = H2.findIndex = H2.find = H2.contains = void 0, H2.contains = function(t2, e2) {
      return -1 !== t2.indexOf(e2);
    }, H2.remove = function(t2, e2) {
      return t2.splice(t2.indexOf(e2), 1);
    };
    var K2 = function(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        t2.push(r3);
      }
      return t2;
    };
    H2.merge = K2, H2.from = function(t2) {
      return K2([], t2);
    };
    var Z2 = function(t2, e2) {
      for (var n3 = 0; n3 < t2.length; n3++)
        if (e2(t2[n3], n3, t2))
          return n3;
      return -1;
    };
    H2.findIndex = Z2, H2.find = function(t2, e2) {
      return t2[Z2(t2, e2)];
    };
    var J2 = {};
    function Q2(t2) {
      return Q2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, Q2(t2);
    }
    function tt2(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function et2(t2, e2) {
      return et2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, et2(t2, e2);
    }
    function nt2(t2, e2) {
      if (e2 && ("object" === Q2(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return rt2(t2);
    }
    function rt2(t2) {
      if (void 0 === t2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }
    function ot2(t2) {
      return ot2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, ot2(t2);
    }
    function it2(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(J2, "__esModule", { value: true }), J2.DropEvent = void 0;
    var at2 = function(t2) {
      !function(t3, e3) {
        if ("function" != typeof e3 && null !== e3)
          throw new TypeError("Super expression must either be null or a function");
        t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), Object.defineProperty(t3, "prototype", { writable: false }), e3 && et2(t3, e3);
      }(a3, t2);
      var e2, n3, r3, o3, i3 = (r3 = a3, o3 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }(), function() {
        var t3, e3 = ot2(r3);
        if (o3) {
          var n4 = ot2(this).constructor;
          t3 = Reflect.construct(e3, arguments, n4);
        } else
          t3 = e3.apply(this, arguments);
        return nt2(this, t3);
      });
      function a3(t3, e3, n4) {
        var r4;
        !function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, a3), it2(rt2(r4 = i3.call(this, e3._interaction)), "dropzone", void 0), it2(rt2(r4), "dragEvent", void 0), it2(rt2(r4), "relatedTarget", void 0), it2(rt2(r4), "draggable", void 0), it2(rt2(r4), "propagationStopped", false), it2(rt2(r4), "immediatePropagationStopped", false);
        var o4 = "dragleave" === n4 ? t3.prev : t3.cur, s3 = o4.element, l3 = o4.dropzone;
        return r4.type = n4, r4.target = s3, r4.currentTarget = s3, r4.dropzone = l3, r4.dragEvent = e3, r4.relatedTarget = e3.target, r4.draggable = e3.interactable, r4.timeStamp = e3.timeStamp, r4;
      }
      return e2 = a3, (n3 = [{ key: "reject", value: function() {
        var t3 = this, e3 = this._interaction.dropState;
        if ("dropactivate" === this.type || this.dropzone && e3.cur.dropzone === this.dropzone && e3.cur.element === this.target)
          if (e3.prev.dropzone = this.dropzone, e3.prev.element = this.target, e3.rejected = true, e3.events.enter = null, this.stopImmediatePropagation(), "dropactivate" === this.type) {
            var n4 = e3.activeDrops, r4 = H2.findIndex(n4, function(e4) {
              var n5 = e4.dropzone, r5 = e4.element;
              return n5 === t3.dropzone && r5 === t3.target;
            });
            e3.activeDrops.splice(r4, 1);
            var o4 = new a3(e3, this.dragEvent, "dropdeactivate");
            o4.dropzone = this.dropzone, o4.target = this.target, this.dropzone.fire(o4);
          } else
            this.dropzone.fire(new a3(e3, this.dragEvent, "dragleave"));
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = true;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = true;
      } }]) && tt2(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), a3;
    }(N.BaseEvent);
    J2.DropEvent = at2;
    var st2 = {};
    function lt2(t2, e2) {
      for (var n3 = 0; n3 < t2.slice().length; n3++) {
        var r3 = t2.slice()[n3], o3 = r3.dropzone, i3 = r3.element;
        e2.dropzone = o3, e2.target = i3, o3.fire(e2), e2.propagationStopped = e2.immediatePropagationStopped = false;
      }
    }
    function ut2(t2, e2) {
      for (var n3 = function(t3, e3) {
        for (var n4 = t3.interactables, r4 = [], o4 = 0; o4 < n4.list.length; o4++) {
          var a3 = n4.list[o4];
          if (a3.options.drop.enabled) {
            var s3 = a3.options.drop.accept;
            if (!(i2.default.element(s3) && s3 !== e3 || i2.default.string(s3) && !_2.matchesSelector(e3, s3) || i2.default.func(s3) && !s3({ dropzone: a3, draggableElement: e3 })))
              for (var l3 = i2.default.string(a3.target) ? a3._context.querySelectorAll(a3.target) : i2.default.array(a3.target) ? a3.target : [a3.target], u3 = 0; u3 < l3.length; u3++) {
                var c3 = l3[u3];
                c3 !== e3 && r4.push({ dropzone: a3, element: c3, rect: a3.getRect(c3) });
              }
          }
        }
        return r4;
      }(t2, e2), r3 = 0; r3 < n3.length; r3++) {
        var o3 = n3[r3];
        o3.rect = o3.dropzone.getRect(o3.element);
      }
      return n3;
    }
    function ct2(t2, e2, n3) {
      for (var r3 = t2.dropState, o3 = t2.interactable, i3 = t2.element, a3 = [], s3 = 0; s3 < r3.activeDrops.length; s3++) {
        var l3 = r3.activeDrops[s3], u3 = l3.dropzone, c3 = l3.element, f3 = l3.rect;
        a3.push(u3.dropCheck(e2, n3, o3, i3, c3, f3) ? c3 : null);
      }
      var d3 = _2.indexOfDeepestElement(a3);
      return r3.activeDrops[d3] || null;
    }
    function ft2(t2, e2, n3) {
      var r3 = t2.dropState, o3 = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };
      return "dragstart" === n3.type && (o3.activate = new J2.DropEvent(r3, n3, "dropactivate"), o3.activate.target = null, o3.activate.dropzone = null), "dragend" === n3.type && (o3.deactivate = new J2.DropEvent(r3, n3, "dropdeactivate"), o3.deactivate.target = null, o3.deactivate.dropzone = null), r3.rejected || (r3.cur.element !== r3.prev.element && (r3.prev.dropzone && (o3.leave = new J2.DropEvent(r3, n3, "dragleave"), n3.dragLeave = o3.leave.target = r3.prev.element, n3.prevDropzone = o3.leave.dropzone = r3.prev.dropzone), r3.cur.dropzone && (o3.enter = new J2.DropEvent(r3, n3, "dragenter"), n3.dragEnter = r3.cur.element, n3.dropzone = r3.cur.dropzone)), "dragend" === n3.type && r3.cur.dropzone && (o3.drop = new J2.DropEvent(r3, n3, "drop"), n3.dropzone = r3.cur.dropzone, n3.relatedTarget = r3.cur.element), "dragmove" === n3.type && r3.cur.dropzone && (o3.move = new J2.DropEvent(r3, n3, "dropmove"), o3.move.dragmove = n3, n3.dropzone = r3.cur.dropzone)), o3;
    }
    function dt2(t2, e2) {
      var n3 = t2.dropState, r3 = n3.activeDrops, o3 = n3.cur, i3 = n3.prev;
      e2.leave && i3.dropzone.fire(e2.leave), e2.enter && o3.dropzone.fire(e2.enter), e2.move && o3.dropzone.fire(e2.move), e2.drop && o3.dropzone.fire(e2.drop), e2.deactivate && lt2(r3, e2.deactivate), n3.prev.dropzone = o3.dropzone, n3.prev.element = o3.element;
    }
    function pt2(t2, e2) {
      var n3 = t2.interaction, r3 = t2.iEvent, o3 = t2.event;
      if ("dragmove" === r3.type || "dragend" === r3.type) {
        var i3 = n3.dropState;
        e2.dynamicDrop && (i3.activeDrops = ut2(e2, n3.element));
        var a3 = r3, s3 = ct2(n3, a3, o3);
        i3.rejected = i3.rejected && !!s3 && s3.dropzone === i3.cur.dropzone && s3.element === i3.cur.element, i3.cur.dropzone = s3 && s3.dropzone, i3.cur.element = s3 && s3.element, i3.events = ft2(n3, 0, a3);
      }
    }
    Object.defineProperty(st2, "__esModule", { value: true }), st2.default = void 0;
    var vt2 = { id: "actions/drop", install: function(t2) {
      var e2 = t2.actions, n3 = t2.interactStatic, r3 = t2.Interactable, o3 = t2.defaults;
      t2.usePlugin(c2.default), r3.prototype.dropzone = function(t3) {
        return function(t4, e3) {
          if (i2.default.object(e3)) {
            if (t4.options.drop.enabled = false !== e3.enabled, e3.listeners) {
              var n4 = (0, z2.default)(e3.listeners), r4 = Object.keys(n4).reduce(function(t5, e4) {
                return t5[/^(enter|leave)/.test(e4) ? "drag".concat(e4) : /^(activate|deactivate|move)/.test(e4) ? "drop".concat(e4) : e4] = n4[e4], t5;
              }, {});
              t4.off(t4.options.drop.listeners), t4.on(r4), t4.options.drop.listeners = r4;
            }
            return i2.default.func(e3.ondrop) && t4.on("drop", e3.ondrop), i2.default.func(e3.ondropactivate) && t4.on("dropactivate", e3.ondropactivate), i2.default.func(e3.ondropdeactivate) && t4.on("dropdeactivate", e3.ondropdeactivate), i2.default.func(e3.ondragenter) && t4.on("dragenter", e3.ondragenter), i2.default.func(e3.ondragleave) && t4.on("dragleave", e3.ondragleave), i2.default.func(e3.ondropmove) && t4.on("dropmove", e3.ondropmove), /^(pointer|center)$/.test(e3.overlap) ? t4.options.drop.overlap = e3.overlap : i2.default.number(e3.overlap) && (t4.options.drop.overlap = Math.max(Math.min(1, e3.overlap), 0)), "accept" in e3 && (t4.options.drop.accept = e3.accept), "checker" in e3 && (t4.options.drop.checker = e3.checker), t4;
          }
          return i2.default.bool(e3) ? (t4.options.drop.enabled = e3, t4) : t4.options.drop;
        }(this, t3);
      }, r3.prototype.dropCheck = function(t3, e3, n4, r4, o4, a3) {
        return function(t4, e4, n5, r5, o5, a4, s3) {
          var l3 = false;
          if (!(s3 = s3 || t4.getRect(a4)))
            return !!t4.options.drop.checker && t4.options.drop.checker(e4, n5, l3, t4, a4, r5, o5);
          var u3 = t4.options.drop.overlap;
          if ("pointer" === u3) {
            var c3 = (0, A2.default)(r5, o5, "drag"), f3 = X2.getPageXY(e4);
            f3.x += c3.x, f3.y += c3.y;
            var d3 = f3.x > s3.left && f3.x < s3.right, p3 = f3.y > s3.top && f3.y < s3.bottom;
            l3 = d3 && p3;
          }
          var v3 = r5.getRect(o5);
          if (v3 && "center" === u3) {
            var h3 = v3.left + v3.width / 2, g3 = v3.top + v3.height / 2;
            l3 = h3 >= s3.left && h3 <= s3.right && g3 >= s3.top && g3 <= s3.bottom;
          }
          return v3 && i2.default.number(u3) && (l3 = Math.max(0, Math.min(s3.right, v3.right) - Math.max(s3.left, v3.left)) * Math.max(0, Math.min(s3.bottom, v3.bottom) - Math.max(s3.top, v3.top)) / (v3.width * v3.height) >= u3), t4.options.drop.checker && (l3 = t4.options.drop.checker(e4, n5, l3, t4, a4, r5, o5)), l3;
        }(this, t3, e3, n4, r4, o4, a3);
      }, n3.dynamicDrop = function(e3) {
        return i2.default.bool(e3) ? (t2.dynamicDrop = e3, n3) : t2.dynamicDrop;
      }, (0, M.default)(e2.phaselessTypes, { dragenter: true, dragleave: true, dropactivate: true, dropdeactivate: true, dropmove: true, drop: true }), e2.methodDict.drop = "dropzone", t2.dynamicDrop = false, o3.actions.drop = vt2.defaults;
    }, listeners: { "interactions:before-action-start": function(t2) {
      var e2 = t2.interaction;
      "drag" === e2.prepared.name && (e2.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });
    }, "interactions:after-action-start": function(t2, e2) {
      var n3 = t2.interaction, r3 = (t2.event, t2.iEvent);
      if ("drag" === n3.prepared.name) {
        var o3 = n3.dropState;
        o3.activeDrops = null, o3.events = null, o3.activeDrops = ut2(e2, n3.element), o3.events = ft2(n3, 0, r3), o3.events.activate && (lt2(o3.activeDrops, o3.events.activate), e2.fire("actions/drop:start", { interaction: n3, dragEvent: r3 }));
      }
    }, "interactions:action-move": pt2, "interactions:after-action-move": function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.iEvent;
      "drag" === n3.prepared.name && (dt2(n3, n3.dropState.events), e2.fire("actions/drop:move", { interaction: n3, dragEvent: r3 }), n3.dropState.events = {});
    }, "interactions:action-end": function(t2, e2) {
      if ("drag" === t2.interaction.prepared.name) {
        var n3 = t2.interaction, r3 = t2.iEvent;
        pt2(t2, e2), dt2(n3, n3.dropState.events), e2.fire("actions/drop:end", { interaction: n3, dragEvent: r3 });
      }
    }, "interactions:stop": function(t2) {
      var e2 = t2.interaction;
      if ("drag" === e2.prepared.name) {
        var n3 = e2.dropState;
        n3 && (n3.activeDrops = null, n3.events = null, n3.cur.dropzone = null, n3.cur.element = null, n3.prev.dropzone = null, n3.prev.element = null, n3.rejected = false);
      }
    } }, getActiveDrops: ut2, getDrop: ct2, getDropEvents: ft2, fireDropEvents: dt2, defaults: { enabled: false, accept: null, overlap: "pointer" } }, ht2 = vt2;
    st2.default = ht2;
    var gt2 = {};
    function yt2(t2) {
      var e2 = t2.interaction, n3 = t2.iEvent, r3 = t2.phase;
      if ("gesture" === e2.prepared.name) {
        var o3 = e2.pointers.map(function(t3) {
          return t3.pointer;
        }), a3 = "start" === r3, s3 = "end" === r3, l3 = e2.interactable.options.deltaSource;
        if (n3.touches = [o3[0], o3[1]], a3)
          n3.distance = X2.touchDistance(o3, l3), n3.box = X2.touchBBox(o3), n3.scale = 1, n3.ds = 0, n3.angle = X2.touchAngle(o3, l3), n3.da = 0, e2.gesture.startDistance = n3.distance, e2.gesture.startAngle = n3.angle;
        else if (s3) {
          var u3 = e2.prevEvent;
          n3.distance = u3.distance, n3.box = u3.box, n3.scale = u3.scale, n3.ds = 0, n3.angle = u3.angle, n3.da = 0;
        } else
          n3.distance = X2.touchDistance(o3, l3), n3.box = X2.touchBBox(o3), n3.scale = n3.distance / e2.gesture.startDistance, n3.angle = X2.touchAngle(o3, l3), n3.ds = n3.scale - e2.gesture.scale, n3.da = n3.angle - e2.gesture.angle;
        e2.gesture.distance = n3.distance, e2.gesture.angle = n3.angle, i2.default.number(n3.scale) && n3.scale !== 1 / 0 && !isNaN(n3.scale) && (e2.gesture.scale = n3.scale);
      }
    }
    Object.defineProperty(gt2, "__esModule", { value: true }), gt2.default = void 0;
    var mt2 = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function(t2) {
      var e2 = t2.actions, n3 = t2.Interactable, r3 = t2.defaults;
      n3.prototype.gesturable = function(t3) {
        return i2.default.object(t3) ? (this.options.gesture.enabled = false !== t3.enabled, this.setPerAction("gesture", t3), this.setOnEvents("gesture", t3), this) : i2.default.bool(t3) ? (this.options.gesture.enabled = t3, this) : this.options.gesture;
      }, e2.map.gesture = mt2, e2.methodDict.gesture = "gesturable", r3.actions.gesture = mt2.defaults;
    }, listeners: { "interactions:action-start": yt2, "interactions:action-move": yt2, "interactions:action-end": yt2, "interactions:new": function(t2) {
      t2.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };
    }, "auto-start:check": function(t2) {
      if (!(t2.interaction.pointers.length < 2)) {
        var e2 = t2.interactable.options.gesture;
        if (e2 && e2.enabled)
          return t2.action = { name: "gesture" }, false;
      }
    } }, defaults: {}, getCursor: function() {
      return "";
    } }, bt2 = mt2;
    gt2.default = bt2;
    var xt2 = {};
    function wt2(t2, e2, n3, r3, o3, a3, s3) {
      if (!e2)
        return false;
      if (true === e2) {
        var l3 = i2.default.number(a3.width) ? a3.width : a3.right - a3.left, u3 = i2.default.number(a3.height) ? a3.height : a3.bottom - a3.top;
        if (s3 = Math.min(s3, Math.abs(("left" === t2 || "right" === t2 ? l3 : u3) / 2)), l3 < 0 && ("left" === t2 ? t2 = "right" : "right" === t2 && (t2 = "left")), u3 < 0 && ("top" === t2 ? t2 = "bottom" : "bottom" === t2 && (t2 = "top")), "left" === t2) {
          var c3 = l3 >= 0 ? a3.left : a3.right;
          return n3.x < c3 + s3;
        }
        if ("top" === t2) {
          var f3 = u3 >= 0 ? a3.top : a3.bottom;
          return n3.y < f3 + s3;
        }
        if ("right" === t2)
          return n3.x > (l3 >= 0 ? a3.right : a3.left) - s3;
        if ("bottom" === t2)
          return n3.y > (u3 >= 0 ? a3.bottom : a3.top) - s3;
      }
      return !!i2.default.element(r3) && (i2.default.element(e2) ? e2 === r3 : _2.matchesUpTo(r3, e2, o3));
    }
    function _t2(t2) {
      var e2 = t2.iEvent, n3 = t2.interaction;
      if ("resize" === n3.prepared.name && n3.resizeAxes) {
        var r3 = e2;
        n3.interactable.options.resize.square ? ("y" === n3.resizeAxes ? r3.delta.x = r3.delta.y : r3.delta.y = r3.delta.x, r3.axes = "xy") : (r3.axes = n3.resizeAxes, "x" === n3.resizeAxes ? r3.delta.y = 0 : "y" === n3.resizeAxes && (r3.delta.x = 0));
      }
    }
    Object.defineProperty(xt2, "__esModule", { value: true }), xt2.default = void 0;
    var Pt2 = { id: "actions/resize", before: ["actions/drag"], install: function(t2) {
      var e2 = t2.actions, n3 = t2.browser, r3 = t2.Interactable, o3 = t2.defaults;
      Pt2.cursors = function(t3) {
        return t3.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" };
      }(n3), Pt2.defaultMargin = n3.supportsTouch || n3.supportsPointerEvent ? 20 : 10, r3.prototype.resizable = function(e3) {
        return function(t3, e4, n4) {
          return i2.default.object(e4) ? (t3.options.resize.enabled = false !== e4.enabled, t3.setPerAction("resize", e4), t3.setOnEvents("resize", e4), i2.default.string(e4.axis) && /^x$|^y$|^xy$/.test(e4.axis) ? t3.options.resize.axis = e4.axis : null === e4.axis && (t3.options.resize.axis = n4.defaults.actions.resize.axis), i2.default.bool(e4.preserveAspectRatio) ? t3.options.resize.preserveAspectRatio = e4.preserveAspectRatio : i2.default.bool(e4.square) && (t3.options.resize.square = e4.square), t3) : i2.default.bool(e4) ? (t3.options.resize.enabled = e4, t3) : t3.options.resize;
        }(this, e3, t2);
      }, e2.map.resize = Pt2, e2.methodDict.resize = "resizable", o3.actions.resize = Pt2.defaults;
    }, listeners: { "interactions:new": function(t2) {
      t2.interaction.resizeAxes = "xy";
    }, "interactions:action-start": function(t2) {
      !function(t3) {
        var e2 = t3.iEvent, n3 = t3.interaction;
        if ("resize" === n3.prepared.name && n3.prepared.edges) {
          var r3 = e2, o3 = n3.rect;
          n3._rects = { start: (0, M.default)({}, o3), corrected: (0, M.default)({}, o3), previous: (0, M.default)({}, o3), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, r3.edges = n3.prepared.edges, r3.rect = n3._rects.corrected, r3.deltaRect = n3._rects.delta;
        }
      }(t2), _t2(t2);
    }, "interactions:action-move": function(t2) {
      !function(t3) {
        var e2 = t3.iEvent, n3 = t3.interaction;
        if ("resize" === n3.prepared.name && n3.prepared.edges) {
          var r3 = e2, o3 = n3.interactable.options.resize.invert, i3 = "reposition" === o3 || "negate" === o3, a3 = n3.rect, s3 = n3._rects, l3 = s3.start, u3 = s3.corrected, c3 = s3.delta, f3 = s3.previous;
          if ((0, M.default)(f3, u3), i3) {
            if ((0, M.default)(u3, a3), "reposition" === o3) {
              if (u3.top > u3.bottom) {
                var d3 = u3.top;
                u3.top = u3.bottom, u3.bottom = d3;
              }
              if (u3.left > u3.right) {
                var p3 = u3.left;
                u3.left = u3.right, u3.right = p3;
              }
            }
          } else
            u3.top = Math.min(a3.top, l3.bottom), u3.bottom = Math.max(a3.bottom, l3.top), u3.left = Math.min(a3.left, l3.right), u3.right = Math.max(a3.right, l3.left);
          for (var v3 in u3.width = u3.right - u3.left, u3.height = u3.bottom - u3.top, u3)
            c3[v3] = u3[v3] - f3[v3];
          r3.edges = n3.prepared.edges, r3.rect = u3, r3.deltaRect = c3;
        }
      }(t2), _t2(t2);
    }, "interactions:action-end": function(t2) {
      var e2 = t2.iEvent, n3 = t2.interaction;
      if ("resize" === n3.prepared.name && n3.prepared.edges) {
        var r3 = e2;
        r3.edges = n3.prepared.edges, r3.rect = n3._rects.corrected, r3.deltaRect = n3._rects.delta;
      }
    }, "auto-start:check": function(t2) {
      var e2 = t2.interaction, n3 = t2.interactable, r3 = t2.element, o3 = t2.rect, a3 = t2.buttons;
      if (o3) {
        var s3 = (0, M.default)({}, e2.coords.cur.page), l3 = n3.options.resize;
        if (l3 && l3.enabled && (!e2.pointerIsDown || !/mouse|pointer/.test(e2.pointerType) || 0 != (a3 & l3.mouseButtons))) {
          if (i2.default.object(l3.edges)) {
            var u3 = { left: false, right: false, top: false, bottom: false };
            for (var c3 in u3)
              u3[c3] = wt2(c3, l3.edges[c3], s3, e2._latestPointer.eventTarget, r3, o3, l3.margin || Pt2.defaultMargin);
            u3.left = u3.left && !u3.right, u3.top = u3.top && !u3.bottom, (u3.left || u3.right || u3.top || u3.bottom) && (t2.action = { name: "resize", edges: u3 });
          } else {
            var f3 = "y" !== l3.axis && s3.x > o3.right - Pt2.defaultMargin, d3 = "x" !== l3.axis && s3.y > o3.bottom - Pt2.defaultMargin;
            (f3 || d3) && (t2.action = { name: "resize", axes: (f3 ? "x" : "") + (d3 ? "y" : "") });
          }
          return !t2.action && void 0;
        }
      }
    } }, defaults: { square: false, preserveAspectRatio: false, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function(t2) {
      var e2 = t2.edges, n3 = t2.axis, r3 = t2.name, o3 = Pt2.cursors, i3 = null;
      if (n3)
        i3 = o3[r3 + n3];
      else if (e2) {
        for (var a3 = "", s3 = ["top", "bottom", "left", "right"], l3 = 0; l3 < s3.length; l3++) {
          var u3 = s3[l3];
          e2[u3] && (a3 += u3);
        }
        i3 = o3[a3];
      }
      return i3;
    }, defaultMargin: null }, Ot2 = Pt2;
    xt2.default = Ot2;
    var Et2 = {};
    Object.defineProperty(Et2, "__esModule", { value: true }), Et2.default = void 0;
    var St2 = { id: "actions", install: function(t2) {
      t2.usePlugin(gt2.default), t2.usePlugin(xt2.default), t2.usePlugin(c2.default), t2.usePlugin(st2.default);
    } };
    Et2.default = St2;
    var Tt2 = {};
    Object.defineProperty(Tt2, "__esModule", { value: true }), Tt2.default = void 0;
    var jt, Mt, kt = 0, It = { request: function(t2) {
      return jt(t2);
    }, cancel: function(t2) {
      return Mt(t2);
    }, init: function(t2) {
      if (jt = t2.requestAnimationFrame, Mt = t2.cancelAnimationFrame, !jt)
        for (var e2 = ["ms", "moz", "webkit", "o"], n3 = 0; n3 < e2.length; n3++) {
          var r3 = e2[n3];
          jt = t2["".concat(r3, "RequestAnimationFrame")], Mt = t2["".concat(r3, "CancelAnimationFrame")] || t2["".concat(r3, "CancelRequestAnimationFrame")];
        }
      jt = jt && jt.bind(t2), Mt = Mt && Mt.bind(t2), jt || (jt = function(e3) {
        var n4 = Date.now(), r4 = Math.max(0, 16 - (n4 - kt)), o3 = t2.setTimeout(function() {
          e3(n4 + r4);
        }, r4);
        return kt = n4 + r4, o3;
      }, Mt = function(t3) {
        return clearTimeout(t3);
      });
    } };
    Tt2.default = It;
    var Dt = {};
    Object.defineProperty(Dt, "__esModule", { value: true }), Dt.default = void 0, Dt.getContainer = zt2, Dt.getScroll = Ct2, Dt.getScrollSize = function(t2) {
      return i2.default.window(t2) && (t2 = window.document.body), { x: t2.scrollWidth, y: t2.scrollHeight };
    }, Dt.getScrollSizeDelta = function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.element, o3 = n3 && n3.interactable.options[n3.prepared.name].autoScroll;
      if (!o3 || !o3.enabled)
        return e2(), { x: 0, y: 0 };
      var i3 = zt2(o3.container, n3.interactable, r3), a3 = Ct2(i3);
      e2();
      var s3 = Ct2(i3);
      return { x: s3.x - a3.x, y: s3.y - a3.y };
    };
    var At = { defaults: { enabled: false, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: false, prevTime: 0, margin: 0, speed: 0, start: function(t2) {
      At.isScrolling = true, Tt2.default.cancel(At.i), t2.autoScroll = At, At.interaction = t2, At.prevTime = At.now(), At.i = Tt2.default.request(At.scroll);
    }, stop: function() {
      At.isScrolling = false, At.interaction && (At.interaction.autoScroll = null), Tt2.default.cancel(At.i);
    }, scroll: function() {
      var t2 = At.interaction, e2 = t2.interactable, n3 = t2.element, r3 = t2.prepared.name, o3 = e2.options[r3].autoScroll, a3 = zt2(o3.container, e2, n3), s3 = At.now(), l3 = (s3 - At.prevTime) / 1e3, u3 = o3.speed * l3;
      if (u3 >= 1) {
        var c3 = { x: At.x * u3, y: At.y * u3 };
        if (c3.x || c3.y) {
          var f3 = Ct2(a3);
          i2.default.window(a3) ? a3.scrollBy(c3.x, c3.y) : a3 && (a3.scrollLeft += c3.x, a3.scrollTop += c3.y);
          var d3 = Ct2(a3), p3 = { x: d3.x - f3.x, y: d3.y - f3.y };
          (p3.x || p3.y) && e2.fire({ type: "autoscroll", target: n3, interactable: e2, delta: p3, interaction: t2, container: a3 });
        }
        At.prevTime = s3;
      }
      At.isScrolling && (Tt2.default.cancel(At.i), At.i = Tt2.default.request(At.scroll));
    }, check: function(t2, e2) {
      var n3;
      return null == (n3 = t2.options[e2].autoScroll) ? void 0 : n3.enabled;
    }, onInteractionMove: function(t2) {
      var e2 = t2.interaction, n3 = t2.pointer;
      if (e2.interacting() && At.check(e2.interactable, e2.prepared.name))
        if (e2.simulation)
          At.x = At.y = 0;
        else {
          var r3, o3, a3, s3, l3 = e2.interactable, u3 = e2.element, c3 = e2.prepared.name, f3 = l3.options[c3].autoScroll, d3 = zt2(f3.container, l3, u3);
          if (i2.default.window(d3))
            s3 = n3.clientX < At.margin, r3 = n3.clientY < At.margin, o3 = n3.clientX > d3.innerWidth - At.margin, a3 = n3.clientY > d3.innerHeight - At.margin;
          else {
            var p3 = _2.getElementClientRect(d3);
            s3 = n3.clientX < p3.left + At.margin, r3 = n3.clientY < p3.top + At.margin, o3 = n3.clientX > p3.right - At.margin, a3 = n3.clientY > p3.bottom - At.margin;
          }
          At.x = o3 ? 1 : s3 ? -1 : 0, At.y = a3 ? 1 : r3 ? -1 : 0, At.isScrolling || (At.margin = f3.margin, At.speed = f3.speed, At.start(e2));
        }
    } };
    function zt2(t2, n3, r3) {
      return (i2.default.string(t2) ? (0, k2.getStringOptionResult)(t2, n3, r3) : t2) || (0, e.getWindow)(r3);
    }
    function Ct2(t2) {
      return i2.default.window(t2) && (t2 = window.document.body), { x: t2.scrollLeft, y: t2.scrollTop };
    }
    var Rt = { id: "auto-scroll", install: function(t2) {
      var e2 = t2.defaults, n3 = t2.actions;
      t2.autoScroll = At, At.now = function() {
        return t2.now();
      }, n3.phaselessTypes.autoscroll = true, e2.perAction.autoScroll = At.defaults;
    }, listeners: { "interactions:new": function(t2) {
      t2.interaction.autoScroll = null;
    }, "interactions:destroy": function(t2) {
      t2.interaction.autoScroll = null, At.stop(), At.interaction && (At.interaction = null);
    }, "interactions:stop": At.stop, "interactions:action-move": function(t2) {
      return At.onInteractionMove(t2);
    } } }, Ft = Rt;
    Dt.default = Ft;
    var Xt = {};
    Object.defineProperty(Xt, "__esModule", { value: true }), Xt.copyAction = function(t2, e2) {
      return t2.name = e2.name, t2.axis = e2.axis, t2.edges = e2.edges, t2;
    }, Xt.sign = void 0, Xt.warnOnce = function(t2, n3) {
      var r3 = false;
      return function() {
        return r3 || (e.window.console.warn(n3), r3 = true), t2.apply(this, arguments);
      };
    }, Xt.sign = function(t2) {
      return t2 >= 0 ? 1 : -1;
    };
    var Bt = {};
    function Yt(t2) {
      return i2.default.bool(t2) ? (this.options.styleCursor = t2, this) : null === t2 ? (delete this.options.styleCursor, this) : this.options.styleCursor;
    }
    function Wt(t2) {
      return i2.default.func(t2) ? (this.options.actionChecker = t2, this) : null === t2 ? (delete this.options.actionChecker, this) : this.options.actionChecker;
    }
    Object.defineProperty(Bt, "__esModule", { value: true }), Bt.default = void 0;
    var Lt = { id: "auto-start/interactableMethods", install: function(t2) {
      var e2 = t2.Interactable;
      e2.prototype.getAction = function(e3, n3, r3, o3) {
        var i3 = function(t3, e4, n4, r4, o4) {
          var i4 = t3.getRect(r4), a3 = { action: null, interactable: t3, interaction: n4, element: r4, rect: i4, buttons: e4.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[e4.button] };
          return o4.fire("auto-start:check", a3), a3.action;
        }(this, n3, r3, o3, t2);
        return this.options.actionChecker ? this.options.actionChecker(e3, n3, i3, this, o3, r3) : i3;
      }, e2.prototype.ignoreFrom = (0, Xt.warnOnce)(function(t3) {
        return this._backCompatOption("ignoreFrom", t3);
      }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e2.prototype.allowFrom = (0, Xt.warnOnce)(function(t3) {
        return this._backCompatOption("allowFrom", t3);
      }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e2.prototype.actionChecker = Wt, e2.prototype.styleCursor = Yt;
    } };
    Bt.default = Lt;
    var Ut = {};
    function Vt(t2, e2, n3, r3, o3) {
      return e2.testIgnoreAllow(e2.options[t2.name], n3, r3) && e2.options[t2.name].enabled && $t2(e2, n3, t2, o3) ? t2 : null;
    }
    function Nt(t2, e2, n3, r3, o3, i3, a3) {
      for (var s3 = 0, l3 = r3.length; s3 < l3; s3++) {
        var u3 = r3[s3], c3 = o3[s3], f3 = u3.getAction(e2, n3, t2, c3);
        if (f3) {
          var d3 = Vt(f3, u3, c3, i3, a3);
          if (d3)
            return { action: d3, interactable: u3, element: c3 };
        }
      }
      return { action: null, interactable: null, element: null };
    }
    function qt(t2, e2, n3, r3, o3) {
      var a3 = [], s3 = [], l3 = r3;
      function u3(t3) {
        a3.push(t3), s3.push(l3);
      }
      for (; i2.default.element(l3); ) {
        a3 = [], s3 = [], o3.interactables.forEachMatch(l3, u3);
        var c3 = Nt(t2, e2, n3, a3, s3, r3, o3);
        if (c3.action && !c3.interactable.options[c3.action.name].manualStart)
          return c3;
        l3 = _2.parentNode(l3);
      }
      return { action: null, interactable: null, element: null };
    }
    function Gt(t2, e2, n3) {
      var r3 = e2.action, o3 = e2.interactable, i3 = e2.element;
      r3 = r3 || { name: null }, t2.interactable = o3, t2.element = i3, (0, Xt.copyAction)(t2.prepared, r3), t2.rect = o3 && r3.name ? o3.getRect(i3) : null, Zt(t2, n3), n3.fire("autoStart:prepared", { interaction: t2 });
    }
    function $t2(t2, e2, n3, r3) {
      var o3 = t2.options, i3 = o3[n3.name].max, a3 = o3[n3.name].maxPerElement, s3 = r3.autoStart.maxInteractions, l3 = 0, u3 = 0, c3 = 0;
      if (!(i3 && a3 && s3))
        return false;
      for (var f3 = 0; f3 < r3.interactions.list.length; f3++) {
        var d3 = r3.interactions.list[f3], p3 = d3.prepared.name;
        if (d3.interacting()) {
          if (++l3 >= s3)
            return false;
          if (d3.interactable === t2) {
            if ((u3 += p3 === n3.name ? 1 : 0) >= i3)
              return false;
            if (d3.element === e2 && (c3++, p3 === n3.name && c3 >= a3))
              return false;
          }
        }
      }
      return s3 > 0;
    }
    function Ht(t2, e2) {
      return i2.default.number(t2) ? (e2.autoStart.maxInteractions = t2, this) : e2.autoStart.maxInteractions;
    }
    function Kt(t2, e2, n3) {
      var r3 = n3.autoStart.cursorElement;
      r3 && r3 !== t2 && (r3.style.cursor = ""), t2.ownerDocument.documentElement.style.cursor = e2, t2.style.cursor = e2, n3.autoStart.cursorElement = e2 ? t2 : null;
    }
    function Zt(t2, e2) {
      var n3 = t2.interactable, r3 = t2.element, o3 = t2.prepared;
      if ("mouse" === t2.pointerType && n3 && n3.options.styleCursor) {
        var a3 = "";
        if (o3.name) {
          var s3 = n3.options[o3.name].cursorChecker;
          a3 = i2.default.func(s3) ? s3(o3, n3, r3, t2._interacting) : e2.actions.map[o3.name].getCursor(o3);
        }
        Kt(t2.element, a3 || "", e2);
      } else
        e2.autoStart.cursorElement && Kt(e2.autoStart.cursorElement, "", e2);
    }
    Object.defineProperty(Ut, "__esModule", { value: true }), Ut.default = void 0;
    var Jt = { id: "auto-start/base", before: ["actions"], install: function(t2) {
      var e2 = t2.interactStatic, n3 = t2.defaults;
      t2.usePlugin(Bt.default), n3.base.actionChecker = null, n3.base.styleCursor = true, (0, M.default)(n3.perAction, { manualStart: false, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e2.maxInteractions = function(e3) {
        return Ht(e3, t2);
      }, t2.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: $t2, cursorElement: null };
    }, listeners: { "interactions:down": function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.pointer, o3 = t2.event, i3 = t2.eventTarget;
      n3.interacting() || Gt(n3, qt(n3, r3, o3, i3, e2), e2);
    }, "interactions:move": function(t2, e2) {
      !function(t3, e3) {
        var n3 = t3.interaction, r3 = t3.pointer, o3 = t3.event, i3 = t3.eventTarget;
        "mouse" !== n3.pointerType || n3.pointerIsDown || n3.interacting() || Gt(n3, qt(n3, r3, o3, i3, e3), e3);
      }(t2, e2), function(t3, e3) {
        var n3 = t3.interaction;
        if (n3.pointerIsDown && !n3.interacting() && n3.pointerWasMoved && n3.prepared.name) {
          e3.fire("autoStart:before-start", t3);
          var r3 = n3.interactable, o3 = n3.prepared.name;
          o3 && r3 && (r3.options[o3].manualStart || !$t2(r3, n3.element, n3.prepared, e3) ? n3.stop() : (n3.start(n3.prepared, r3, n3.element), Zt(n3, e3)));
        }
      }(t2, e2);
    }, "interactions:stop": function(t2, e2) {
      var n3 = t2.interaction, r3 = n3.interactable;
      r3 && r3.options.styleCursor && Kt(n3.element, "", e2);
    } }, maxInteractions: Ht, withinInteractionLimit: $t2, validateAction: Vt }, Qt = Jt;
    Ut.default = Qt;
    var te = {};
    Object.defineProperty(te, "__esModule", { value: true }), te.default = void 0;
    var ee = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.eventTarget, o3 = t2.dx, a3 = t2.dy;
      if ("drag" === n3.prepared.name) {
        var s3 = Math.abs(o3), l3 = Math.abs(a3), u3 = n3.interactable.options.drag, c3 = u3.startAxis, f3 = s3 > l3 ? "x" : s3 < l3 ? "y" : "xy";
        if (n3.prepared.axis = "start" === u3.lockAxis ? f3[0] : u3.lockAxis, "xy" !== f3 && "xy" !== c3 && c3 !== f3) {
          n3.prepared.name = null;
          for (var d3 = r3, p3 = function(t3) {
            if (t3 !== n3.interactable) {
              var o4 = n3.interactable.options.drag;
              if (!o4.manualStart && t3.testIgnoreAllow(o4, d3, r3)) {
                var i3 = t3.getAction(n3.downPointer, n3.downEvent, n3, d3);
                if (i3 && "drag" === i3.name && function(t4, e3) {
                  if (!e3)
                    return false;
                  var n4 = e3.options.drag.startAxis;
                  return "xy" === t4 || "xy" === n4 || n4 === t4;
                }(f3, t3) && Ut.default.validateAction(i3, t3, d3, r3, e2))
                  return t3;
              }
            }
          }; i2.default.element(d3); ) {
            var v3 = e2.interactables.forEachMatch(d3, p3);
            if (v3) {
              n3.prepared.name = "drag", n3.interactable = v3, n3.element = d3;
              break;
            }
            d3 = (0, _2.parentNode)(d3);
          }
        }
      }
    } } };
    te.default = ee;
    var ne2 = {};
    function re2(t2) {
      var e2 = t2.prepared && t2.prepared.name;
      if (!e2)
        return null;
      var n3 = t2.interactable.options;
      return n3[e2].hold || n3[e2].delay;
    }
    Object.defineProperty(ne2, "__esModule", { value: true }), ne2.default = void 0;
    var oe2 = { id: "auto-start/hold", install: function(t2) {
      var e2 = t2.defaults;
      t2.usePlugin(Ut.default), e2.perAction.hold = 0, e2.perAction.delay = 0;
    }, listeners: { "interactions:new": function(t2) {
      t2.interaction.autoStartHoldTimer = null;
    }, "autoStart:prepared": function(t2) {
      var e2 = t2.interaction, n3 = re2(e2);
      n3 > 0 && (e2.autoStartHoldTimer = setTimeout(function() {
        e2.start(e2.prepared, e2.interactable, e2.element);
      }, n3));
    }, "interactions:move": function(t2) {
      var e2 = t2.interaction, n3 = t2.duplicate;
      e2.autoStartHoldTimer && e2.pointerWasMoved && !n3 && (clearTimeout(e2.autoStartHoldTimer), e2.autoStartHoldTimer = null);
    }, "autoStart:before-start": function(t2) {
      var e2 = t2.interaction;
      re2(e2) > 0 && (e2.prepared.name = null);
    } }, getHoldDuration: re2 }, ie2 = oe2;
    ne2.default = ie2;
    var ae2 = {};
    Object.defineProperty(ae2, "__esModule", { value: true }), ae2.default = void 0;
    var se2 = { id: "auto-start", install: function(t2) {
      t2.usePlugin(Ut.default), t2.usePlugin(ne2.default), t2.usePlugin(te.default);
    } };
    ae2.default = se2;
    var le2 = {};
    function ue2(t2) {
      return /^(always|never|auto)$/.test(t2) ? (this.options.preventDefault = t2, this) : i2.default.bool(t2) ? (this.options.preventDefault = t2 ? "always" : "never", this) : this.options.preventDefault;
    }
    function ce(t2) {
      var e2 = t2.interaction, n3 = t2.event;
      e2.interactable && e2.interactable.checkAndPreventDefault(n3);
    }
    function fe2(t2) {
      var n3 = t2.Interactable;
      n3.prototype.preventDefault = ue2, n3.prototype.checkAndPreventDefault = function(n4) {
        return function(t3, n5, r3) {
          var o3 = t3.options.preventDefault;
          if ("never" !== o3)
            if ("always" !== o3) {
              if (n5.events.supportsPassive && /^touch(start|move)$/.test(r3.type)) {
                var a3 = (0, e.getWindow)(r3.target).document, s3 = n5.getDocOptions(a3);
                if (!s3 || !s3.events || false !== s3.events.passive)
                  return;
              }
              /^(mouse|pointer|touch)*(down|start)/i.test(r3.type) || i2.default.element(r3.target) && (0, _2.matchesSelector)(r3.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || r3.preventDefault();
            } else
              r3.preventDefault();
        }(this, t2, n4);
      }, t2.interactions.docEvents.push({ type: "dragstart", listener: function(e2) {
        for (var n4 = 0; n4 < t2.interactions.list.length; n4++) {
          var r3 = t2.interactions.list[n4];
          if (r3.element && (r3.element === e2.target || (0, _2.nodeContains)(r3.element, e2.target)))
            return void r3.interactable.checkAndPreventDefault(e2);
        }
      } });
    }
    Object.defineProperty(le2, "__esModule", { value: true }), le2.default = void 0, le2.install = fe2;
    var de2 = { id: "core/interactablePreventDefault", install: fe2, listeners: ["down", "move", "up", "cancel"].reduce(function(t2, e2) {
      return t2["interactions:".concat(e2)] = ce, t2;
    }, {}) };
    le2.default = de2;
    var pe2 = {};
    Object.defineProperty(pe2, "__esModule", { value: true }), pe2.default = void 0, pe2.default = {};
    var ve2, he2 = {};
    Object.defineProperty(he2, "__esModule", { value: true }), he2.default = void 0, function(t2) {
      t2.touchAction = "touchAction", t2.boxSizing = "boxSizing", t2.noListeners = "noListeners";
    }(ve2 || (ve2 = {}));
    ve2.touchAction, ve2.boxSizing, ve2.noListeners;
    var ge2 = { id: "dev-tools", install: function() {
    } };
    he2.default = ge2;
    var ye2 = {};
    Object.defineProperty(ye2, "__esModule", { value: true }), ye2.default = function t2(e2) {
      var n3 = {};
      for (var r3 in e2) {
        var o3 = e2[r3];
        i2.default.plainObject(o3) ? n3[r3] = t2(o3) : i2.default.array(o3) ? n3[r3] = H2.from(o3) : n3[r3] = o3;
      }
      return n3;
    };
    var me2 = {};
    function be2(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var n3 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null != n3) {
          var r3, o3, i3 = [], a3 = true, s3 = false;
          try {
            for (n3 = n3.call(t3); !(a3 = (r3 = n3.next()).done) && (i3.push(r3.value), !e3 || i3.length !== e3); a3 = true)
              ;
          } catch (t4) {
            s3 = true, o3 = t4;
          } finally {
            try {
              a3 || null == n3.return || n3.return();
            } finally {
              if (s3)
                throw o3;
            }
          }
          return i3;
        }
      }(t2, e2) || function(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return xe(t3, e3);
          var n3 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? xe(t3, e3) : void 0;
        }
      }(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function xe(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    function we2(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function _e2(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(me2, "__esModule", { value: true }), me2.default = void 0, me2.getRectOffset = Ee;
    var Pe2 = function() {
      function t2(e3) {
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), _e2(this, "states", []), _e2(this, "startOffset", { left: 0, right: 0, top: 0, bottom: 0 }), _e2(this, "startDelta", void 0), _e2(this, "result", void 0), _e2(this, "endResult", void 0), _e2(this, "startEdges", void 0), _e2(this, "edges", void 0), _e2(this, "interaction", void 0), this.interaction = e3, this.result = Oe(), this.edges = { left: false, right: false, top: false, bottom: false };
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "start", value: function(t3, e3) {
        var n4 = t3.phase, r3 = this.interaction, o3 = function(t4) {
          var e4 = t4.interactable.options[t4.prepared.name], n5 = e4.modifiers;
          return n5 && n5.length ? n5 : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map(function(t5) {
            var n6 = e4[t5];
            return n6 && n6.enabled && { options: n6, methods: n6._methods };
          }).filter(function(t5) {
            return !!t5;
          });
        }(r3);
        this.prepareStates(o3), this.startEdges = (0, M.default)({}, r3.edges), this.edges = (0, M.default)({}, this.startEdges), this.startOffset = Ee(r3.rect, e3), this.startDelta = { x: 0, y: 0 };
        var i3 = this.fillArg({ phase: n4, pageCoords: e3, preEnd: false });
        return this.result = Oe(), this.startAll(i3), this.result = this.setAll(i3);
      } }, { key: "fillArg", value: function(t3) {
        var e3 = this.interaction;
        return t3.interaction = e3, t3.interactable = e3.interactable, t3.element = e3.element, t3.rect || (t3.rect = e3.rect), t3.edges || (t3.edges = this.startEdges), t3.startOffset = this.startOffset, t3;
      } }, { key: "startAll", value: function(t3) {
        for (var e3 = 0; e3 < this.states.length; e3++) {
          var n4 = this.states[e3];
          n4.methods.start && (t3.state = n4, n4.methods.start(t3));
        }
      } }, { key: "setAll", value: function(t3) {
        var e3 = t3.phase, n4 = t3.preEnd, r3 = t3.skipModifiers, o3 = t3.rect, i3 = t3.edges;
        t3.coords = (0, M.default)({}, t3.pageCoords), t3.rect = (0, M.default)({}, o3), t3.edges = (0, M.default)({}, i3);
        for (var a3 = r3 ? this.states.slice(r3) : this.states, s3 = Oe(t3.coords, t3.rect), l3 = 0; l3 < a3.length; l3++) {
          var u3, c3 = a3[l3], f3 = c3.options, d3 = (0, M.default)({}, t3.coords), p3 = null;
          null != (u3 = c3.methods) && u3.set && this.shouldDo(f3, n4, e3) && (t3.state = c3, p3 = c3.methods.set(t3), k2.addEdges(t3.edges, t3.rect, { x: t3.coords.x - d3.x, y: t3.coords.y - d3.y })), s3.eventProps.push(p3);
        }
        (0, M.default)(this.edges, t3.edges), s3.delta.x = t3.coords.x - t3.pageCoords.x, s3.delta.y = t3.coords.y - t3.pageCoords.y, s3.rectDelta.left = t3.rect.left - o3.left, s3.rectDelta.right = t3.rect.right - o3.right, s3.rectDelta.top = t3.rect.top - o3.top, s3.rectDelta.bottom = t3.rect.bottom - o3.bottom;
        var v3 = this.result.coords, h3 = this.result.rect;
        if (v3 && h3) {
          var g3 = s3.rect.left !== h3.left || s3.rect.right !== h3.right || s3.rect.top !== h3.top || s3.rect.bottom !== h3.bottom;
          s3.changed = g3 || v3.x !== s3.coords.x || v3.y !== s3.coords.y;
        }
        return s3;
      } }, { key: "applyToInteraction", value: function(t3) {
        var e3 = this.interaction, n4 = t3.phase, r3 = e3.coords.cur, o3 = e3.coords.start, i3 = this.result, a3 = this.startDelta, s3 = i3.delta;
        "start" === n4 && (0, M.default)(this.startDelta, i3.delta);
        for (var l3 = 0; l3 < [[o3, a3], [r3, s3]].length; l3++) {
          var u3 = be2([[o3, a3], [r3, s3]][l3], 2), c3 = u3[0], f3 = u3[1];
          c3.page.x += f3.x, c3.page.y += f3.y, c3.client.x += f3.x, c3.client.y += f3.y;
        }
        var d3 = this.result.rectDelta, p3 = t3.rect || e3.rect;
        p3.left += d3.left, p3.right += d3.right, p3.top += d3.top, p3.bottom += d3.bottom, p3.width = p3.right - p3.left, p3.height = p3.bottom - p3.top;
      } }, { key: "setAndApply", value: function(t3) {
        var e3 = this.interaction, n4 = t3.phase, r3 = t3.preEnd, o3 = t3.skipModifiers, i3 = this.setAll(this.fillArg({ preEnd: r3, phase: n4, pageCoords: t3.modifiedCoords || e3.coords.cur.page }));
        if (this.result = i3, !i3.changed && (!o3 || o3 < this.states.length) && e3.interacting())
          return false;
        if (t3.modifiedCoords) {
          var a3 = e3.coords.cur.page, s3 = { x: t3.modifiedCoords.x - a3.x, y: t3.modifiedCoords.y - a3.y };
          i3.coords.x += s3.x, i3.coords.y += s3.y, i3.delta.x += s3.x, i3.delta.y += s3.y;
        }
        this.applyToInteraction(t3);
      } }, { key: "beforeEnd", value: function(t3) {
        var e3 = t3.interaction, n4 = t3.event, r3 = this.states;
        if (r3 && r3.length) {
          for (var o3 = false, i3 = 0; i3 < r3.length; i3++) {
            var a3 = r3[i3];
            t3.state = a3;
            var s3 = a3.options, l3 = a3.methods, u3 = l3.beforeEnd && l3.beforeEnd(t3);
            if (u3)
              return this.endResult = u3, false;
            o3 = o3 || !o3 && this.shouldDo(s3, true, t3.phase, true);
          }
          o3 && e3.move({ event: n4, preEnd: true });
        }
      } }, { key: "stop", value: function(t3) {
        var e3 = t3.interaction;
        if (this.states && this.states.length) {
          var n4 = (0, M.default)({ states: this.states, interactable: e3.interactable, element: e3.element, rect: null }, t3);
          this.fillArg(n4);
          for (var r3 = 0; r3 < this.states.length; r3++) {
            var o3 = this.states[r3];
            n4.state = o3, o3.methods.stop && o3.methods.stop(n4);
          }
          this.states = null, this.endResult = null;
        }
      } }, { key: "prepareStates", value: function(t3) {
        this.states = [];
        for (var e3 = 0; e3 < t3.length; e3++) {
          var n4 = t3[e3], r3 = n4.options, o3 = n4.methods, i3 = n4.name;
          this.states.push({ options: r3, methods: o3, index: e3, name: i3 });
        }
        return this.states;
      } }, { key: "restoreInteractionCoords", value: function(t3) {
        var e3 = t3.interaction, n4 = e3.coords, r3 = e3.rect, o3 = e3.modification;
        if (o3.result) {
          for (var i3 = o3.startDelta, a3 = o3.result, s3 = a3.delta, l3 = a3.rectDelta, u3 = [[n4.start, i3], [n4.cur, s3]], c3 = 0; c3 < u3.length; c3++) {
            var f3 = be2(u3[c3], 2), d3 = f3[0], p3 = f3[1];
            d3.page.x -= p3.x, d3.page.y -= p3.y, d3.client.x -= p3.x, d3.client.y -= p3.y;
          }
          r3.left -= l3.left, r3.right -= l3.right, r3.top -= l3.top, r3.bottom -= l3.bottom;
        }
      } }, { key: "shouldDo", value: function(t3, e3, n4, r3) {
        return !(!t3 || false === t3.enabled || r3 && !t3.endOnly || t3.endOnly && !e3 || "start" === n4 && !t3.setStart);
      } }, { key: "copyFrom", value: function(t3) {
        this.startOffset = t3.startOffset, this.startDelta = t3.startDelta, this.startEdges = t3.startEdges, this.edges = t3.edges, this.states = t3.states.map(function(t4) {
          return (0, ye2.default)(t4);
        }), this.result = Oe((0, M.default)({}, t3.result.coords), (0, M.default)({}, t3.result.rect));
      } }, { key: "destroy", value: function() {
        for (var t3 in this)
          this[t3] = null;
      } }]) && we2(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    function Oe(t2, e2) {
      return { rect: e2, coords: t2, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: true };
    }
    function Ee(t2, e2) {
      return t2 ? { left: e2.x - t2.left, top: e2.y - t2.top, right: t2.right - e2.x, bottom: t2.bottom - e2.y } : { left: 0, top: 0, right: 0, bottom: 0 };
    }
    me2.default = Pe2;
    var Se2 = {};
    function Te2(t2) {
      var e2 = t2.iEvent, n3 = t2.interaction.modification.result;
      n3 && (e2.modifiers = n3.eventProps);
    }
    Object.defineProperty(Se2, "__esModule", { value: true }), Se2.addEventModifiers = Te2, Se2.default = void 0, Se2.makeModifier = function(t2, e2) {
      var n3 = t2.defaults, r3 = { start: t2.start, set: t2.set, beforeEnd: t2.beforeEnd, stop: t2.stop }, o3 = function(t3) {
        var o4 = t3 || {};
        for (var i3 in o4.enabled = false !== o4.enabled, n3)
          i3 in o4 || (o4[i3] = n3[i3]);
        var a3 = { options: o4, methods: r3, name: e2, enable: function() {
          return o4.enabled = true, a3;
        }, disable: function() {
          return o4.enabled = false, a3;
        } };
        return a3;
      };
      return e2 && "string" == typeof e2 && (o3._defaults = n3, o3._methods = r3), o3;
    };
    var je = { id: "modifiers/base", before: ["actions"], install: function(t2) {
      t2.defaults.perAction.modifiers = [];
    }, listeners: { "interactions:new": function(t2) {
      var e2 = t2.interaction;
      e2.modification = new me2.default(e2);
    }, "interactions:before-action-start": function(t2) {
      var e2 = t2.interaction, n3 = t2.interaction.modification;
      n3.start(t2, e2.coords.start.page), e2.edges = n3.edges, n3.applyToInteraction(t2);
    }, "interactions:before-action-move": function(t2) {
      var e2 = t2.interaction, n3 = e2.modification, r3 = n3.setAndApply(t2);
      return e2.edges = n3.edges, r3;
    }, "interactions:before-action-end": function(t2) {
      var e2 = t2.interaction, n3 = e2.modification, r3 = n3.beforeEnd(t2);
      return e2.edges = n3.startEdges, r3;
    }, "interactions:action-start": Te2, "interactions:action-move": Te2, "interactions:action-end": Te2, "interactions:after-action-start": function(t2) {
      return t2.interaction.modification.restoreInteractionCoords(t2);
    }, "interactions:after-action-move": function(t2) {
      return t2.interaction.modification.restoreInteractionCoords(t2);
    }, "interactions:stop": function(t2) {
      return t2.interaction.modification.stop(t2);
    } } }, Me = je;
    Se2.default = Me;
    var ke = {};
    Object.defineProperty(ke, "__esModule", { value: true }), ke.defaults = void 0, ke.defaults = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: false, origin: { x: 0, y: 0 } }, actions: {} };
    var Ie = {};
    function De(t2) {
      return De = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, De(t2);
    }
    function Ae2(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function ze2(t2, e2) {
      return ze2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, ze2(t2, e2);
    }
    function Ce2(t2, e2) {
      if (e2 && ("object" === De(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return Re(t2);
    }
    function Re(t2) {
      if (void 0 === t2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }
    function Fe(t2) {
      return Fe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, Fe(t2);
    }
    function Xe(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(Ie, "__esModule", { value: true }), Ie.InteractEvent = void 0;
    var Be = function(t2) {
      !function(t3, e3) {
        if ("function" != typeof e3 && null !== e3)
          throw new TypeError("Super expression must either be null or a function");
        t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), Object.defineProperty(t3, "prototype", { writable: false }), e3 && ze2(t3, e3);
      }(a3, t2);
      var e2, n3, r3, o3, i3 = (r3 = a3, o3 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }(), function() {
        var t3, e3 = Fe(r3);
        if (o3) {
          var n4 = Fe(this).constructor;
          t3 = Reflect.construct(e3, arguments, n4);
        } else
          t3 = e3.apply(this, arguments);
        return Ce2(this, t3);
      });
      function a3(t3, e3, n4, r4, o4, s3, l3) {
        var u3;
        !function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, a3), Xe(Re(u3 = i3.call(this, t3)), "relatedTarget", null), Xe(Re(u3), "screenX", void 0), Xe(Re(u3), "screenY", void 0), Xe(Re(u3), "button", void 0), Xe(Re(u3), "buttons", void 0), Xe(Re(u3), "ctrlKey", void 0), Xe(Re(u3), "shiftKey", void 0), Xe(Re(u3), "altKey", void 0), Xe(Re(u3), "metaKey", void 0), Xe(Re(u3), "page", void 0), Xe(Re(u3), "client", void 0), Xe(Re(u3), "delta", void 0), Xe(Re(u3), "rect", void 0), Xe(Re(u3), "x0", void 0), Xe(Re(u3), "y0", void 0), Xe(Re(u3), "t0", void 0), Xe(Re(u3), "dt", void 0), Xe(Re(u3), "duration", void 0), Xe(Re(u3), "clientX0", void 0), Xe(Re(u3), "clientY0", void 0), Xe(Re(u3), "velocity", void 0), Xe(Re(u3), "speed", void 0), Xe(Re(u3), "swipe", void 0), Xe(Re(u3), "axes", void 0), Xe(Re(u3), "preEnd", void 0), o4 = o4 || t3.element;
        var c3 = t3.interactable, f3 = (c3 && c3.options || ke.defaults).deltaSource, d3 = (0, A2.default)(c3, o4, n4), p3 = "start" === r4, v3 = "end" === r4, h3 = p3 ? Re(u3) : t3.prevEvent, g3 = p3 ? t3.coords.start : v3 ? { page: h3.page, client: h3.client, timeStamp: t3.coords.cur.timeStamp } : t3.coords.cur;
        return u3.page = (0, M.default)({}, g3.page), u3.client = (0, M.default)({}, g3.client), u3.rect = (0, M.default)({}, t3.rect), u3.timeStamp = g3.timeStamp, v3 || (u3.page.x -= d3.x, u3.page.y -= d3.y, u3.client.x -= d3.x, u3.client.y -= d3.y), u3.ctrlKey = e3.ctrlKey, u3.altKey = e3.altKey, u3.shiftKey = e3.shiftKey, u3.metaKey = e3.metaKey, u3.button = e3.button, u3.buttons = e3.buttons, u3.target = o4, u3.currentTarget = o4, u3.preEnd = s3, u3.type = l3 || n4 + (r4 || ""), u3.interactable = c3, u3.t0 = p3 ? t3.pointers[t3.pointers.length - 1].downTime : h3.t0, u3.x0 = t3.coords.start.page.x - d3.x, u3.y0 = t3.coords.start.page.y - d3.y, u3.clientX0 = t3.coords.start.client.x - d3.x, u3.clientY0 = t3.coords.start.client.y - d3.y, u3.delta = p3 || v3 ? { x: 0, y: 0 } : { x: u3[f3].x - h3[f3].x, y: u3[f3].y - h3[f3].y }, u3.dt = t3.coords.delta.timeStamp, u3.duration = u3.timeStamp - u3.t0, u3.velocity = (0, M.default)({}, t3.coords.velocity[f3]), u3.speed = (0, R2.default)(u3.velocity.x, u3.velocity.y), u3.swipe = v3 || "inertiastart" === r4 ? u3.getSwipe() : null, u3;
      }
      return e2 = a3, (n3 = [{ key: "getSwipe", value: function() {
        var t3 = this._interaction;
        if (t3.prevEvent.speed < 600 || this.timeStamp - t3.prevEvent.timeStamp > 150)
          return null;
        var e3 = 180 * Math.atan2(t3.prevEvent.velocityY, t3.prevEvent.velocityX) / Math.PI;
        e3 < 0 && (e3 += 360);
        var n4 = 112.5 <= e3 && e3 < 247.5, r4 = 202.5 <= e3 && e3 < 337.5;
        return { up: r4, down: !r4 && 22.5 <= e3 && e3 < 157.5, left: n4, right: !n4 && (292.5 <= e3 || e3 < 67.5), angle: e3, speed: t3.prevEvent.speed, velocity: { x: t3.prevEvent.velocityX, y: t3.prevEvent.velocityY } };
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = true;
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = true;
      } }]) && Ae2(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), a3;
    }(N.BaseEvent);
    Ie.InteractEvent = Be, Object.defineProperties(Be.prototype, { pageX: { get: function() {
      return this.page.x;
    }, set: function(t2) {
      this.page.x = t2;
    } }, pageY: { get: function() {
      return this.page.y;
    }, set: function(t2) {
      this.page.y = t2;
    } }, clientX: { get: function() {
      return this.client.x;
    }, set: function(t2) {
      this.client.x = t2;
    } }, clientY: { get: function() {
      return this.client.y;
    }, set: function(t2) {
      this.client.y = t2;
    } }, dx: { get: function() {
      return this.delta.x;
    }, set: function(t2) {
      this.delta.x = t2;
    } }, dy: { get: function() {
      return this.delta.y;
    }, set: function(t2) {
      this.delta.y = t2;
    } }, velocityX: { get: function() {
      return this.velocity.x;
    }, set: function(t2) {
      this.velocity.x = t2;
    } }, velocityY: { get: function() {
      return this.velocity.y;
    }, set: function(t2) {
      this.velocity.y = t2;
    } } });
    var Ye = {};
    function We(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function Le(t2, e2, n3) {
      return e2 && We(t2.prototype, e2), n3 && We(t2, n3), Object.defineProperty(t2, "prototype", { writable: false }), t2;
    }
    function Ue(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(Ye, "__esModule", { value: true }), Ye.PointerInfo = void 0;
    var Ve = Le(function t2(e2, n3, r3, o3, i3) {
      !function(t3, e3) {
        if (!(t3 instanceof e3))
          throw new TypeError("Cannot call a class as a function");
      }(this, t2), Ue(this, "id", void 0), Ue(this, "pointer", void 0), Ue(this, "event", void 0), Ue(this, "downTime", void 0), Ue(this, "downTarget", void 0), this.id = e2, this.pointer = n3, this.event = r3, this.downTime = o3, this.downTarget = i3;
    });
    Ye.PointerInfo = Ve;
    var Ne2, qe, Ge = {};
    function $e2(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function He2(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(Ge, "__esModule", { value: true }), Ge.Interaction = void 0, Object.defineProperty(Ge, "PointerInfo", { enumerable: true, get: function() {
      return Ye.PointerInfo;
    } }), Ge.default = Ge._ProxyValues = Ge._ProxyMethods = void 0, Ge._ProxyValues = Ne2, function(t2) {
      t2.interactable = "", t2.element = "", t2.prepared = "", t2.pointerIsDown = "", t2.pointerWasMoved = "", t2._proxy = "";
    }(Ne2 || (Ge._ProxyValues = Ne2 = {})), Ge._ProxyMethods = qe, function(t2) {
      t2.start = "", t2.move = "", t2.end = "", t2.stop = "", t2.interacting = "";
    }(qe || (Ge._ProxyMethods = qe = {}));
    var Ke = 0, Ze2 = function() {
      function t2(e3) {
        var n4 = this, r3 = e3.pointerType, o3 = e3.scopeFire;
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), He2(this, "interactable", null), He2(this, "element", null), He2(this, "rect", null), He2(this, "_rects", void 0), He2(this, "edges", null), He2(this, "_scopeFire", void 0), He2(this, "prepared", { name: null, axis: null, edges: null }), He2(this, "pointerType", void 0), He2(this, "pointers", []), He2(this, "downEvent", null), He2(this, "downPointer", {}), He2(this, "_latestPointer", { pointer: null, event: null, eventTarget: null }), He2(this, "prevEvent", null), He2(this, "pointerIsDown", false), He2(this, "pointerWasMoved", false), He2(this, "_interacting", false), He2(this, "_ending", false), He2(this, "_stopped", true), He2(this, "_proxy", null), He2(this, "simulation", null), He2(this, "doMove", (0, Xt.warnOnce)(function(t3) {
          this.move(t3);
        }, "The interaction.doMove() method has been renamed to interaction.move()")), He2(this, "coords", { start: X2.newCoords(), prev: X2.newCoords(), cur: X2.newCoords(), delta: X2.newCoords(), velocity: X2.newCoords() }), He2(this, "_id", Ke++), this._scopeFire = o3, this.pointerType = r3;
        var i3 = this;
        this._proxy = {};
        var a3 = function(t3) {
          Object.defineProperty(n4._proxy, t3, { get: function() {
            return i3[t3];
          } });
        };
        for (var s3 in Ne2)
          a3(s3);
        var l3 = function(t3) {
          Object.defineProperty(n4._proxy, t3, { value: function() {
            return i3[t3].apply(i3, arguments);
          } });
        };
        for (var u3 in qe)
          l3(u3);
        this._scopeFire("interactions:new", { interaction: this });
      }
      var e2, n3;
      return e2 = t2, n3 = [{ key: "pointerMoveTolerance", get: function() {
        return 1;
      } }, { key: "pointerDown", value: function(t3, e3, n4) {
        var r3 = this.updatePointer(t3, e3, n4, true), o3 = this.pointers[r3];
        this._scopeFire("interactions:down", { pointer: t3, event: e3, eventTarget: n4, pointerIndex: r3, pointerInfo: o3, type: "down", interaction: this });
      } }, { key: "start", value: function(t3, e3, n4) {
        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < ("gesture" === t3.name ? 2 : 1) || !e3.options[t3.name].enabled) && ((0, Xt.copyAction)(this.prepared, t3), this.interactable = e3, this.element = n4, this.rect = e3.getRect(n4), this.edges = this.prepared.edges ? (0, M.default)({}, this.prepared.edges) : { left: true, right: true, top: true, bottom: true }, this._stopped = false, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting);
      } }, { key: "pointerMove", value: function(t3, e3, n4) {
        this.simulation || this.modification && this.modification.endResult || this.updatePointer(t3, e3, n4, false);
        var r3, o3, i3 = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        this.pointerIsDown && !this.pointerWasMoved && (r3 = this.coords.cur.client.x - this.coords.start.client.x, o3 = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = (0, R2.default)(r3, o3) > this.pointerMoveTolerance);
        var a3 = this.getPointerIndex(t3), s3 = { pointer: t3, pointerIndex: a3, pointerInfo: this.pointers[a3], event: e3, type: "move", eventTarget: n4, dx: r3, dy: o3, duplicate: i3, interaction: this };
        i3 || X2.setCoordVelocity(this.coords.velocity, this.coords.delta), this._scopeFire("interactions:move", s3), i3 || this.simulation || (this.interacting() && (s3.type = null, this.move(s3)), this.pointerWasMoved && X2.copyCoords(this.coords.prev, this.coords.cur));
      } }, { key: "move", value: function(t3) {
        t3 && t3.event || X2.setZeroCoords(this.coords.delta), (t3 = (0, M.default)({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, t3 || {})).phase = "move", this._doPhase(t3);
      } }, { key: "pointerUp", value: function(t3, e3, n4, r3) {
        var o3 = this.getPointerIndex(t3);
        -1 === o3 && (o3 = this.updatePointer(t3, e3, n4, false));
        var i3 = /cancel$/i.test(e3.type) ? "cancel" : "up";
        this._scopeFire("interactions:".concat(i3), { pointer: t3, pointerIndex: o3, pointerInfo: this.pointers[o3], event: e3, eventTarget: n4, type: i3, curEventTarget: r3, interaction: this }), this.simulation || this.end(e3), this.removePointer(t3, e3);
      } }, { key: "documentBlur", value: function(t3) {
        this.end(t3), this._scopeFire("interactions:blur", { event: t3, type: "blur", interaction: this });
      } }, { key: "end", value: function(t3) {
        var e3;
        this._ending = true, t3 = t3 || this._latestPointer.event, this.interacting() && (e3 = this._doPhase({ event: t3, interaction: this, phase: "end" })), this._ending = false, true === e3 && this.stop();
      } }, { key: "currentAction", value: function() {
        return this._interacting ? this.prepared.name : null;
      } }, { key: "interacting", value: function() {
        return this._interacting;
      } }, { key: "stop", value: function() {
        this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = false, this._stopped = true, this.prepared.name = this.prevEvent = null;
      } }, { key: "getPointerIndex", value: function(t3) {
        var e3 = X2.getPointerId(t3);
        return "mouse" === this.pointerType || "pen" === this.pointerType ? this.pointers.length - 1 : H2.findIndex(this.pointers, function(t4) {
          return t4.id === e3;
        });
      } }, { key: "getPointerInfo", value: function(t3) {
        return this.pointers[this.getPointerIndex(t3)];
      } }, { key: "updatePointer", value: function(t3, e3, n4, r3) {
        var o3 = X2.getPointerId(t3), i3 = this.getPointerIndex(t3), a3 = this.pointers[i3];
        return r3 = false !== r3 && (r3 || /(down|start)$/i.test(e3.type)), a3 ? a3.pointer = t3 : (a3 = new Ye.PointerInfo(o3, t3, e3, null, null), i3 = this.pointers.length, this.pointers.push(a3)), X2.setCoords(this.coords.cur, this.pointers.map(function(t4) {
          return t4.pointer;
        }), this._now()), X2.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur), r3 && (this.pointerIsDown = true, a3.downTime = this.coords.cur.timeStamp, a3.downTarget = n4, X2.pointerExtend(this.downPointer, t3), this.interacting() || (X2.copyCoords(this.coords.start, this.coords.cur), X2.copyCoords(this.coords.prev, this.coords.cur), this.downEvent = e3, this.pointerWasMoved = false)), this._updateLatestPointer(t3, e3, n4), this._scopeFire("interactions:update-pointer", { pointer: t3, event: e3, eventTarget: n4, down: r3, pointerInfo: a3, pointerIndex: i3, interaction: this }), i3;
      } }, { key: "removePointer", value: function(t3, e3) {
        var n4 = this.getPointerIndex(t3);
        if (-1 !== n4) {
          var r3 = this.pointers[n4];
          this._scopeFire("interactions:remove-pointer", { pointer: t3, event: e3, eventTarget: null, pointerIndex: n4, pointerInfo: r3, interaction: this }), this.pointers.splice(n4, 1), this.pointerIsDown = false;
        }
      } }, { key: "_updateLatestPointer", value: function(t3, e3, n4) {
        this._latestPointer.pointer = t3, this._latestPointer.event = e3, this._latestPointer.eventTarget = n4;
      } }, { key: "destroy", value: function() {
        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;
      } }, { key: "_createPreparedEvent", value: function(t3, e3, n4, r3) {
        return new Ie.InteractEvent(this, t3, this.prepared.name, e3, this.element, n4, r3);
      } }, { key: "_fireEvent", value: function(t3) {
        var e3;
        null == (e3 = this.interactable) || e3.fire(t3), (!this.prevEvent || t3.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t3);
      } }, { key: "_doPhase", value: function(t3) {
        var e3 = t3.event, n4 = t3.phase, r3 = t3.preEnd, o3 = t3.type, i3 = this.rect;
        if (i3 && "move" === n4 && (k2.addEdges(this.edges, i3, this.coords.delta[this.interactable.options.deltaSource]), i3.width = i3.right - i3.left, i3.height = i3.bottom - i3.top), false === this._scopeFire("interactions:before-action-".concat(n4), t3))
          return false;
        var a3 = t3.iEvent = this._createPreparedEvent(e3, n4, r3, o3);
        return this._scopeFire("interactions:action-".concat(n4), t3), "start" === n4 && (this.prevEvent = a3), this._fireEvent(a3), this._scopeFire("interactions:after-action-".concat(n4), t3), true;
      } }, { key: "_now", value: function() {
        return Date.now();
      } }], n3 && $e2(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    Ge.Interaction = Ze2;
    var Je2 = Ze2;
    Ge.default = Je2;
    var Qe2 = {};
    function tn(t2) {
      t2.pointerIsDown && (on(t2.coords.cur, t2.offset.total), t2.offset.pending.x = 0, t2.offset.pending.y = 0);
    }
    function en(t2) {
      nn(t2.interaction);
    }
    function nn(t2) {
      if (!function(t3) {
        return !(!t3.offset.pending.x && !t3.offset.pending.y);
      }(t2))
        return false;
      var e2 = t2.offset.pending;
      return on(t2.coords.cur, e2), on(t2.coords.delta, e2), k2.addEdges(t2.edges, t2.rect, e2), e2.x = 0, e2.y = 0, true;
    }
    function rn(t2) {
      var e2 = t2.x, n3 = t2.y;
      this.offset.pending.x += e2, this.offset.pending.y += n3, this.offset.total.x += e2, this.offset.total.y += n3;
    }
    function on(t2, e2) {
      var n3 = t2.page, r3 = t2.client, o3 = e2.x, i3 = e2.y;
      n3.x += o3, n3.y += i3, r3.x += o3, r3.y += i3;
    }
    Object.defineProperty(Qe2, "__esModule", { value: true }), Qe2.addTotal = tn, Qe2.applyPending = nn, Qe2.default = void 0, Ge._ProxyMethods.offsetBy = "";
    var an = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function(t2) {
      t2.Interaction.prototype.offsetBy = rn;
    }, listeners: { "interactions:new": function(t2) {
      t2.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };
    }, "interactions:update-pointer": function(t2) {
      return tn(t2.interaction);
    }, "interactions:before-action-start": en, "interactions:before-action-move": en, "interactions:before-action-end": function(t2) {
      var e2 = t2.interaction;
      if (nn(e2))
        return e2.move({ offset: true }), e2.end(), false;
    }, "interactions:stop": function(t2) {
      var e2 = t2.interaction;
      e2.offset.total.x = 0, e2.offset.total.y = 0, e2.offset.pending.x = 0, e2.offset.pending.y = 0;
    } } }, sn = an;
    Qe2.default = sn;
    var ln = {};
    function un(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function cn(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(ln, "__esModule", { value: true }), ln.default = ln.InertiaState = void 0;
    var fn2 = function() {
      function t2(e3) {
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), cn(this, "active", false), cn(this, "isModified", false), cn(this, "smoothEnd", false), cn(this, "allowResume", false), cn(this, "modification", void 0), cn(this, "modifierCount", 0), cn(this, "modifierArg", void 0), cn(this, "startCoords", void 0), cn(this, "t0", 0), cn(this, "v0", 0), cn(this, "te", 0), cn(this, "targetOffset", void 0), cn(this, "modifiedOffset", void 0), cn(this, "currentOffset", void 0), cn(this, "lambda_v0", 0), cn(this, "one_ve_v0", 0), cn(this, "timeout", void 0), cn(this, "interaction", void 0), this.interaction = e3;
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "start", value: function(t3) {
        var e3 = this.interaction, n4 = dn(e3);
        if (!n4 || !n4.enabled)
          return false;
        var r3 = e3.coords.velocity.client, o3 = (0, R2.default)(r3.x, r3.y), i3 = this.modification || (this.modification = new me2.default(e3));
        if (i3.copyFrom(e3.modification), this.t0 = e3._now(), this.allowResume = n4.allowResume, this.v0 = o3, this.currentOffset = { x: 0, y: 0 }, this.startCoords = e3.coords.cur.page, this.modifierArg = i3.fillArg({ pageCoords: this.startCoords, preEnd: true, phase: "inertiastart" }), this.t0 - e3.coords.cur.timeStamp < 50 && o3 > n4.minSpeed && o3 > n4.endSpeed)
          this.startInertia();
        else {
          if (i3.result = i3.setAll(this.modifierArg), !i3.result.changed)
            return false;
          this.startSmoothEnd();
        }
        return e3.modification.result.rect = null, e3.offsetBy(this.targetOffset), e3._doPhase({ interaction: e3, event: t3, phase: "inertiastart" }), e3.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), e3.modification.result.rect = null, this.active = true, e3.simulation = this, true;
      } }, { key: "startInertia", value: function() {
        var t3 = this, e3 = this.interaction.coords.velocity.client, n4 = dn(this.interaction), r3 = n4.resistance, o3 = -Math.log(n4.endSpeed / this.v0) / r3;
        this.targetOffset = { x: (e3.x - o3) / r3, y: (e3.y - o3) / r3 }, this.te = o3, this.lambda_v0 = r3 / this.v0, this.one_ve_v0 = 1 - n4.endSpeed / this.v0;
        var i3 = this.modification, a3 = this.modifierArg;
        a3.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, i3.result = i3.setAll(a3), i3.result.changed && (this.isModified = true, this.modifiedOffset = { x: this.targetOffset.x + i3.result.delta.x, y: this.targetOffset.y + i3.result.delta.y }), this.onNextFrame(function() {
          return t3.inertiaTick();
        });
      } }, { key: "startSmoothEnd", value: function() {
        var t3 = this;
        this.smoothEnd = true, this.isModified = true, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {
          return t3.smoothEndTick();
        });
      } }, { key: "onNextFrame", value: function(t3) {
        var e3 = this;
        this.timeout = Tt2.default.request(function() {
          e3.active && t3();
        });
      } }, { key: "inertiaTick", value: function() {
        var t3, e3, n4, r3, o3, i3 = this, a3 = this.interaction, s3 = dn(a3).resistance, l3 = (a3._now() - this.t0) / 1e3;
        if (l3 < this.te) {
          var u3, c3 = 1 - (Math.exp(-s3 * l3) - this.lambda_v0) / this.one_ve_v0;
          this.isModified ? (t3 = this.targetOffset.x, e3 = this.targetOffset.y, n4 = this.modifiedOffset.x, r3 = this.modifiedOffset.y, u3 = { x: vn(o3 = c3, 0, t3, n4), y: vn(o3, 0, e3, r3) }) : u3 = { x: this.targetOffset.x * c3, y: this.targetOffset.y * c3 };
          var f3 = { x: u3.x - this.currentOffset.x, y: u3.y - this.currentOffset.y };
          this.currentOffset.x += f3.x, this.currentOffset.y += f3.y, a3.offsetBy(f3), a3.move(), this.onNextFrame(function() {
            return i3.inertiaTick();
          });
        } else
          a3.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "smoothEndTick", value: function() {
        var t3 = this, e3 = this.interaction, n4 = e3._now() - this.t0, r3 = dn(e3).smoothEndDuration;
        if (n4 < r3) {
          var o3 = { x: hn(n4, 0, this.targetOffset.x, r3), y: hn(n4, 0, this.targetOffset.y, r3) }, i3 = { x: o3.x - this.currentOffset.x, y: o3.y - this.currentOffset.y };
          this.currentOffset.x += i3.x, this.currentOffset.y += i3.y, e3.offsetBy(i3), e3.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {
            return t3.smoothEndTick();
          });
        } else
          e3.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "resume", value: function(t3) {
        var e3 = t3.pointer, n4 = t3.event, r3 = t3.eventTarget, o3 = this.interaction;
        o3.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), o3.updatePointer(e3, n4, r3, true), o3._doPhase({ interaction: o3, event: n4, phase: "resume" }), (0, X2.copyCoords)(o3.coords.prev, o3.coords.cur), this.stop();
      } }, { key: "end", value: function() {
        this.interaction.move(), this.interaction.end(), this.stop();
      } }, { key: "stop", value: function() {
        this.active = this.smoothEnd = false, this.interaction.simulation = null, Tt2.default.cancel(this.timeout);
      } }]) && un(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    function dn(t2) {
      var e2 = t2.interactable, n3 = t2.prepared;
      return e2 && e2.options && n3.name && e2.options[n3.name].inertia;
    }
    ln.InertiaState = fn2;
    var pn = { id: "inertia", before: ["modifiers", "actions"], install: function(t2) {
      var e2 = t2.defaults;
      t2.usePlugin(Qe2.default), t2.usePlugin(Se2.default), t2.actions.phases.inertiastart = true, t2.actions.phases.resume = true, e2.perAction.inertia = { enabled: false, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: true, smoothEndDuration: 300 };
    }, listeners: { "interactions:new": function(t2) {
      var e2 = t2.interaction;
      e2.inertia = new fn2(e2);
    }, "interactions:before-action-end": function(t2) {
      var e2 = t2.interaction, n3 = t2.event;
      return (!e2._interacting || e2.simulation || !e2.inertia.start(n3)) && null;
    }, "interactions:down": function(t2) {
      var e2 = t2.interaction, n3 = t2.eventTarget, r3 = e2.inertia;
      if (r3.active)
        for (var o3 = n3; i2.default.element(o3); ) {
          if (o3 === e2.element) {
            r3.resume(t2);
            break;
          }
          o3 = _2.parentNode(o3);
        }
    }, "interactions:stop": function(t2) {
      var e2 = t2.interaction.inertia;
      e2.active && e2.stop();
    }, "interactions:before-action-resume": function(t2) {
      var e2 = t2.interaction.modification;
      e2.stop(t2), e2.start(t2, t2.interaction.coords.cur.page), e2.applyToInteraction(t2);
    }, "interactions:before-action-inertiastart": function(t2) {
      return t2.interaction.modification.setAndApply(t2);
    }, "interactions:action-resume": Se2.addEventModifiers, "interactions:action-inertiastart": Se2.addEventModifiers, "interactions:after-action-inertiastart": function(t2) {
      return t2.interaction.modification.restoreInteractionCoords(t2);
    }, "interactions:after-action-resume": function(t2) {
      return t2.interaction.modification.restoreInteractionCoords(t2);
    } } };
    function vn(t2, e2, n3, r3) {
      var o3 = 1 - t2;
      return o3 * o3 * e2 + 2 * o3 * t2 * n3 + t2 * t2 * r3;
    }
    function hn(t2, e2, n3, r3) {
      return -n3 * (t2 /= r3) * (t2 - 2) + e2;
    }
    var gn = pn;
    ln.default = gn;
    var yn = {};
    function mn(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function bn(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    function xn(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        if (t2.immediatePropagationStopped)
          break;
        r3(t2);
      }
    }
    Object.defineProperty(yn, "__esModule", { value: true }), yn.Eventable = void 0;
    var wn = function() {
      function t2(e3) {
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), bn(this, "options", void 0), bn(this, "types", {}), bn(this, "propagationStopped", false), bn(this, "immediatePropagationStopped", false), bn(this, "global", void 0), this.options = (0, M.default)({}, e3 || {});
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "fire", value: function(t3) {
        var e3, n4 = this.global;
        (e3 = this.types[t3.type]) && xn(t3, e3), !t3.propagationStopped && n4 && (e3 = n4[t3.type]) && xn(t3, e3);
      } }, { key: "on", value: function(t3, e3) {
        var n4 = (0, z2.default)(t3, e3);
        for (t3 in n4)
          this.types[t3] = H2.merge(this.types[t3] || [], n4[t3]);
      } }, { key: "off", value: function(t3, e3) {
        var n4 = (0, z2.default)(t3, e3);
        for (t3 in n4) {
          var r3 = this.types[t3];
          if (r3 && r3.length)
            for (var o3 = 0; o3 < n4[t3].length; o3++) {
              var i3 = n4[t3][o3], a3 = r3.indexOf(i3);
              -1 !== a3 && r3.splice(a3, 1);
            }
        }
      } }, { key: "getRect", value: function(t3) {
        return null;
      } }]) && mn(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    yn.Eventable = wn;
    var _n = {};
    Object.defineProperty(_n, "__esModule", { value: true }), _n.default = function(t2, e2) {
      if (e2.phaselessTypes[t2])
        return true;
      for (var n3 in e2.map)
        if (0 === t2.indexOf(n3) && t2.substr(n3.length) in e2.phases)
          return true;
      return false;
    };
    var Pn = {};
    Object.defineProperty(Pn, "__esModule", { value: true }), Pn.createInteractStatic = function(t2) {
      var e2 = function e3(n3, r3) {
        var o3 = t2.interactables.get(n3, r3);
        return o3 || ((o3 = t2.interactables.new(n3, r3)).events.global = e3.globalEvents), o3;
      };
      return e2.getPointerAverage = X2.pointerAverage, e2.getTouchBBox = X2.touchBBox, e2.getTouchDistance = X2.touchDistance, e2.getTouchAngle = X2.touchAngle, e2.getElementRect = _2.getElementRect, e2.getElementClientRect = _2.getElementClientRect, e2.matchesSelector = _2.matchesSelector, e2.closest = _2.closest, e2.globalEvents = {}, e2.version = "1.10.18", e2.scope = t2, e2.use = function(t3, e3) {
        return this.scope.usePlugin(t3, e3), this;
      }, e2.isSet = function(t3, e3) {
        return !!this.scope.interactables.get(t3, e3 && e3.context);
      }, e2.on = (0, Xt.warnOnce)(function(t3, e3, n3) {
        if (i2.default.string(t3) && -1 !== t3.search(" ") && (t3 = t3.trim().split(/ +/)), i2.default.array(t3)) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var o3 = t3[r3];
            this.on(o3, e3, n3);
          }
          return this;
        }
        if (i2.default.object(t3)) {
          for (var a3 in t3)
            this.on(a3, t3[a3], e3);
          return this;
        }
        return (0, _n.default)(t3, this.scope.actions) ? this.globalEvents[t3] ? this.globalEvents[t3].push(e3) : this.globalEvents[t3] = [e3] : this.scope.events.add(this.scope.document, t3, e3, { options: n3 }), this;
      }, "The interact.on() method is being deprecated"), e2.off = (0, Xt.warnOnce)(function(t3, e3, n3) {
        if (i2.default.string(t3) && -1 !== t3.search(" ") && (t3 = t3.trim().split(/ +/)), i2.default.array(t3)) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var o3 = t3[r3];
            this.off(o3, e3, n3);
          }
          return this;
        }
        if (i2.default.object(t3)) {
          for (var a3 in t3)
            this.off(a3, t3[a3], e3);
          return this;
        }
        var s3;
        return (0, _n.default)(t3, this.scope.actions) ? t3 in this.globalEvents && -1 !== (s3 = this.globalEvents[t3].indexOf(e3)) && this.globalEvents[t3].splice(s3, 1) : this.scope.events.remove(this.scope.document, t3, e3, n3), this;
      }, "The interact.off() method is being deprecated"), e2.debug = function() {
        return this.scope;
      }, e2.supportsTouch = function() {
        return b2.default.supportsTouch;
      }, e2.supportsPointerEvent = function() {
        return b2.default.supportsPointerEvent;
      }, e2.stop = function() {
        for (var t3 = 0; t3 < this.scope.interactions.list.length; t3++)
          this.scope.interactions.list[t3].stop();
        return this;
      }, e2.pointerMoveTolerance = function(t3) {
        return i2.default.number(t3) ? (this.scope.interactions.pointerMoveTolerance = t3, this) : this.scope.interactions.pointerMoveTolerance;
      }, e2.addDocument = function(t3, e3) {
        this.scope.addDocument(t3, e3);
      }, e2.removeDocument = function(t3) {
        this.scope.removeDocument(t3);
      }, e2;
    };
    var On = {};
    function En(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function Sn(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(On, "__esModule", { value: true }), On.Interactable = void 0;
    var Tn = function() {
      function t2(n4, r4, o3, i3) {
        !function(t3, e2) {
          if (!(t3 instanceof e2))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), Sn(this, "options", void 0), Sn(this, "_actions", void 0), Sn(this, "target", void 0), Sn(this, "events", new yn.Eventable()), Sn(this, "_context", void 0), Sn(this, "_win", void 0), Sn(this, "_doc", void 0), Sn(this, "_scopeEvents", void 0), Sn(this, "_rectChecker", void 0), this._actions = r4.actions, this.target = n4, this._context = r4.context || o3, this._win = (0, e.getWindow)((0, _2.trySelector)(n4) ? this._context : n4), this._doc = this._win.document, this._scopeEvents = i3, this.set(r4);
      }
      var n3, r3;
      return n3 = t2, (r3 = [{ key: "_defaults", get: function() {
        return { base: {}, perAction: {}, actions: {} };
      } }, { key: "setOnEvents", value: function(t3, e2) {
        return i2.default.func(e2.onstart) && this.on("".concat(t3, "start"), e2.onstart), i2.default.func(e2.onmove) && this.on("".concat(t3, "move"), e2.onmove), i2.default.func(e2.onend) && this.on("".concat(t3, "end"), e2.onend), i2.default.func(e2.oninertiastart) && this.on("".concat(t3, "inertiastart"), e2.oninertiastart), this;
      } }, { key: "updatePerActionListeners", value: function(t3, e2, n4) {
        (i2.default.array(e2) || i2.default.object(e2)) && this.off(t3, e2), (i2.default.array(n4) || i2.default.object(n4)) && this.on(t3, n4);
      } }, { key: "setPerAction", value: function(t3, e2) {
        var n4 = this._defaults;
        for (var r4 in e2) {
          var o3 = r4, a3 = this.options[t3], s3 = e2[o3];
          "listeners" === o3 && this.updatePerActionListeners(t3, a3.listeners, s3), i2.default.array(s3) ? a3[o3] = H2.from(s3) : i2.default.plainObject(s3) ? (a3[o3] = (0, M.default)(a3[o3] || {}, (0, ye2.default)(s3)), i2.default.object(n4.perAction[o3]) && "enabled" in n4.perAction[o3] && (a3[o3].enabled = false !== s3.enabled)) : i2.default.bool(s3) && i2.default.object(n4.perAction[o3]) ? a3[o3].enabled = s3 : a3[o3] = s3;
        }
      } }, { key: "getRect", value: function(t3) {
        return t3 = t3 || (i2.default.element(this.target) ? this.target : null), i2.default.string(this.target) && (t3 = t3 || this._context.querySelector(this.target)), (0, _2.getElementRect)(t3);
      } }, { key: "rectChecker", value: function(t3) {
        var e2 = this;
        return i2.default.func(t3) ? (this._rectChecker = t3, this.getRect = function(t4) {
          var n4 = (0, M.default)({}, e2._rectChecker(t4));
          return "width" in n4 || (n4.width = n4.right - n4.left, n4.height = n4.bottom - n4.top), n4;
        }, this) : null === t3 ? (delete this.getRect, delete this._rectChecker, this) : this.getRect;
      } }, { key: "_backCompatOption", value: function(t3, e2) {
        if ((0, _2.trySelector)(e2) || i2.default.object(e2)) {
          for (var n4 in this.options[t3] = e2, this._actions.map)
            this.options[n4][t3] = e2;
          return this;
        }
        return this.options[t3];
      } }, { key: "origin", value: function(t3) {
        return this._backCompatOption("origin", t3);
      } }, { key: "deltaSource", value: function(t3) {
        return "page" === t3 || "client" === t3 ? (this.options.deltaSource = t3, this) : this.options.deltaSource;
      } }, { key: "context", value: function() {
        return this._context;
      } }, { key: "inContext", value: function(t3) {
        return this._context === t3.ownerDocument || (0, _2.nodeContains)(this._context, t3);
      } }, { key: "testIgnoreAllow", value: function(t3, e2, n4) {
        return !this.testIgnore(t3.ignoreFrom, e2, n4) && this.testAllow(t3.allowFrom, e2, n4);
      } }, { key: "testAllow", value: function(t3, e2, n4) {
        return !t3 || !!i2.default.element(n4) && (i2.default.string(t3) ? (0, _2.matchesUpTo)(n4, t3, e2) : !!i2.default.element(t3) && (0, _2.nodeContains)(t3, n4));
      } }, { key: "testIgnore", value: function(t3, e2, n4) {
        return !(!t3 || !i2.default.element(n4)) && (i2.default.string(t3) ? (0, _2.matchesUpTo)(n4, t3, e2) : !!i2.default.element(t3) && (0, _2.nodeContains)(t3, n4));
      } }, { key: "fire", value: function(t3) {
        return this.events.fire(t3), this;
      } }, { key: "_onOff", value: function(t3, e2, n4, r4) {
        i2.default.object(e2) && !i2.default.array(e2) && (r4 = n4, n4 = null);
        var o3 = "on" === t3 ? "add" : "remove", a3 = (0, z2.default)(e2, n4);
        for (var s3 in a3) {
          "wheel" === s3 && (s3 = b2.default.wheelEvent);
          for (var l3 = 0; l3 < a3[s3].length; l3++) {
            var u3 = a3[s3][l3];
            (0, _n.default)(s3, this._actions) ? this.events[t3](s3, u3) : i2.default.string(this.target) ? this._scopeEvents["".concat(o3, "Delegate")](this.target, this._context, s3, u3, r4) : this._scopeEvents[o3](this.target, s3, u3, r4);
          }
        }
        return this;
      } }, { key: "on", value: function(t3, e2, n4) {
        return this._onOff("on", t3, e2, n4);
      } }, { key: "off", value: function(t3, e2, n4) {
        return this._onOff("off", t3, e2, n4);
      } }, { key: "set", value: function(t3) {
        var e2 = this._defaults;
        for (var n4 in i2.default.object(t3) || (t3 = {}), this.options = (0, ye2.default)(e2.base), this._actions.methodDict) {
          var r4 = n4, o3 = this._actions.methodDict[r4];
          this.options[r4] = {}, this.setPerAction(r4, (0, M.default)((0, M.default)({}, e2.perAction), e2.actions[r4])), this[o3](t3[r4]);
        }
        for (var a3 in t3)
          i2.default.func(this[a3]) && this[a3](t3[a3]);
        return this;
      } }, { key: "unset", value: function() {
        if (i2.default.string(this.target))
          for (var t3 in this._scopeEvents.delegatedEvents)
            for (var e2 = this._scopeEvents.delegatedEvents[t3], n4 = e2.length - 1; n4 >= 0; n4--) {
              var r4 = e2[n4], o3 = r4.selector, a3 = r4.context, s3 = r4.listeners;
              o3 === this.target && a3 === this._context && e2.splice(n4, 1);
              for (var l3 = s3.length - 1; l3 >= 0; l3--)
                this._scopeEvents.removeDelegate(this.target, this._context, t3, s3[l3][0], s3[l3][1]);
            }
        else
          this._scopeEvents.remove(this.target, "all");
      } }]) && En(n3.prototype, r3), Object.defineProperty(n3, "prototype", { writable: false }), t2;
    }();
    On.Interactable = Tn;
    var jn = {};
    function Mn(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function kn(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(jn, "__esModule", { value: true }), jn.InteractableSet = void 0;
    var In = function() {
      function t2(e3) {
        var n4 = this;
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), kn(this, "list", []), kn(this, "selectorMap", {}), kn(this, "scope", void 0), this.scope = e3, e3.addListeners({ "interactable:unset": function(t3) {
          var e4 = t3.interactable, r3 = e4.target, o3 = e4._context, a3 = i2.default.string(r3) ? n4.selectorMap[r3] : r3[n4.scope.id], s3 = H2.findIndex(a3, function(t4) {
            return t4.context === o3;
          });
          a3[s3] && (a3[s3].context = null, a3[s3].interactable = null), a3.splice(s3, 1);
        } });
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "new", value: function(t3, e3) {
        e3 = (0, M.default)(e3 || {}, { actions: this.scope.actions });
        var n4 = new this.scope.Interactable(t3, e3, this.scope.document, this.scope.events), r3 = { context: n4._context, interactable: n4 };
        return this.scope.addDocument(n4._doc), this.list.push(n4), i2.default.string(t3) ? (this.selectorMap[t3] || (this.selectorMap[t3] = []), this.selectorMap[t3].push(r3)) : (n4.target[this.scope.id] || Object.defineProperty(t3, this.scope.id, { value: [], configurable: true }), t3[this.scope.id].push(r3)), this.scope.fire("interactable:new", { target: t3, options: e3, interactable: n4, win: this.scope._win }), n4;
      } }, { key: "get", value: function(t3, e3) {
        var n4 = e3 && e3.context || this.scope.document, r3 = i2.default.string(t3), o3 = r3 ? this.selectorMap[t3] : t3[this.scope.id];
        if (!o3)
          return null;
        var a3 = H2.find(o3, function(e4) {
          return e4.context === n4 && (r3 || e4.interactable.inContext(t3));
        });
        return a3 && a3.interactable;
      } }, { key: "forEachMatch", value: function(t3, e3) {
        for (var n4 = 0; n4 < this.list.length; n4++) {
          var r3 = this.list[n4], o3 = void 0;
          if ((i2.default.string(r3.target) ? i2.default.element(t3) && _2.matchesSelector(t3, r3.target) : t3 === r3.target) && r3.inContext(t3) && (o3 = e3(r3)), void 0 !== o3)
            return o3;
        }
      } }]) && Mn(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    jn.InteractableSet = In;
    var Dn = {};
    function An(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function zn(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    function Cn(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var n3 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null != n3) {
          var r3, o3, i3 = [], a3 = true, s3 = false;
          try {
            for (n3 = n3.call(t3); !(a3 = (r3 = n3.next()).done) && (i3.push(r3.value), !e3 || i3.length !== e3); a3 = true)
              ;
          } catch (t4) {
            s3 = true, o3 = t4;
          } finally {
            try {
              a3 || null == n3.return || n3.return();
            } finally {
              if (s3)
                throw o3;
            }
          }
          return i3;
        }
      }(t2, e2) || function(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return Rn(t3, e3);
          var n3 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? Rn(t3, e3) : void 0;
        }
      }(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function Rn(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    Object.defineProperty(Dn, "__esModule", { value: true }), Dn.default = void 0;
    var Fn = function() {
      function t2(e3) {
        !function(t3, e4) {
          if (!(t3 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t2), zn(this, "currentTarget", void 0), zn(this, "originalEvent", void 0), zn(this, "type", void 0), this.originalEvent = e3, (0, F2.default)(this, e3);
      }
      var e2, n3;
      return e2 = t2, (n3 = [{ key: "preventOriginalDefault", value: function() {
        this.originalEvent.preventDefault();
      } }, { key: "stopPropagation", value: function() {
        this.originalEvent.stopPropagation();
      } }, { key: "stopImmediatePropagation", value: function() {
        this.originalEvent.stopImmediatePropagation();
      } }]) && An(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), t2;
    }();
    function Xn(t2) {
      if (!i2.default.object(t2))
        return { capture: !!t2, passive: false };
      var e2 = (0, M.default)({}, t2);
      return e2.capture = !!t2.capture, e2.passive = !!t2.passive, e2;
    }
    var Bn = { id: "events", install: function(t2) {
      var e2, n3 = [], r3 = {}, o3 = [], a3 = { add: s3, remove: l3, addDelegate: function(t3, e3, n4, i3, a4) {
        var l4 = Xn(a4);
        if (!r3[n4]) {
          r3[n4] = [];
          for (var f3 = 0; f3 < o3.length; f3++) {
            var d3 = o3[f3];
            s3(d3, n4, u3), s3(d3, n4, c3, true);
          }
        }
        var p3 = r3[n4], v3 = H2.find(p3, function(n5) {
          return n5.selector === t3 && n5.context === e3;
        });
        v3 || (v3 = { selector: t3, context: e3, listeners: [] }, p3.push(v3)), v3.listeners.push([i3, l4]);
      }, removeDelegate: function(t3, e3, n4, o4, i3) {
        var a4, s4 = Xn(i3), f3 = r3[n4], d3 = false;
        if (f3)
          for (a4 = f3.length - 1; a4 >= 0; a4--) {
            var p3 = f3[a4];
            if (p3.selector === t3 && p3.context === e3) {
              for (var v3 = p3.listeners, h3 = v3.length - 1; h3 >= 0; h3--) {
                var g3 = Cn(v3[h3], 2), y3 = g3[0], m3 = g3[1], b3 = m3.capture, x3 = m3.passive;
                if (y3 === o4 && b3 === s4.capture && x3 === s4.passive) {
                  v3.splice(h3, 1), v3.length || (f3.splice(a4, 1), l3(e3, n4, u3), l3(e3, n4, c3, true)), d3 = true;
                  break;
                }
              }
              if (d3)
                break;
            }
          }
      }, delegateListener: u3, delegateUseCapture: c3, delegatedEvents: r3, documents: o3, targets: n3, supportsOptions: false, supportsPassive: false };
      function s3(t3, e3, r4, o4) {
        var i3 = Xn(o4), s4 = H2.find(n3, function(e4) {
          return e4.eventTarget === t3;
        });
        s4 || (s4 = { eventTarget: t3, events: {} }, n3.push(s4)), s4.events[e3] || (s4.events[e3] = []), t3.addEventListener && !H2.contains(s4.events[e3], r4) && (t3.addEventListener(e3, r4, a3.supportsOptions ? i3 : i3.capture), s4.events[e3].push(r4));
      }
      function l3(t3, e3, r4, o4) {
        var i3 = Xn(o4), s4 = H2.findIndex(n3, function(e4) {
          return e4.eventTarget === t3;
        }), u4 = n3[s4];
        if (u4 && u4.events)
          if ("all" !== e3) {
            var c4 = false, f3 = u4.events[e3];
            if (f3) {
              if ("all" === r4) {
                for (var d3 = f3.length - 1; d3 >= 0; d3--)
                  l3(t3, e3, f3[d3], i3);
                return;
              }
              for (var p3 = 0; p3 < f3.length; p3++)
                if (f3[p3] === r4) {
                  t3.removeEventListener(e3, r4, a3.supportsOptions ? i3 : i3.capture), f3.splice(p3, 1), 0 === f3.length && (delete u4.events[e3], c4 = true);
                  break;
                }
            }
            c4 && !Object.keys(u4.events).length && n3.splice(s4, 1);
          } else
            for (e3 in u4.events)
              u4.events.hasOwnProperty(e3) && l3(t3, e3, "all");
      }
      function u3(t3, e3) {
        for (var n4 = Xn(e3), o4 = new Fn(t3), a4 = r3[t3.type], s4 = Cn(X2.getEventTargets(t3), 1)[0], l4 = s4; i2.default.element(l4); ) {
          for (var u4 = 0; u4 < a4.length; u4++) {
            var c4 = a4[u4], f3 = c4.selector, d3 = c4.context;
            if (_2.matchesSelector(l4, f3) && _2.nodeContains(d3, s4) && _2.nodeContains(d3, l4)) {
              var p3 = c4.listeners;
              o4.currentTarget = l4;
              for (var v3 = 0; v3 < p3.length; v3++) {
                var h3 = Cn(p3[v3], 2), g3 = h3[0], y3 = h3[1], m3 = y3.capture, b3 = y3.passive;
                m3 === n4.capture && b3 === n4.passive && g3(o4);
              }
            }
          }
          l4 = _2.parentNode(l4);
        }
      }
      function c3(t3) {
        return u3(t3, true);
      }
      return null == (e2 = t2.document) || e2.createElement("div").addEventListener("test", null, { get capture() {
        return a3.supportsOptions = true;
      }, get passive() {
        return a3.supportsPassive = true;
      } }), t2.events = a3, a3;
    } };
    Dn.default = Bn;
    var Yn = {};
    Object.defineProperty(Yn, "__esModule", { value: true }), Yn.default = void 0;
    var Wn = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function(t2) {
      for (var e2 = 0; e2 < Wn.methodOrder.length; e2++) {
        var n3;
        n3 = Wn.methodOrder[e2];
        var r3 = Wn[n3](t2);
        if (r3)
          return r3;
      }
      return null;
    }, simulationResume: function(t2) {
      var e2 = t2.pointerType, n3 = t2.eventType, r3 = t2.eventTarget, o3 = t2.scope;
      if (!/down|start/i.test(n3))
        return null;
      for (var i3 = 0; i3 < o3.interactions.list.length; i3++) {
        var a3 = o3.interactions.list[i3], s3 = r3;
        if (a3.simulation && a3.simulation.allowResume && a3.pointerType === e2)
          for (; s3; ) {
            if (s3 === a3.element)
              return a3;
            s3 = _2.parentNode(s3);
          }
      }
      return null;
    }, mouseOrPen: function(t2) {
      var e2, n3 = t2.pointerId, r3 = t2.pointerType, o3 = t2.eventType, i3 = t2.scope;
      if ("mouse" !== r3 && "pen" !== r3)
        return null;
      for (var a3 = 0; a3 < i3.interactions.list.length; a3++) {
        var s3 = i3.interactions.list[a3];
        if (s3.pointerType === r3) {
          if (s3.simulation && !Ln(s3, n3))
            continue;
          if (s3.interacting())
            return s3;
          e2 || (e2 = s3);
        }
      }
      if (e2)
        return e2;
      for (var l3 = 0; l3 < i3.interactions.list.length; l3++) {
        var u3 = i3.interactions.list[l3];
        if (!(u3.pointerType !== r3 || /down/i.test(o3) && u3.simulation))
          return u3;
      }
      return null;
    }, hasPointer: function(t2) {
      for (var e2 = t2.pointerId, n3 = t2.scope, r3 = 0; r3 < n3.interactions.list.length; r3++) {
        var o3 = n3.interactions.list[r3];
        if (Ln(o3, e2))
          return o3;
      }
      return null;
    }, idle: function(t2) {
      for (var e2 = t2.pointerType, n3 = t2.scope, r3 = 0; r3 < n3.interactions.list.length; r3++) {
        var o3 = n3.interactions.list[r3];
        if (1 === o3.pointers.length) {
          var i3 = o3.interactable;
          if (i3 && (!i3.options.gesture || !i3.options.gesture.enabled))
            continue;
        } else if (o3.pointers.length >= 2)
          continue;
        if (!o3.interacting() && e2 === o3.pointerType)
          return o3;
      }
      return null;
    } };
    function Ln(t2, e2) {
      return t2.pointers.some(function(t3) {
        return t3.id === e2;
      });
    }
    var Un = Wn;
    Yn.default = Un;
    var Vn = {};
    function Nn(t2) {
      return Nn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, Nn(t2);
    }
    function qn(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var n3 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null != n3) {
          var r3, o3, i3 = [], a3 = true, s3 = false;
          try {
            for (n3 = n3.call(t3); !(a3 = (r3 = n3.next()).done) && (i3.push(r3.value), !e3 || i3.length !== e3); a3 = true)
              ;
          } catch (t4) {
            s3 = true, o3 = t4;
          } finally {
            try {
              a3 || null == n3.return || n3.return();
            } finally {
              if (s3)
                throw o3;
            }
          }
          return i3;
        }
      }(t2, e2) || function(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return Gn(t3, e3);
          var n3 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? Gn(t3, e3) : void 0;
        }
      }(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function Gn(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    function $n(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function Hn(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function Kn(t2, e2) {
      return Kn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, Kn(t2, e2);
    }
    function Zn(t2, e2) {
      if (e2 && ("object" === Nn(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return function(t3) {
        if (void 0 === t3)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t3;
      }(t2);
    }
    function Jn(t2) {
      return Jn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, Jn(t2);
    }
    Object.defineProperty(Vn, "__esModule", { value: true }), Vn.default = void 0;
    var Qn = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
    function tr(t2, e2) {
      return function(n3) {
        var r3 = e2.interactions.list, o3 = X2.getPointerType(n3), i3 = qn(X2.getEventTargets(n3), 2), a3 = i3[0], s3 = i3[1], l3 = [];
        if (/^touch/.test(n3.type)) {
          e2.prevTouchTime = e2.now();
          for (var u3 = 0; u3 < n3.changedTouches.length; u3++) {
            var c3 = n3.changedTouches[u3], f3 = { pointer: c3, pointerId: X2.getPointerId(c3), pointerType: o3, eventType: n3.type, eventTarget: a3, curEventTarget: s3, scope: e2 }, d3 = er(f3);
            l3.push([f3.pointer, f3.eventTarget, f3.curEventTarget, d3]);
          }
        } else {
          var p3 = false;
          if (!b2.default.supportsPointerEvent && /mouse/.test(n3.type)) {
            for (var v3 = 0; v3 < r3.length && !p3; v3++)
              p3 = "mouse" !== r3[v3].pointerType && r3[v3].pointerIsDown;
            p3 = p3 || e2.now() - e2.prevTouchTime < 500 || 0 === n3.timeStamp;
          }
          if (!p3) {
            var h3 = { pointer: n3, pointerId: X2.getPointerId(n3), pointerType: o3, eventType: n3.type, curEventTarget: s3, eventTarget: a3, scope: e2 }, g3 = er(h3);
            l3.push([h3.pointer, h3.eventTarget, h3.curEventTarget, g3]);
          }
        }
        for (var y3 = 0; y3 < l3.length; y3++) {
          var m3 = qn(l3[y3], 4), x3 = m3[0], w3 = m3[1], _3 = m3[2];
          m3[3][t2](x3, n3, w3, _3);
        }
      };
    }
    function er(t2) {
      var e2 = t2.pointerType, n3 = t2.scope, r3 = { interaction: Yn.default.search(t2), searchDetails: t2 };
      return n3.fire("interactions:find", r3), r3.interaction || n3.interactions.new({ pointerType: e2 });
    }
    function nr(t2, e2) {
      var n3 = t2.doc, r3 = t2.scope, o3 = t2.options, i3 = r3.interactions.docEvents, a3 = r3.events, s3 = a3[e2];
      for (var l3 in r3.browser.isIOS && !o3.events && (o3.events = { passive: false }), a3.delegatedEvents)
        s3(n3, l3, a3.delegateListener), s3(n3, l3, a3.delegateUseCapture, true);
      for (var u3 = o3 && o3.events, c3 = 0; c3 < i3.length; c3++) {
        var f3 = i3[c3];
        s3(n3, f3.type, f3.listener, u3);
      }
    }
    var rr = { id: "core/interactions", install: function(t2) {
      for (var e2 = {}, n3 = 0; n3 < Qn.length; n3++) {
        var r3 = Qn[n3];
        e2[r3] = tr(r3, t2);
      }
      var o3, i3 = b2.default.pEventTypes;
      function a3() {
        for (var e3 = 0; e3 < t2.interactions.list.length; e3++) {
          var n4 = t2.interactions.list[e3];
          if (n4.pointerIsDown && "touch" === n4.pointerType && !n4._interacting)
            for (var r4 = function() {
              var e4 = n4.pointers[o4];
              t2.documents.some(function(t3) {
                var n5 = t3.doc;
                return (0, _2.nodeContains)(n5, e4.downTarget);
              }) || n4.removePointer(e4.pointer, e4.event);
            }, o4 = 0; o4 < n4.pointers.length; o4++)
              r4();
        }
      }
      (o3 = h2.default.PointerEvent ? [{ type: i3.down, listener: a3 }, { type: i3.down, listener: e2.pointerDown }, { type: i3.move, listener: e2.pointerMove }, { type: i3.up, listener: e2.pointerUp }, { type: i3.cancel, listener: e2.pointerUp }] : [{ type: "mousedown", listener: e2.pointerDown }, { type: "mousemove", listener: e2.pointerMove }, { type: "mouseup", listener: e2.pointerUp }, { type: "touchstart", listener: a3 }, { type: "touchstart", listener: e2.pointerDown }, { type: "touchmove", listener: e2.pointerMove }, { type: "touchend", listener: e2.pointerUp }, { type: "touchcancel", listener: e2.pointerUp }]).push({ type: "blur", listener: function(e3) {
        for (var n4 = 0; n4 < t2.interactions.list.length; n4++)
          t2.interactions.list[n4].documentBlur(e3);
      } }), t2.prevTouchTime = 0, t2.Interaction = function(e3) {
        !function(t3, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t3.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t3, writable: true, configurable: true } }), Object.defineProperty(t3, "prototype", { writable: false }), e4 && Kn(t3, e4);
        }(s3, e3);
        var n4, r4, o4, i4, a4 = (o4 = s3, i4 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t3) {
            return false;
          }
        }(), function() {
          var t3, e4 = Jn(o4);
          if (i4) {
            var n5 = Jn(this).constructor;
            t3 = Reflect.construct(e4, arguments, n5);
          } else
            t3 = e4.apply(this, arguments);
          return Zn(this, t3);
        });
        function s3() {
          return $n(this, s3), a4.apply(this, arguments);
        }
        return n4 = s3, (r4 = [{ key: "pointerMoveTolerance", get: function() {
          return t2.interactions.pointerMoveTolerance;
        }, set: function(e4) {
          t2.interactions.pointerMoveTolerance = e4;
        } }, { key: "_now", value: function() {
          return t2.now();
        } }]) && Hn(n4.prototype, r4), Object.defineProperty(n4, "prototype", { writable: false }), s3;
      }(Ge.default), t2.interactions = { list: [], new: function(e3) {
        e3.scopeFire = function(e4, n5) {
          return t2.fire(e4, n5);
        };
        var n4 = new t2.Interaction(e3);
        return t2.interactions.list.push(n4), n4;
      }, listeners: e2, docEvents: o3, pointerMoveTolerance: 1 }, t2.usePlugin(le2.default);
    }, listeners: { "scope:add-document": function(t2) {
      return nr(t2, "add");
    }, "scope:remove-document": function(t2) {
      return nr(t2, "remove");
    }, "interactable:unset": function(t2, e2) {
      for (var n3 = t2.interactable, r3 = e2.interactions.list.length - 1; r3 >= 0; r3--) {
        var o3 = e2.interactions.list[r3];
        o3.interactable === n3 && (o3.stop(), e2.fire("interactions:destroy", { interaction: o3 }), o3.destroy(), e2.interactions.list.length > 2 && e2.interactions.list.splice(r3, 1));
      }
    } }, onDocSignal: nr, doOnInteractions: tr, methodNames: Qn }, or = rr;
    Vn.default = or;
    var ir = {};
    function ar(t2) {
      return ar = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, ar(t2);
    }
    function sr() {
      return sr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t2, e2, n3) {
        var r3 = lr(t2, e2);
        if (r3) {
          var o3 = Object.getOwnPropertyDescriptor(r3, e2);
          return o3.get ? o3.get.call(arguments.length < 3 ? t2 : n3) : o3.value;
        }
      }, sr.apply(this, arguments);
    }
    function lr(t2, e2) {
      for (; !Object.prototype.hasOwnProperty.call(t2, e2) && null !== (t2 = fr(t2)); )
        ;
      return t2;
    }
    function ur(t2, e2) {
      return ur = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, ur(t2, e2);
    }
    function cr(t2, e2) {
      if (e2 && ("object" === ar(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return function(t3) {
        if (void 0 === t3)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t3;
      }(t2);
    }
    function fr(t2) {
      return fr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, fr(t2);
    }
    function dr(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function pr(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function vr(t2, e2, n3) {
      return e2 && pr(t2.prototype, e2), n3 && pr(t2, n3), Object.defineProperty(t2, "prototype", { writable: false }), t2;
    }
    function hr(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(ir, "__esModule", { value: true }), ir.Scope = void 0, ir.initScope = yr;
    var gr = function() {
      function t2() {
        var e2 = this;
        dr(this, t2), hr(this, "id", "__interact_scope_".concat(Math.floor(100 * Math.random()))), hr(this, "isInitialized", false), hr(this, "listenerMaps", []), hr(this, "browser", b2.default), hr(this, "defaults", (0, ye2.default)(ke.defaults)), hr(this, "Eventable", yn.Eventable), hr(this, "actions", { map: {}, phases: { start: true, move: true, end: true }, methodDict: {}, phaselessTypes: {} }), hr(this, "interactStatic", (0, Pn.createInteractStatic)(this)), hr(this, "InteractEvent", Ie.InteractEvent), hr(this, "Interactable", void 0), hr(this, "interactables", new jn.InteractableSet(this)), hr(this, "_win", void 0), hr(this, "document", void 0), hr(this, "window", void 0), hr(this, "documents", []), hr(this, "_plugins", { list: [], map: {} }), hr(this, "onWindowUnload", function(t3) {
          return e2.removeDocument(t3.target);
        });
        var n3 = this;
        this.Interactable = function(t3) {
          !function(t4, e4) {
            if ("function" != typeof e4 && null !== e4)
              throw new TypeError("Super expression must either be null or a function");
            t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, writable: true, configurable: true } }), Object.defineProperty(t4, "prototype", { writable: false }), e4 && ur(t4, e4);
          }(i3, t3);
          var e3, r3, o3 = (e3 = i3, r3 = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if ("function" == typeof Proxy)
              return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (t4) {
              return false;
            }
          }(), function() {
            var t4, n4 = fr(e3);
            if (r3) {
              var o4 = fr(this).constructor;
              t4 = Reflect.construct(n4, arguments, o4);
            } else
              t4 = n4.apply(this, arguments);
            return cr(this, t4);
          });
          function i3() {
            return dr(this, i3), o3.apply(this, arguments);
          }
          return vr(i3, [{ key: "_defaults", get: function() {
            return n3.defaults;
          } }, { key: "set", value: function(t4) {
            return sr(fr(i3.prototype), "set", this).call(this, t4), n3.fire("interactable:set", { options: t4, interactable: this }), this;
          } }, { key: "unset", value: function() {
            sr(fr(i3.prototype), "unset", this).call(this);
            var t4 = n3.interactables.list.indexOf(this);
            t4 < 0 || (sr(fr(i3.prototype), "unset", this).call(this), n3.interactables.list.splice(t4, 1), n3.fire("interactable:unset", { interactable: this }));
          } }]), i3;
        }(On.Interactable);
      }
      return vr(t2, [{ key: "addListeners", value: function(t3, e2) {
        this.listenerMaps.push({ id: e2, map: t3 });
      } }, { key: "fire", value: function(t3, e2) {
        for (var n3 = 0; n3 < this.listenerMaps.length; n3++) {
          var r3 = this.listenerMaps[n3].map[t3];
          if (r3 && false === r3(e2, this, t3))
            return false;
        }
      } }, { key: "init", value: function(t3) {
        return this.isInitialized ? this : yr(this, t3);
      } }, { key: "pluginIsInstalled", value: function(t3) {
        return this._plugins.map[t3.id] || -1 !== this._plugins.list.indexOf(t3);
      } }, { key: "usePlugin", value: function(t3, e2) {
        if (!this.isInitialized)
          return this;
        if (this.pluginIsInstalled(t3))
          return this;
        if (t3.id && (this._plugins.map[t3.id] = t3), this._plugins.list.push(t3), t3.install && t3.install(this, e2), t3.listeners && t3.before) {
          for (var n3 = 0, r3 = this.listenerMaps.length, o3 = t3.before.reduce(function(t4, e3) {
            return t4[e3] = true, t4[mr(e3)] = true, t4;
          }, {}); n3 < r3; n3++) {
            var i3 = this.listenerMaps[n3].id;
            if (o3[i3] || o3[mr(i3)])
              break;
          }
          this.listenerMaps.splice(n3, 0, { id: t3.id, map: t3.listeners });
        } else
          t3.listeners && this.listenerMaps.push({ id: t3.id, map: t3.listeners });
        return this;
      } }, { key: "addDocument", value: function(t3, n3) {
        if (-1 !== this.getDocIndex(t3))
          return false;
        var r3 = e.getWindow(t3);
        n3 = n3 ? (0, M.default)({}, n3) : {}, this.documents.push({ doc: t3, options: n3 }), this.events.documents.push(t3), t3 !== this.document && this.events.add(r3, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: t3, window: r3, scope: this, options: n3 });
      } }, { key: "removeDocument", value: function(t3) {
        var n3 = this.getDocIndex(t3), r3 = e.getWindow(t3), o3 = this.documents[n3].options;
        this.events.remove(r3, "unload", this.onWindowUnload), this.documents.splice(n3, 1), this.events.documents.splice(n3, 1), this.fire("scope:remove-document", { doc: t3, window: r3, scope: this, options: o3 });
      } }, { key: "getDocIndex", value: function(t3) {
        for (var e2 = 0; e2 < this.documents.length; e2++)
          if (this.documents[e2].doc === t3)
            return e2;
        return -1;
      } }, { key: "getDocOptions", value: function(t3) {
        var e2 = this.getDocIndex(t3);
        return -1 === e2 ? null : this.documents[e2].options;
      } }, { key: "now", value: function() {
        return (this.window.Date || Date).now();
      } }]), t2;
    }();
    function yr(t2, n3) {
      return t2.isInitialized = true, i2.default.window(n3) && e.init(n3), h2.default.init(n3), b2.default.init(n3), Tt2.default.init(n3), t2.window = n3, t2.document = n3.document, t2.usePlugin(Vn.default), t2.usePlugin(Dn.default), t2;
    }
    function mr(t2) {
      return t2 && t2.replace(/\/.*$/, "");
    }
    ir.Scope = gr;
    var br = {};
    Object.defineProperty(br, "__esModule", { value: true }), br.default = void 0;
    var xr = new ir.Scope(), wr = xr.interactStatic;
    br.default = wr;
    var _r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0;
    xr.init(_r);
    var Pr = {};
    Object.defineProperty(Pr, "__esModule", { value: true }), Pr.default = void 0, Pr.default = function() {
    };
    var Or = {};
    Object.defineProperty(Or, "__esModule", { value: true }), Or.default = void 0, Or.default = function() {
    };
    var Er = {};
    function Sr(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var n3 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null != n3) {
          var r3, o3, i3 = [], a3 = true, s3 = false;
          try {
            for (n3 = n3.call(t3); !(a3 = (r3 = n3.next()).done) && (i3.push(r3.value), !e3 || i3.length !== e3); a3 = true)
              ;
          } catch (t4) {
            s3 = true, o3 = t4;
          } finally {
            try {
              a3 || null == n3.return || n3.return();
            } finally {
              if (s3)
                throw o3;
            }
          }
          return i3;
        }
      }(t2, e2) || function(t3, e3) {
        if (t3) {
          if ("string" == typeof t3)
            return Tr(t3, e3);
          var n3 = Object.prototype.toString.call(t3).slice(8, -1);
          return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? Tr(t3, e3) : void 0;
        }
      }(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function Tr(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    Object.defineProperty(Er, "__esModule", { value: true }), Er.default = void 0, Er.default = function(t2) {
      var e2 = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(function(e3) {
        var n4 = Sr(e3, 2), r3 = n4[0], o3 = n4[1];
        return r3 in t2 || o3 in t2;
      }), n3 = function(n4, r3) {
        for (var o3 = t2.range, i3 = t2.limits, a3 = void 0 === i3 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : i3, s3 = t2.offset, l3 = void 0 === s3 ? { x: 0, y: 0 } : s3, u3 = { range: o3, grid: t2, x: null, y: null }, c3 = 0; c3 < e2.length; c3++) {
          var f3 = Sr(e2[c3], 2), d3 = f3[0], p3 = f3[1], v3 = Math.round((n4 - l3.x) / t2[d3]), h3 = Math.round((r3 - l3.y) / t2[p3]);
          u3[d3] = Math.max(a3.left, Math.min(a3.right, v3 * t2[d3] + l3.x)), u3[p3] = Math.max(a3.top, Math.min(a3.bottom, h3 * t2[p3] + l3.y));
        }
        return u3;
      };
      return n3.grid = t2, n3.coordFields = e2, n3;
    };
    var jr = {};
    Object.defineProperty(jr, "__esModule", { value: true }), Object.defineProperty(jr, "edgeTarget", { enumerable: true, get: function() {
      return Pr.default;
    } }), Object.defineProperty(jr, "elements", { enumerable: true, get: function() {
      return Or.default;
    } }), Object.defineProperty(jr, "grid", { enumerable: true, get: function() {
      return Er.default;
    } });
    var Mr = {};
    Object.defineProperty(Mr, "__esModule", { value: true }), Mr.default = void 0;
    var kr = { id: "snappers", install: function(t2) {
      var e2 = t2.interactStatic;
      e2.snappers = (0, M.default)(e2.snappers || {}, jr), e2.createSnapGrid = e2.snappers.grid;
    } }, Ir = kr;
    Mr.default = Ir;
    var Dr = {};
    function Ar(t2, e2) {
      var n3 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var r3 = Object.getOwnPropertySymbols(t2);
        e2 && (r3 = r3.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), n3.push.apply(n3, r3);
      }
      return n3;
    }
    function zr(t2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var n3 = null != arguments[e2] ? arguments[e2] : {};
        e2 % 2 ? Ar(Object(n3), true).forEach(function(e3) {
          Cr(t2, e3, n3[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n3)) : Ar(Object(n3)).forEach(function(e3) {
          Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(n3, e3));
        });
      }
      return t2;
    }
    function Cr(t2, e2, n3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: n3, enumerable: true, configurable: true, writable: true }) : t2[e2] = n3, t2;
    }
    Object.defineProperty(Dr, "__esModule", { value: true }), Dr.default = Dr.aspectRatio = void 0;
    var Rr = { start: function(t2) {
      var e2 = t2.state, n3 = t2.rect, r3 = t2.edges, o3 = t2.pageCoords, i3 = e2.options, a3 = i3.ratio, s3 = i3.enabled, l3 = e2.options, u3 = l3.equalDelta, c3 = l3.modifiers;
      "preserve" === a3 && (a3 = n3.width / n3.height), e2.startCoords = (0, M.default)({}, o3), e2.startRect = (0, M.default)({}, n3), e2.ratio = a3, e2.equalDelta = u3;
      var f3 = e2.linkedEdges = { top: r3.top || r3.left && !r3.bottom, left: r3.left || r3.top && !r3.right, bottom: r3.bottom || r3.right && !r3.top, right: r3.right || r3.bottom && !r3.left };
      if (e2.xIsPrimaryAxis = !(!r3.left && !r3.right), e2.equalDelta) {
        var d3 = (f3.left ? 1 : -1) * (f3.top ? 1 : -1);
        e2.edgeSign = { x: d3, y: d3 };
      } else
        e2.edgeSign = { x: f3.left ? -1 : 1, y: f3.top ? -1 : 1 };
      if (false !== s3 && (0, M.default)(r3, f3), null != c3 && c3.length) {
        var p3 = new me2.default(t2.interaction);
        p3.copyFrom(t2.interaction.modification), p3.prepareStates(c3), e2.subModification = p3, p3.startAll(zr({}, t2));
      }
    }, set: function(t2) {
      var e2 = t2.state, n3 = t2.rect, r3 = t2.coords, o3 = e2.linkedEdges, i3 = (0, M.default)({}, r3), a3 = e2.equalDelta ? Fr : Xr;
      if ((0, M.default)(t2.edges, o3), a3(e2, e2.xIsPrimaryAxis, r3, n3), !e2.subModification)
        return null;
      var s3 = (0, M.default)({}, n3);
      (0, k2.addEdges)(o3, s3, { x: r3.x - i3.x, y: r3.y - i3.y });
      var l3 = e2.subModification.setAll(zr(zr({}, t2), {}, { rect: s3, edges: o3, pageCoords: r3, prevCoords: r3, prevRect: s3 })), u3 = l3.delta;
      return l3.changed && (a3(e2, Math.abs(u3.x) > Math.abs(u3.y), l3.coords, l3.rect), (0, M.default)(r3, l3.coords)), l3.eventProps;
    }, defaults: { ratio: "preserve", equalDelta: false, modifiers: [], enabled: false } };
    function Fr(t2, e2, n3) {
      var r3 = t2.startCoords, o3 = t2.edgeSign;
      e2 ? n3.y = r3.y + (n3.x - r3.x) * o3.y : n3.x = r3.x + (n3.y - r3.y) * o3.x;
    }
    function Xr(t2, e2, n3, r3) {
      var o3 = t2.startRect, i3 = t2.startCoords, a3 = t2.ratio, s3 = t2.edgeSign;
      if (e2) {
        var l3 = r3.width / a3;
        n3.y = i3.y + (l3 - o3.height) * s3.y;
      } else {
        var u3 = r3.height * a3;
        n3.x = i3.x + (u3 - o3.width) * s3.x;
      }
    }
    Dr.aspectRatio = Rr;
    var Br = (0, Se2.makeModifier)(Rr, "aspectRatio");
    Dr.default = Br;
    var Yr = {};
    Object.defineProperty(Yr, "__esModule", { value: true }), Yr.default = void 0;
    var Wr = function() {
    };
    Wr._defaults = {};
    var Lr = Wr;
    Yr.default = Lr;
    var Ur = {};
    Object.defineProperty(Ur, "__esModule", { value: true }), Object.defineProperty(Ur, "default", { enumerable: true, get: function() {
      return Yr.default;
    } });
    var Vr = {};
    function Nr(t2, e2, n3) {
      return i2.default.func(t2) ? k2.resolveRectLike(t2, e2.interactable, e2.element, [n3.x, n3.y, e2]) : k2.resolveRectLike(t2, e2.interactable, e2.element);
    }
    Object.defineProperty(Vr, "__esModule", { value: true }), Vr.default = void 0, Vr.getRestrictionRect = Nr, Vr.restrict = void 0;
    var qr = { start: function(t2) {
      var e2 = t2.rect, n3 = t2.startOffset, r3 = t2.state, o3 = t2.interaction, i3 = t2.pageCoords, a3 = r3.options, s3 = a3.elementRect, l3 = (0, M.default)({ left: 0, top: 0, right: 0, bottom: 0 }, a3.offset || {});
      if (e2 && s3) {
        var u3 = Nr(a3.restriction, o3, i3);
        if (u3) {
          var c3 = u3.right - u3.left - e2.width, f3 = u3.bottom - u3.top - e2.height;
          c3 < 0 && (l3.left += c3, l3.right += c3), f3 < 0 && (l3.top += f3, l3.bottom += f3);
        }
        l3.left += n3.left - e2.width * s3.left, l3.top += n3.top - e2.height * s3.top, l3.right += n3.right - e2.width * (1 - s3.right), l3.bottom += n3.bottom - e2.height * (1 - s3.bottom);
      }
      r3.offset = l3;
    }, set: function(t2) {
      var e2 = t2.coords, n3 = t2.interaction, r3 = t2.state, o3 = r3.options, i3 = r3.offset, a3 = Nr(o3.restriction, n3, e2);
      if (a3) {
        var s3 = k2.xywhToTlbr(a3);
        e2.x = Math.max(Math.min(s3.right - i3.right, e2.x), s3.left + i3.left), e2.y = Math.max(Math.min(s3.bottom - i3.bottom, e2.y), s3.top + i3.top);
      }
    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: false, enabled: false } };
    Vr.restrict = qr;
    var Gr = (0, Se2.makeModifier)(qr, "restrict");
    Vr.default = Gr;
    var $r = {};
    Object.defineProperty($r, "__esModule", { value: true }), $r.restrictEdges = $r.default = void 0;
    var Hr = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, Kr = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };
    function Zr(t2, e2) {
      for (var n3 = ["top", "left", "bottom", "right"], r3 = 0; r3 < n3.length; r3++) {
        var o3 = n3[r3];
        o3 in t2 || (t2[o3] = e2[o3]);
      }
      return t2;
    }
    var Jr = { noInner: Hr, noOuter: Kr, start: function(t2) {
      var e2, n3 = t2.interaction, r3 = t2.startOffset, o3 = t2.state, i3 = o3.options;
      if (i3) {
        var a3 = (0, Vr.getRestrictionRect)(i3.offset, n3, n3.coords.start.page);
        e2 = k2.rectToXY(a3);
      }
      e2 = e2 || { x: 0, y: 0 }, o3.offset = { top: e2.y + r3.top, left: e2.x + r3.left, bottom: e2.y - r3.bottom, right: e2.x - r3.right };
    }, set: function(t2) {
      var e2 = t2.coords, n3 = t2.edges, r3 = t2.interaction, o3 = t2.state, i3 = o3.offset, a3 = o3.options;
      if (n3) {
        var s3 = (0, M.default)({}, e2), l3 = (0, Vr.getRestrictionRect)(a3.inner, r3, s3) || {}, u3 = (0, Vr.getRestrictionRect)(a3.outer, r3, s3) || {};
        Zr(l3, Hr), Zr(u3, Kr), n3.top ? e2.y = Math.min(Math.max(u3.top + i3.top, s3.y), l3.top + i3.top) : n3.bottom && (e2.y = Math.max(Math.min(u3.bottom + i3.bottom, s3.y), l3.bottom + i3.bottom)), n3.left ? e2.x = Math.min(Math.max(u3.left + i3.left, s3.x), l3.left + i3.left) : n3.right && (e2.x = Math.max(Math.min(u3.right + i3.right, s3.x), l3.right + i3.right));
      }
    }, defaults: { inner: null, outer: null, offset: null, endOnly: false, enabled: false } };
    $r.restrictEdges = Jr;
    var Qr = (0, Se2.makeModifier)(Jr, "restrictEdges");
    $r.default = Qr;
    var to = {};
    Object.defineProperty(to, "__esModule", { value: true }), to.restrictRect = to.default = void 0;
    var eo = (0, M.default)({ get elementRect() {
      return { top: 0, left: 0, bottom: 1, right: 1 };
    }, set elementRect(t2) {
    } }, Vr.restrict.defaults), no = { start: Vr.restrict.start, set: Vr.restrict.set, defaults: eo };
    to.restrictRect = no;
    var ro = (0, Se2.makeModifier)(no, "restrictRect");
    to.default = ro;
    var oo = {};
    Object.defineProperty(oo, "__esModule", { value: true }), oo.restrictSize = oo.default = void 0;
    var io = { width: -1 / 0, height: -1 / 0 }, ao = { width: 1 / 0, height: 1 / 0 }, so = { start: function(t2) {
      return $r.restrictEdges.start(t2);
    }, set: function(t2) {
      var e2 = t2.interaction, n3 = t2.state, r3 = t2.rect, o3 = t2.edges, i3 = n3.options;
      if (o3) {
        var a3 = k2.tlbrToXywh((0, Vr.getRestrictionRect)(i3.min, e2, t2.coords)) || io, s3 = k2.tlbrToXywh((0, Vr.getRestrictionRect)(i3.max, e2, t2.coords)) || ao;
        n3.options = { endOnly: i3.endOnly, inner: (0, M.default)({}, $r.restrictEdges.noInner), outer: (0, M.default)({}, $r.restrictEdges.noOuter) }, o3.top ? (n3.options.inner.top = r3.bottom - a3.height, n3.options.outer.top = r3.bottom - s3.height) : o3.bottom && (n3.options.inner.bottom = r3.top + a3.height, n3.options.outer.bottom = r3.top + s3.height), o3.left ? (n3.options.inner.left = r3.right - a3.width, n3.options.outer.left = r3.right - s3.width) : o3.right && (n3.options.inner.right = r3.left + a3.width, n3.options.outer.right = r3.left + s3.width), $r.restrictEdges.set(t2), n3.options = i3;
      }
    }, defaults: { min: null, max: null, endOnly: false, enabled: false } };
    oo.restrictSize = so;
    var lo = (0, Se2.makeModifier)(so, "restrictSize");
    oo.default = lo;
    var uo = {};
    Object.defineProperty(uo, "__esModule", { value: true }), Object.defineProperty(uo, "default", { enumerable: true, get: function() {
      return Yr.default;
    } });
    var co = {};
    Object.defineProperty(co, "__esModule", { value: true }), co.snap = co.default = void 0;
    var fo = { start: function(t2) {
      var e2, n3 = t2.interaction, r3 = t2.interactable, o3 = t2.element, i3 = t2.rect, a3 = t2.state, s3 = t2.startOffset, l3 = a3.options, u3 = l3.offsetWithOrigin ? function(t3) {
        var e3 = t3.interaction.element;
        return (0, k2.rectToXY)((0, k2.resolveRectLike)(t3.state.options.origin, null, null, [e3])) || (0, A2.default)(t3.interactable, e3, t3.interaction.prepared.name);
      }(t2) : { x: 0, y: 0 };
      if ("startCoords" === l3.offset)
        e2 = { x: n3.coords.start.page.x, y: n3.coords.start.page.y };
      else {
        var c3 = (0, k2.resolveRectLike)(l3.offset, r3, o3, [n3]);
        (e2 = (0, k2.rectToXY)(c3) || { x: 0, y: 0 }).x += u3.x, e2.y += u3.y;
      }
      var f3 = l3.relativePoints;
      a3.offsets = i3 && f3 && f3.length ? f3.map(function(t3, n4) {
        return { index: n4, relativePoint: t3, x: s3.left - i3.width * t3.x + e2.x, y: s3.top - i3.height * t3.y + e2.y };
      }) : [{ index: 0, relativePoint: null, x: e2.x, y: e2.y }];
    }, set: function(t2) {
      var e2 = t2.interaction, n3 = t2.coords, r3 = t2.state, o3 = r3.options, a3 = r3.offsets, s3 = (0, A2.default)(e2.interactable, e2.element, e2.prepared.name), l3 = (0, M.default)({}, n3), u3 = [];
      o3.offsetWithOrigin || (l3.x -= s3.x, l3.y -= s3.y);
      for (var c3 = 0; c3 < a3.length; c3++)
        for (var f3 = a3[c3], d3 = l3.x - f3.x, p3 = l3.y - f3.y, v3 = 0, h3 = o3.targets.length; v3 < h3; v3++) {
          var g3, y3 = o3.targets[v3];
          (g3 = i2.default.func(y3) ? y3(d3, p3, e2._proxy, f3, v3) : y3) && u3.push({ x: (i2.default.number(g3.x) ? g3.x : d3) + f3.x, y: (i2.default.number(g3.y) ? g3.y : p3) + f3.y, range: i2.default.number(g3.range) ? g3.range : o3.range, source: y3, index: v3, offset: f3 });
        }
      for (var m3 = { target: null, inRange: false, distance: 0, range: 0, delta: { x: 0, y: 0 } }, b3 = 0; b3 < u3.length; b3++) {
        var x3 = u3[b3], w3 = x3.range, _3 = x3.x - l3.x, P3 = x3.y - l3.y, O3 = (0, R2.default)(_3, P3), E3 = O3 <= w3;
        w3 === 1 / 0 && m3.inRange && m3.range !== 1 / 0 && (E3 = false), m3.target && !(E3 ? m3.inRange && w3 !== 1 / 0 ? O3 / w3 < m3.distance / m3.range : w3 === 1 / 0 && m3.range !== 1 / 0 || O3 < m3.distance : !m3.inRange && O3 < m3.distance) || (m3.target = x3, m3.distance = O3, m3.range = w3, m3.inRange = E3, m3.delta.x = _3, m3.delta.y = P3);
      }
      return m3.inRange && (n3.x = m3.target.x, n3.y = m3.target.y), r3.closest = m3, m3;
    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: true, origin: null, relativePoints: null, endOnly: false, enabled: false } };
    co.snap = fo;
    var po = (0, Se2.makeModifier)(fo, "snap");
    co.default = po;
    var vo = {};
    function ho(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var n3 = 0, r3 = Array(e2); n3 < e2; n3++)
        r3[n3] = t2[n3];
      return r3;
    }
    Object.defineProperty(vo, "__esModule", { value: true }), vo.snapSize = vo.default = void 0;
    var go = { start: function(t2) {
      var e2 = t2.state, n3 = t2.edges, r3 = e2.options;
      if (!n3)
        return null;
      t2.state = { options: { targets: null, relativePoints: [{ x: n3.left ? 0 : 1, y: n3.top ? 0 : 1 }], offset: r3.offset || "self", origin: { x: 0, y: 0 }, range: r3.range } }, e2.targetFields = e2.targetFields || [["width", "height"], ["x", "y"]], co.snap.start(t2), e2.offsets = t2.state.offsets, t2.state = e2;
    }, set: function(t2) {
      var e2, n3, r3 = t2.interaction, o3 = t2.state, a3 = t2.coords, s3 = o3.options, l3 = o3.offsets, u3 = { x: a3.x - l3[0].x, y: a3.y - l3[0].y };
      o3.options = (0, M.default)({}, s3), o3.options.targets = [];
      for (var c3 = 0; c3 < (s3.targets || []).length; c3++) {
        var f3 = (s3.targets || [])[c3], d3 = void 0;
        if (d3 = i2.default.func(f3) ? f3(u3.x, u3.y, r3) : f3) {
          for (var p3 = 0; p3 < o3.targetFields.length; p3++) {
            var v3 = (e2 = o3.targetFields[p3], n3 = 2, function(t3) {
              if (Array.isArray(t3))
                return t3;
            }(e2) || function(t3, e3) {
              var n4 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
              if (null != n4) {
                var r4, o4, i3 = [], a4 = true, s4 = false;
                try {
                  for (n4 = n4.call(t3); !(a4 = (r4 = n4.next()).done) && (i3.push(r4.value), !e3 || i3.length !== e3); a4 = true)
                    ;
                } catch (t4) {
                  s4 = true, o4 = t4;
                } finally {
                  try {
                    a4 || null == n4.return || n4.return();
                  } finally {
                    if (s4)
                      throw o4;
                  }
                }
                return i3;
              }
            }(e2, n3) || function(t3, e3) {
              if (t3) {
                if ("string" == typeof t3)
                  return ho(t3, e3);
                var n4 = Object.prototype.toString.call(t3).slice(8, -1);
                return "Object" === n4 && t3.constructor && (n4 = t3.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(t3) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? ho(t3, e3) : void 0;
              }
            }(e2, n3) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()), h3 = v3[0], g3 = v3[1];
            if (h3 in d3 || g3 in d3) {
              d3.x = d3[h3], d3.y = d3[g3];
              break;
            }
          }
          o3.options.targets.push(d3);
        }
      }
      var y3 = co.snap.set(t2);
      return o3.options = s3, y3;
    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: false, enabled: false } };
    vo.snapSize = go;
    var yo = (0, Se2.makeModifier)(go, "snapSize");
    vo.default = yo;
    var mo = {};
    Object.defineProperty(mo, "__esModule", { value: true }), mo.snapEdges = mo.default = void 0;
    var bo = { start: function(t2) {
      var e2 = t2.edges;
      return e2 ? (t2.state.targetFields = t2.state.targetFields || [[e2.left ? "left" : "right", e2.top ? "top" : "bottom"]], vo.snapSize.start(t2)) : null;
    }, set: vo.snapSize.set, defaults: (0, M.default)((0, ye2.default)(vo.snapSize.defaults), { targets: null, range: null, offset: { x: 0, y: 0 } }) };
    mo.snapEdges = bo;
    var xo = (0, Se2.makeModifier)(bo, "snapEdges");
    mo.default = xo;
    var wo = {};
    Object.defineProperty(wo, "__esModule", { value: true }), Object.defineProperty(wo, "default", { enumerable: true, get: function() {
      return Yr.default;
    } });
    var _o = {};
    Object.defineProperty(_o, "__esModule", { value: true }), Object.defineProperty(_o, "default", { enumerable: true, get: function() {
      return Yr.default;
    } });
    var Po = {};
    Object.defineProperty(Po, "__esModule", { value: true }), Po.default = void 0;
    var Oo = { aspectRatio: Dr.default, restrictEdges: $r.default, restrict: Vr.default, restrictRect: to.default, restrictSize: oo.default, snapEdges: mo.default, snap: co.default, snapSize: vo.default, spring: wo.default, avoid: Ur.default, transform: _o.default, rubberband: uo.default };
    Po.default = Oo;
    var Eo = {};
    Object.defineProperty(Eo, "__esModule", { value: true }), Eo.default = void 0;
    var So = { id: "modifiers", install: function(t2) {
      var e2 = t2.interactStatic;
      for (var n3 in t2.usePlugin(Se2.default), t2.usePlugin(Mr.default), e2.modifiers = Po.default, Po.default) {
        var r3 = Po.default[n3], o3 = r3._defaults, i3 = r3._methods;
        o3._methods = i3, t2.defaults.perAction[n3] = o3;
      }
    } }, To = So;
    Eo.default = To;
    var jo = {};
    function Mo(t2) {
      return Mo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, Mo(t2);
    }
    function ko(t2, e2) {
      for (var n3 = 0; n3 < e2.length; n3++) {
        var r3 = e2[n3];
        r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t2, r3.key, r3);
      }
    }
    function Io(t2, e2) {
      return Io = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, Io(t2, e2);
    }
    function Do(t2, e2) {
      if (e2 && ("object" === Mo(e2) || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return Ao(t2);
    }
    function Ao(t2) {
      if (void 0 === t2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }
    function zo(t2) {
      return zo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, zo(t2);
    }
    Object.defineProperty(jo, "__esModule", { value: true }), jo.default = jo.PointerEvent = void 0;
    var Co = function(t2) {
      !function(t3, e3) {
        if ("function" != typeof e3 && null !== e3)
          throw new TypeError("Super expression must either be null or a function");
        t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), Object.defineProperty(t3, "prototype", { writable: false }), e3 && Io(t3, e3);
      }(a3, t2);
      var e2, n3, r3, o3, i3 = (r3 = a3, o3 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }(), function() {
        var t3, e3 = zo(r3);
        if (o3) {
          var n4 = zo(this).constructor;
          t3 = Reflect.construct(e3, arguments, n4);
        } else
          t3 = e3.apply(this, arguments);
        return Do(this, t3);
      });
      function a3(t3, e3, n4, r4, o4, s3) {
        var l3;
        if (function(t4, e4) {
          if (!(t4 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, a3), l3 = i3.call(this, o4), X2.pointerExtend(Ao(l3), n4), n4 !== e3 && X2.pointerExtend(Ao(l3), e3), l3.timeStamp = s3, l3.originalEvent = n4, l3.type = t3, l3.pointerId = X2.getPointerId(e3), l3.pointerType = X2.getPointerType(e3), l3.target = r4, l3.currentTarget = null, "tap" === t3) {
          var u3 = o4.getPointerIndex(e3);
          l3.dt = l3.timeStamp - o4.pointers[u3].downTime;
          var c3 = l3.timeStamp - o4.tapTime;
          l3.double = !!o4.prevTap && "doubletap" !== o4.prevTap.type && o4.prevTap.target === l3.target && c3 < 500;
        } else
          "doubletap" === t3 && (l3.dt = e3.timeStamp - o4.tapTime, l3.double = true);
        return l3;
      }
      return e2 = a3, (n3 = [{ key: "_subtractOrigin", value: function(t3) {
        var e3 = t3.x, n4 = t3.y;
        return this.pageX -= e3, this.pageY -= n4, this.clientX -= e3, this.clientY -= n4, this;
      } }, { key: "_addOrigin", value: function(t3) {
        var e3 = t3.x, n4 = t3.y;
        return this.pageX += e3, this.pageY += n4, this.clientX += e3, this.clientY += n4, this;
      } }, { key: "preventDefault", value: function() {
        this.originalEvent.preventDefault();
      } }]) && ko(e2.prototype, n3), Object.defineProperty(e2, "prototype", { writable: false }), a3;
    }(N.BaseEvent);
    jo.PointerEvent = jo.default = Co;
    var Ro = {};
    Object.defineProperty(Ro, "__esModule", { value: true }), Ro.default = void 0;
    var Fo = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function(t2) {
      t2.pointerEvents = Fo, t2.defaults.actions.pointerEvents = Fo.defaults, (0, M.default)(t2.actions.phaselessTypes, Fo.types);
    }, listeners: { "interactions:new": function(t2) {
      var e2 = t2.interaction;
      e2.prevTap = null, e2.tapTime = 0;
    }, "interactions:update-pointer": function(t2) {
      var e2 = t2.down, n3 = t2.pointerInfo;
      !e2 && n3.hold || (n3.hold = { duration: 1 / 0, timeout: null });
    }, "interactions:move": function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.pointer, o3 = t2.event, i3 = t2.eventTarget;
      t2.duplicate || n3.pointerIsDown && !n3.pointerWasMoved || (n3.pointerIsDown && Yo(t2), Xo({ interaction: n3, pointer: r3, event: o3, eventTarget: i3, type: "move" }, e2));
    }, "interactions:down": function(t2, e2) {
      !function(t3, e3) {
        for (var n3 = t3.interaction, r3 = t3.pointer, o3 = t3.event, i3 = t3.eventTarget, a3 = t3.pointerIndex, s3 = n3.pointers[a3].hold, l3 = _2.getPath(i3), u3 = { interaction: n3, pointer: r3, event: o3, eventTarget: i3, type: "hold", targets: [], path: l3, node: null }, c3 = 0; c3 < l3.length; c3++) {
          var f3 = l3[c3];
          u3.node = f3, e3.fire("pointerEvents:collect-targets", u3);
        }
        if (u3.targets.length) {
          for (var d3 = 1 / 0, p3 = 0; p3 < u3.targets.length; p3++) {
            var v3 = u3.targets[p3].eventable.options.holdDuration;
            v3 < d3 && (d3 = v3);
          }
          s3.duration = d3, s3.timeout = setTimeout(function() {
            Xo({ interaction: n3, eventTarget: i3, pointer: r3, event: o3, type: "hold" }, e3);
          }, d3);
        }
      }(t2, e2), Xo(t2, e2);
    }, "interactions:up": function(t2, e2) {
      Yo(t2), Xo(t2, e2), function(t3, e3) {
        var n3 = t3.interaction, r3 = t3.pointer, o3 = t3.event, i3 = t3.eventTarget;
        n3.pointerWasMoved || Xo({ interaction: n3, eventTarget: i3, pointer: r3, event: o3, type: "tap" }, e3);
      }(t2, e2);
    }, "interactions:cancel": function(t2, e2) {
      Yo(t2), Xo(t2, e2);
    } }, PointerEvent: jo.PointerEvent, fire: Xo, collectEventTargets: Bo, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: true, move: true, up: true, cancel: true, tap: true, doubletap: true, hold: true } };
    function Xo(t2, e2) {
      var n3 = t2.interaction, r3 = t2.pointer, o3 = t2.event, i3 = t2.eventTarget, a3 = t2.type, s3 = t2.targets, l3 = void 0 === s3 ? Bo(t2, e2) : s3, u3 = new jo.PointerEvent(a3, r3, o3, i3, n3, e2.now());
      e2.fire("pointerEvents:new", { pointerEvent: u3 });
      for (var c3 = { interaction: n3, pointer: r3, event: o3, eventTarget: i3, targets: l3, type: a3, pointerEvent: u3 }, f3 = 0; f3 < l3.length; f3++) {
        var d3 = l3[f3];
        for (var p3 in d3.props || {})
          u3[p3] = d3.props[p3];
        var v3 = (0, A2.default)(d3.eventable, d3.node);
        if (u3._subtractOrigin(v3), u3.eventable = d3.eventable, u3.currentTarget = d3.node, d3.eventable.fire(u3), u3._addOrigin(v3), u3.immediatePropagationStopped || u3.propagationStopped && f3 + 1 < l3.length && l3[f3 + 1].node !== u3.currentTarget)
          break;
      }
      if (e2.fire("pointerEvents:fired", c3), "tap" === a3) {
        var h3 = u3.double ? Xo({ interaction: n3, pointer: r3, event: o3, eventTarget: i3, type: "doubletap" }, e2) : u3;
        n3.prevTap = h3, n3.tapTime = h3.timeStamp;
      }
      return u3;
    }
    function Bo(t2, e2) {
      var n3 = t2.interaction, r3 = t2.pointer, o3 = t2.event, i3 = t2.eventTarget, a3 = t2.type, s3 = n3.getPointerIndex(r3), l3 = n3.pointers[s3];
      if ("tap" === a3 && (n3.pointerWasMoved || !l3 || l3.downTarget !== i3))
        return [];
      for (var u3 = _2.getPath(i3), c3 = { interaction: n3, pointer: r3, event: o3, eventTarget: i3, type: a3, path: u3, targets: [], node: null }, f3 = 0; f3 < u3.length; f3++) {
        var d3 = u3[f3];
        c3.node = d3, e2.fire("pointerEvents:collect-targets", c3);
      }
      return "hold" === a3 && (c3.targets = c3.targets.filter(function(t3) {
        var e3;
        return t3.eventable.options.holdDuration === (null == (e3 = n3.pointers[s3]) ? void 0 : e3.hold.duration);
      })), c3.targets;
    }
    function Yo(t2) {
      var e2 = t2.interaction, n3 = t2.pointerIndex, r3 = e2.pointers[n3].hold;
      r3 && r3.timeout && (clearTimeout(r3.timeout), r3.timeout = null);
    }
    var Wo = Fo;
    Ro.default = Wo;
    var Lo = {};
    function Uo(t2) {
      var e2 = t2.interaction;
      e2.holdIntervalHandle && (clearInterval(e2.holdIntervalHandle), e2.holdIntervalHandle = null);
    }
    Object.defineProperty(Lo, "__esModule", { value: true }), Lo.default = void 0;
    var Vo = { id: "pointer-events/holdRepeat", install: function(t2) {
      t2.usePlugin(Ro.default);
      var e2 = t2.pointerEvents;
      e2.defaults.holdRepeatInterval = 0, e2.types.holdrepeat = t2.actions.phaselessTypes.holdrepeat = true;
    }, listeners: ["move", "up", "cancel", "endall"].reduce(function(t2, e2) {
      return t2["pointerEvents:".concat(e2)] = Uo, t2;
    }, { "pointerEvents:new": function(t2) {
      var e2 = t2.pointerEvent;
      "hold" === e2.type && (e2.count = (e2.count || 0) + 1);
    }, "pointerEvents:fired": function(t2, e2) {
      var n3 = t2.interaction, r3 = t2.pointerEvent, o3 = t2.eventTarget, i3 = t2.targets;
      if ("hold" === r3.type && i3.length) {
        var a3 = i3[0].eventable.options.holdRepeatInterval;
        a3 <= 0 || (n3.holdIntervalHandle = setTimeout(function() {
          e2.pointerEvents.fire({ interaction: n3, eventTarget: o3, type: "hold", pointer: r3, event: r3 }, e2);
        }, a3));
      }
    } }) }, No = Vo;
    Lo.default = No;
    var qo = {};
    function Go(t2) {
      return (0, M.default)(this.events.options, t2), this;
    }
    Object.defineProperty(qo, "__esModule", { value: true }), qo.default = void 0;
    var $o = { id: "pointer-events/interactableTargets", install: function(t2) {
      var e2 = t2.Interactable;
      e2.prototype.pointerEvents = Go;
      var n3 = e2.prototype._backCompatOption;
      e2.prototype._backCompatOption = function(t3, e3) {
        var r3 = n3.call(this, t3, e3);
        return r3 === this && (this.events.options[t3] = e3), r3;
      };
    }, listeners: { "pointerEvents:collect-targets": function(t2, e2) {
      var n3 = t2.targets, r3 = t2.node, o3 = t2.type, i3 = t2.eventTarget;
      e2.interactables.forEachMatch(r3, function(t3) {
        var e3 = t3.events, a3 = e3.options;
        e3.types[o3] && e3.types[o3].length && t3.testIgnoreAllow(a3, r3, i3) && n3.push({ node: r3, eventable: e3, props: { interactable: t3 } });
      });
    }, "interactable:new": function(t2) {
      var e2 = t2.interactable;
      e2.events.getRect = function(t3) {
        return e2.getRect(t3);
      };
    }, "interactable:set": function(t2, e2) {
      var n3 = t2.interactable, r3 = t2.options;
      (0, M.default)(n3.events.options, e2.pointerEvents.defaults), (0, M.default)(n3.events.options, r3.pointerEvents || {});
    } } }, Ho = $o;
    qo.default = Ho;
    var Ko = {};
    Object.defineProperty(Ko, "__esModule", { value: true }), Ko.default = void 0;
    var Zo = { id: "pointer-events", install: function(t2) {
      t2.usePlugin(Ro), t2.usePlugin(Lo.default), t2.usePlugin(qo.default);
    } }, Jo = Zo;
    Ko.default = Jo;
    var Qo = {};
    function ti(t2) {
      var e2 = t2.Interactable;
      t2.actions.phases.reflow = true, e2.prototype.reflow = function(e3) {
        return function(t3, e4, n3) {
          for (var r3 = i2.default.string(t3.target) ? H2.from(t3._context.querySelectorAll(t3.target)) : [t3.target], o3 = n3.window.Promise, a3 = o3 ? [] : null, s3 = function() {
            var i3 = r3[l3], s4 = t3.getRect(i3);
            if (!s4)
              return "break";
            var u3 = H2.find(n3.interactions.list, function(n4) {
              return n4.interacting() && n4.interactable === t3 && n4.element === i3 && n4.prepared.name === e4.name;
            }), c3 = void 0;
            if (u3)
              u3.move(), a3 && (c3 = u3._reflowPromise || new o3(function(t4) {
                u3._reflowResolve = t4;
              }));
            else {
              var f3 = (0, k2.tlbrToXywh)(s4), d3 = { page: { x: f3.x, y: f3.y }, client: { x: f3.x, y: f3.y }, timeStamp: n3.now() }, p3 = X2.coordsToEvent(d3);
              c3 = function(t4, e5, n4, r4, o4) {
                var i4 = t4.interactions.new({ pointerType: "reflow" }), a4 = { interaction: i4, event: o4, pointer: o4, eventTarget: n4, phase: "reflow" };
                i4.interactable = e5, i4.element = n4, i4.prevEvent = o4, i4.updatePointer(o4, o4, n4, true), X2.setZeroCoords(i4.coords.delta), (0, Xt.copyAction)(i4.prepared, r4), i4._doPhase(a4);
                var s5 = t4.window.Promise, l4 = s5 ? new s5(function(t5) {
                  i4._reflowResolve = t5;
                }) : void 0;
                return i4._reflowPromise = l4, i4.start(r4, e5, n4), i4._interacting ? (i4.move(a4), i4.end(o4)) : (i4.stop(), i4._reflowResolve()), i4.removePointer(o4, o4), l4;
              }(n3, t3, i3, e4, p3);
            }
            a3 && a3.push(c3);
          }, l3 = 0; l3 < r3.length && "break" !== s3(); l3++)
            ;
          return a3 && o3.all(a3).then(function() {
            return t3;
          });
        }(this, e3, t2);
      };
    }
    Object.defineProperty(Qo, "__esModule", { value: true }), Qo.default = void 0, Qo.install = ti;
    var ei = { id: "reflow", install: ti, listeners: { "interactions:stop": function(t2, e2) {
      var n3 = t2.interaction;
      "reflow" === n3.pointerType && (n3._reflowResolve && n3._reflowResolve(), H2.remove(e2.interactions.list, n3));
    } } }, ni = ei;
    Qo.default = ni;
    var ri = {};
    Object.defineProperty(ri, "__esModule", { value: true }), ri.default = void 0, br.default.use(le2.default), br.default.use(Qe2.default), br.default.use(Ko.default), br.default.use(ln.default), br.default.use(Eo.default), br.default.use(ae2.default), br.default.use(Et2.default), br.default.use(Dt.default), br.default.use(Qo.default);
    var oi = br.default;
    ri.default = oi, br.default.default = br.default, Et2.default, Dt.default, ae2.default, le2.default, he2.default, ln.default, br.default, Eo.default, Qe2.default, Ko.default, Qo.default;
    var ii = { exports: {} };
    function ai(t2) {
      return ai = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, ai(t2);
    }
    Object.defineProperty(ii.exports, "__esModule", { value: true }), ii.exports.default = void 0;
    var si = ri.default;
    if (ii.exports.default = si, "object" === ai(ii) && ii)
      try {
        ii.exports = ri.default;
      } catch (t2) {
      }
    return ri.default.default = ri.default, ii.exports;
  });
})(interact_min);
var interact_minExports = interact_min.exports;
const interact = /* @__PURE__ */ getDefaultExportFromCjs(interact_minExports);
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements$1 = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min$1 = Math.min;
const max$1 = Math.max;
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end2) {
  return max$1(start2, min$1(value, end2));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement$1(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect$1(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition = async (reference2, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference: reference2,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect$1(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect$1(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform,
      elements
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
    const min$1$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1$1, center, max2);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? min$1$1 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 + alignmentOffset
      }
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements$1,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1$1 = alignment !== void 0 || allowedPlacements === placements$1 ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v2) => v2 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min$1(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min$1(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max$1(overflow.left, 0);
        const xMax = max$1(overflow.right, 0);
        const yMin = max$1(overflow.top, 0);
        const yMax = max$1(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function n$1(t) {
  var e;
  return (null == (e = t.ownerDocument) ? void 0 : e.defaultView) || window;
}
function o(t) {
  return n$1(t).getComputedStyle(t);
}
const i = Math.min, r = Math.max, l = Math.round;
function c(t) {
  const e = o(t);
  let n2 = parseFloat(e.width), i2 = parseFloat(e.height);
  const r2 = t.offsetWidth, c2 = t.offsetHeight, s2 = l(n2) !== r2 || l(i2) !== c2;
  return s2 && (n2 = r2, i2 = c2), { width: n2, height: i2, fallback: s2 };
}
function s(t) {
  return h(t) ? (t.nodeName || "").toLowerCase() : "";
}
let f$1;
function u$1() {
  if (f$1)
    return f$1;
  const t = navigator.userAgentData;
  return t && Array.isArray(t.brands) ? (f$1 = t.brands.map((t2) => t2.brand + "/" + t2.version).join(" "), f$1) : navigator.userAgent;
}
function a(t) {
  return t instanceof n$1(t).HTMLElement;
}
function d$1(t) {
  return t instanceof n$1(t).Element;
}
function h(t) {
  return t instanceof n$1(t).Node;
}
function p(t) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t instanceof n$1(t).ShadowRoot || t instanceof ShadowRoot;
}
function g$1(t) {
  const { overflow: e, overflowX: n2, overflowY: i2, display: r2 } = o(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + i2 + n2) && !["inline", "contents"].includes(r2);
}
function m$1(t) {
  return ["table", "td", "th"].includes(s(t));
}
function y$1(t) {
  const e = /firefox/i.test(u$1()), n2 = o(t), i2 = n2.backdropFilter || n2.WebkitBackdropFilter;
  return "none" !== n2.transform || "none" !== n2.perspective || !!i2 && "none" !== i2 || e && "filter" === n2.willChange || e && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((t2) => n2.willChange.includes(t2)) || ["paint", "layout", "strict", "content"].some((t2) => {
    const e2 = n2.contain;
    return null != e2 && e2.includes(t2);
  });
}
function x() {
  return !/^((?!chrome|android).)*safari/i.test(u$1());
}
function w(t) {
  return ["html", "body", "#document"].includes(s(t));
}
function v$1(t) {
  return d$1(t) ? t : t.contextElement;
}
const b$1 = { x: 1, y: 1 };
function L$1(t) {
  const e = v$1(t);
  if (!a(e))
    return b$1;
  const n2 = e.getBoundingClientRect(), { width: o2, height: i2, fallback: r2 } = c(e);
  let s2 = (r2 ? l(n2.width) : n2.width) / o2, f2 = (r2 ? l(n2.height) : n2.height) / i2;
  return s2 && Number.isFinite(s2) || (s2 = 1), f2 && Number.isFinite(f2) || (f2 = 1), { x: s2, y: f2 };
}
function E$1(t, e, o2, i2) {
  var r2, l2;
  void 0 === e && (e = false), void 0 === o2 && (o2 = false);
  const c2 = t.getBoundingClientRect(), s2 = v$1(t);
  let f2 = b$1;
  e && (i2 ? d$1(i2) && (f2 = L$1(i2)) : f2 = L$1(t));
  const u2 = s2 ? n$1(s2) : window, a2 = !x() && o2;
  let h2 = (c2.left + (a2 && (null == (r2 = u2.visualViewport) ? void 0 : r2.offsetLeft) || 0)) / f2.x, p2 = (c2.top + (a2 && (null == (l2 = u2.visualViewport) ? void 0 : l2.offsetTop) || 0)) / f2.y, g2 = c2.width / f2.x, m2 = c2.height / f2.y;
  if (s2) {
    const t2 = n$1(s2), e2 = i2 && d$1(i2) ? n$1(i2) : i2;
    let o3 = t2.frameElement;
    for (; o3 && i2 && e2 !== t2; ) {
      const t3 = L$1(o3), e3 = o3.getBoundingClientRect(), i3 = getComputedStyle(o3);
      e3.x += (o3.clientLeft + parseFloat(i3.paddingLeft)) * t3.x, e3.y += (o3.clientTop + parseFloat(i3.paddingTop)) * t3.y, h2 *= t3.x, p2 *= t3.y, g2 *= t3.x, m2 *= t3.y, h2 += e3.x, p2 += e3.y, o3 = n$1(o3).frameElement;
    }
  }
  return { width: g2, height: m2, top: p2, right: h2 + g2, bottom: p2 + m2, left: h2, x: h2, y: p2 };
}
function R(t) {
  return ((h(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function T(t) {
  return d$1(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function C$1(t) {
  return E$1(R(t)).left + T(t).scrollLeft;
}
function F(t) {
  if ("html" === s(t))
    return t;
  const e = t.assignedSlot || t.parentNode || p(t) && t.host || R(t);
  return p(e) ? e.host : e;
}
function W$1(t) {
  const e = F(t);
  return w(e) ? e.ownerDocument.body : a(e) && g$1(e) ? e : W$1(e);
}
function D(t, e) {
  var o2;
  void 0 === e && (e = []);
  const i2 = W$1(t), r2 = i2 === (null == (o2 = t.ownerDocument) ? void 0 : o2.body), l2 = n$1(i2);
  return r2 ? e.concat(l2, l2.visualViewport || [], g$1(i2) ? i2 : []) : e.concat(i2, D(i2));
}
function S$1(e, i2, l2) {
  return "viewport" === i2 ? rectToClientRect$1(function(t, e2) {
    const o2 = n$1(t), i3 = R(t), r2 = o2.visualViewport;
    let l3 = i3.clientWidth, c2 = i3.clientHeight, s2 = 0, f2 = 0;
    if (r2) {
      l3 = r2.width, c2 = r2.height;
      const t2 = x();
      (t2 || !t2 && "fixed" === e2) && (s2 = r2.offsetLeft, f2 = r2.offsetTop);
    }
    return { width: l3, height: c2, x: s2, y: f2 };
  }(e, l2)) : d$1(i2) ? rectToClientRect$1(function(t, e2) {
    const n2 = E$1(t, true, "fixed" === e2), o2 = n2.top + t.clientTop, i3 = n2.left + t.clientLeft, r2 = a(t) ? L$1(t) : { x: 1, y: 1 };
    return { width: t.clientWidth * r2.x, height: t.clientHeight * r2.y, x: i3 * r2.x, y: o2 * r2.y };
  }(i2, l2)) : rectToClientRect$1(function(t) {
    const e2 = R(t), n2 = T(t), i3 = t.ownerDocument.body, l3 = r(e2.scrollWidth, e2.clientWidth, i3.scrollWidth, i3.clientWidth), c2 = r(e2.scrollHeight, e2.clientHeight, i3.scrollHeight, i3.clientHeight);
    let s2 = -n2.scrollLeft + C$1(t);
    const f2 = -n2.scrollTop;
    return "rtl" === o(i3).direction && (s2 += r(e2.clientWidth, i3.clientWidth) - l3), { width: l3, height: c2, x: s2, y: f2 };
  }(R(e)));
}
function A(t) {
  return a(t) && "fixed" !== o(t).position ? t.offsetParent : null;
}
function H(t) {
  const e = n$1(t);
  let i2 = A(t);
  for (; i2 && m$1(i2) && "static" === o(i2).position; )
    i2 = A(i2);
  return i2 && ("html" === s(i2) || "body" === s(i2) && "static" === o(i2).position && !y$1(i2)) ? e : i2 || function(t2) {
    let e2 = F(t2);
    for (; a(e2) && !w(e2); ) {
      if (y$1(e2))
        return e2;
      e2 = F(e2);
    }
    return null;
  }(t) || e;
}
function O(t, e, n2) {
  const o2 = a(e), i2 = R(e), r2 = E$1(t, true, "fixed" === n2, e);
  let l2 = { scrollLeft: 0, scrollTop: 0 };
  const c2 = { x: 0, y: 0 };
  if (o2 || !o2 && "fixed" !== n2)
    if (("body" !== s(e) || g$1(i2)) && (l2 = T(e)), a(e)) {
      const t2 = E$1(e, true);
      c2.x = t2.x + e.clientLeft, c2.y = t2.y + e.clientTop;
    } else
      i2 && (c2.x = C$1(i2));
  return { x: r2.left + l2.scrollLeft - c2.x, y: r2.top + l2.scrollTop - c2.y, width: r2.width, height: r2.height };
}
const P = { getClippingRect: function(t) {
  let { element: e, boundary: n2, rootBoundary: l2, strategy: c2 } = t;
  const f2 = "clippingAncestors" === n2 ? function(t2, e2) {
    const n3 = e2.get(t2);
    if (n3)
      return n3;
    let i2 = D(t2).filter((t3) => d$1(t3) && "body" !== s(t3)), r2 = null;
    const l3 = "fixed" === o(t2).position;
    let c3 = l3 ? F(t2) : t2;
    for (; d$1(c3) && !w(c3); ) {
      const t3 = o(c3), e3 = y$1(c3);
      (l3 ? e3 || r2 : e3 || "static" !== t3.position || !r2 || !["absolute", "fixed"].includes(r2.position)) ? r2 = t3 : i2 = i2.filter((t4) => t4 !== c3), c3 = F(c3);
    }
    return e2.set(t2, i2), i2;
  }(e, this._c) : [].concat(n2), u2 = [...f2, l2], a2 = u2[0], h2 = u2.reduce((t2, n3) => {
    const o2 = S$1(e, n3, c2);
    return t2.top = r(o2.top, t2.top), t2.right = i(o2.right, t2.right), t2.bottom = i(o2.bottom, t2.bottom), t2.left = r(o2.left, t2.left), t2;
  }, S$1(e, a2, c2));
  return { width: h2.right - h2.left, height: h2.bottom - h2.top, x: h2.left, y: h2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
  let { rect: e, offsetParent: n2, strategy: o2 } = t;
  const i2 = a(n2), r2 = R(n2);
  if (n2 === r2)
    return e;
  let l2 = { scrollLeft: 0, scrollTop: 0 }, c2 = { x: 1, y: 1 };
  const f2 = { x: 0, y: 0 };
  if ((i2 || !i2 && "fixed" !== o2) && (("body" !== s(n2) || g$1(r2)) && (l2 = T(n2)), a(n2))) {
    const t2 = E$1(n2);
    c2 = L$1(n2), f2.x = t2.x + n2.clientLeft, f2.y = t2.y + n2.clientTop;
  }
  return { width: e.width * c2.x, height: e.height * c2.y, x: e.x * c2.x - l2.scrollLeft * c2.x + f2.x, y: e.y * c2.y - l2.scrollTop * c2.y + f2.y };
}, isElement: d$1, getDimensions: function(t) {
  return a(t) ? c(t) : t.getBoundingClientRect();
}, getOffsetParent: H, getDocumentElement: R, getScale: L$1, async getElementRects(t) {
  let { reference: e, floating: n2, strategy: o2 } = t;
  const i2 = this.getOffsetParent || H, r2 = this.getDimensions;
  return { reference: O(e, await i2(n2), o2), floating: { x: 0, y: 0, ...await r2(n2) } };
}, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => "rtl" === o(t).direction };
const B = (t, n2, o2) => {
  const i2 = /* @__PURE__ */ new Map(), r2 = { platform: P, ...o2 }, l2 = { ...r2.platform, _c: i2 };
  return computePosition(t, n2, { ...r2, platform: l2 });
};
function fe(e, t) {
  for (const o2 in t)
    Object.prototype.hasOwnProperty.call(t, o2) && (typeof t[o2] == "object" && e[o2] ? fe(e[o2], t[o2]) : e[o2] = t[o2]);
}
const u = {
  // Disable popper components
  disabled: false,
  // Default position offset along main axis (px)
  distance: 5,
  // Default position offset along cross axis (px)
  skidding: 0,
  // Default container where the tooltip will be appended
  container: "body",
  // Element used to compute position and size boundaries
  boundary: void 0,
  // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
  instantMove: false,
  // Auto destroy tooltip DOM nodes (ms)
  disposeTimeout: 5e3,
  // Triggers on the popper itself
  popperTriggers: [],
  // Positioning strategy
  strategy: "absolute",
  // Prevent overflow
  preventOverflow: true,
  // Flip to the opposite placement if needed
  flip: true,
  // Shift on the cross axis to prevent the popper from overflowing
  shift: true,
  // Overflow padding (px)
  overflowPadding: 0,
  // Arrow padding (px)
  arrowPadding: 0,
  // Compute arrow overflow (useful to hide it)
  arrowOverflow: true,
  // Themes
  themes: {
    tooltip: {
      // Default tooltip placement relative to target element
      placement: "top",
      // Default events that trigger the tooltip
      triggers: ["hover", "focus", "touch"],
      // Close tooltip on click on tooltip target
      hideTriggers: (e) => [...e, "click"],
      // Delay (ms)
      delay: {
        show: 200,
        hide: 0
      },
      // Update popper on content resize
      handleResize: false,
      // Enable HTML content in directive
      html: false,
      // Displayed when tooltip content is loading
      loadingContent: "..."
    },
    dropdown: {
      // Default dropdown placement relative to target element
      placement: "bottom",
      // Default events that trigger the dropdown
      triggers: ["click"],
      // Delay (ms)
      delay: 0,
      // Update popper on content resize
      handleResize: true,
      // Hide on clock outside
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function b(e, t) {
  let o2 = u.themes[e] || {}, i2;
  do
    i2 = o2[t], typeof i2 > "u" ? o2.$extend ? o2 = u.themes[o2.$extend] || {} : (o2 = null, i2 = u[t]) : o2 = null;
  while (o2);
  return i2;
}
function Je(e) {
  const t = [e];
  let o2 = u.themes[e] || {};
  do
    o2.$extend && !o2.$resetCss ? (t.push(o2.$extend), o2 = u.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t.map((i2) => `v-popper--theme-${i2}`);
}
function oe(e) {
  const t = [e];
  let o2 = u.themes[e] || {};
  do
    o2.$extend ? (t.push(o2.$extend), o2 = u.themes[o2.$extend] || {}) : o2 = null;
  while (o2);
  return t;
}
let _ = false;
if (typeof window < "u") {
  _ = false;
  try {
    const e = Object.defineProperty({}, "passive", {
      get() {
        _ = true;
      }
    });
    window.addEventListener("test", null, e);
  } catch {
  }
}
let me = false;
typeof window < "u" && typeof navigator < "u" && (me = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
const ge = ["auto", "top", "bottom", "left", "right"].reduce((e, t) => e.concat([
  t,
  `${t}-start`,
  `${t}-end`
]), []), ie = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart",
  pointer: "pointerdown"
}, se = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend",
  pointer: "pointerup"
};
function ne(e, t) {
  const o2 = e.indexOf(t);
  o2 !== -1 && e.splice(o2, 1);
}
function W() {
  return new Promise((e) => requestAnimationFrame(() => {
    requestAnimationFrame(e);
  }));
}
const d = [];
let g = null;
const re = {};
function pe(e) {
  let t = re[e];
  return t || (t = re[e] = []), t;
}
let X = function() {
};
typeof window < "u" && (X = window.Element);
function n(e) {
  return function(t) {
    return b(t.theme, e);
  };
}
const G = "__floating-vue__popper", K = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [G]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [G]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      default: null
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    // eslint-disable-next-line vue/require-prop-types
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: n("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: n("positioningDisabled")
    },
    placement: {
      type: String,
      default: n("placement"),
      validator: (e) => ge.includes(e)
    },
    delay: {
      type: [String, Number, Object],
      default: n("delay")
    },
    distance: {
      type: [Number, String],
      default: n("distance")
    },
    skidding: {
      type: [Number, String],
      default: n("skidding")
    },
    triggers: {
      type: Array,
      default: n("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: n("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: n("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: n("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: n("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: n("popperHideTriggers")
    },
    container: {
      type: [String, Object, X, Boolean],
      default: n("container")
    },
    boundary: {
      type: [String, X],
      default: n("boundary")
    },
    strategy: {
      type: String,
      validator: (e) => ["absolute", "fixed"].includes(e),
      default: n("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: n("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: n("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: n("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: n("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: n("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: n("computeTransformOrigin")
    },
    /**
     * @deprecated
     */
    autoMinSize: {
      type: Boolean,
      default: n("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: n("autoSize")
    },
    /**
     * @deprecated
     */
    autoMaxSize: {
      type: Boolean,
      default: n("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: n("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: n("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: n("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: n("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: n("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: n("flip")
    },
    shift: {
      type: Boolean,
      default: n("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: n("shiftCrossAxis")
    },
    noAutoFocus: {
      type: Boolean,
      default: n("noAutoFocus")
    },
    disposeTimeout: {
      type: Number,
      default: n("disposeTimeout")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: {
          ...this.classes,
          popperClass: this.popperClass
        },
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var e;
      return (e = this[G]) == null ? void 0 : e.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var e, t;
      return ((e = this.popperTriggers) == null ? void 0 : e.includes("hover")) || ((t = this.popperShowTriggers) == null ? void 0 : t.includes("hover"));
    }
  },
  watch: {
    shown: "$_autoShowHide",
    disabled(e) {
      e ? this.dispose() : this.init();
    },
    async container() {
      this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
    },
    ...[
      "triggers",
      "positioningDisabled"
    ].reduce((e, t) => (e[t] = "$_refreshListeners", e), {}),
    ...[
      "placement",
      "distance",
      "skidding",
      "boundary",
      "strategy",
      "overflowPadding",
      "arrowPadding",
      "preventOverflow",
      "shift",
      "shiftCrossAxis",
      "flip"
    ].reduce((e, t) => (e[t] = "$_computePosition", e), {})
  },
  created() {
    this.$_isDisposed = true, this.randomId = `popper_${[Math.random(), Date.now()].map((e) => e.toString(36).substring(2, 10)).join("_")}`, this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
  },
  mounted() {
    this.init(), this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event: e = null, skipDelay: t = false, force: o2 = false } = {}) {
      var i2, s2;
      (i2 = this.parentPopper) != null && i2.lockedChild && this.parentPopper.lockedChild !== this || (this.$_pendingHide = false, (o2 || !this.disabled) && (((s2 = this.parentPopper) == null ? void 0 : s2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e, t), this.$emit("show"), this.$_showFrameLocked = true, requestAnimationFrame(() => {
        this.$_showFrameLocked = false;
      })), this.$emit("update:shown", true));
    },
    hide({ event: e = null, skipDelay: t = false } = {}) {
      var o2;
      if (!this.$_hideInProgress) {
        if (this.shownChildren.size > 0) {
          this.$_pendingHide = true;
          return;
        }
        if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
          this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
            this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t }), this.parentPopper.lockedChild = null);
          }, 1e3));
          return;
        }
        ((o2 = this.parentPopper) == null ? void 0 : o2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_pendingHide = false, this.$_scheduleHide(e, t), this.$emit("hide"), this.$emit("update:shown", false);
      }
    },
    init() {
      var e;
      this.$_isDisposed && (this.$_isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = ((e = this.referenceNode) == null ? void 0 : e.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((t) => t.nodeType === t.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
    },
    dispose() {
      this.$_isDisposed || (this.$_isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs("data-original-title", "title"), this.$emit("dispose"));
    },
    async onResize() {
      this.isShown && (await this.$_computePosition(), this.$emit("resize"));
    },
    async $_computePosition() {
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const e = {
        strategy: this.strategy,
        middleware: []
      };
      (this.distance || this.skidding) && e.middleware.push(offset$2({
        mainAxis: this.distance,
        crossAxis: this.skidding
      }));
      const t = this.placement.startsWith("auto");
      if (t ? e.middleware.push(autoPlacement({
        alignment: this.placement.split("-")[1] ?? ""
      })) : e.placement = this.placement, this.preventOverflow && (this.shift && e.middleware.push(shift({
        padding: this.overflowPadding,
        boundary: this.boundary,
        crossAxis: this.shiftCrossAxis
      })), !t && this.flip && e.middleware.push(flip$2({
        padding: this.overflowPadding,
        boundary: this.boundary
      }))), e.middleware.push(arrow$2({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      })), this.arrowOverflow && e.middleware.push({
        name: "arrowOverflow",
        fn: ({ placement: i2, rects: s2, middlewareData: r2 }) => {
          let p2;
          const { centerOffset: a2 } = r2.arrow;
          return i2.startsWith("top") || i2.startsWith("bottom") ? p2 = Math.abs(a2) > s2.reference.width / 2 : p2 = Math.abs(a2) > s2.reference.height / 2, {
            data: {
              overflow: p2
            }
          };
        }
      }), this.autoMinSize || this.autoSize) {
        const i2 = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        e.middleware.push({
          name: "autoSize",
          fn: ({ rects: s2, placement: r2, middlewareData: p2 }) => {
            var h2;
            if ((h2 = p2.autoSize) != null && h2.skip)
              return {};
            let a2, l2;
            return r2.startsWith("top") || r2.startsWith("bottom") ? a2 = s2.reference.width : l2 = s2.reference.height, this.$_innerNode.style[i2 === "min" ? "minWidth" : i2 === "max" ? "maxWidth" : "width"] = a2 != null ? `${a2}px` : null, this.$_innerNode.style[i2 === "min" ? "minHeight" : i2 === "max" ? "maxHeight" : "height"] = l2 != null ? `${l2}px` : null, {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e.middleware.push(size({
        boundary: this.boundary,
        padding: this.overflowPadding,
        apply: ({ availableWidth: i2, availableHeight: s2 }) => {
          this.$_innerNode.style.maxWidth = i2 != null ? `${i2}px` : null, this.$_innerNode.style.maxHeight = s2 != null ? `${s2}px` : null;
        }
      })));
      const o2 = await B(this.$_referenceNode, this.$_popperNode, e);
      Object.assign(this.result, {
        x: o2.x,
        y: o2.y,
        placement: o2.placement,
        strategy: o2.strategy,
        arrow: {
          ...o2.middlewareData.arrow,
          ...o2.middlewareData.arrowOverflow
        }
      });
    },
    $_scheduleShow(e = null, t = false) {
      if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), g && this.instantMove && g.instantMove && g !== this.parentPopper) {
        g.$_applyHide(true), this.$_applyShow(true);
        return;
      }
      t ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
    },
    $_scheduleHide(e = null, t = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (g = this), t ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
    },
    $_computeDelay(e) {
      const t = this.delay;
      return parseInt(t && t[e] || t || 0);
    },
    async $_applyShow(e = false) {
      clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e, !this.isShown && (this.$_ensureTeleport(), await W(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
        ...D(this.$_referenceNode),
        ...D(this.$_popperNode)
      ], "scroll", () => {
        this.$_computePosition();
      }));
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const t = this.$_referenceNode.getBoundingClientRect(), o2 = this.$_popperNode.querySelector(".v-popper__wrapper"), i2 = o2.parentNode.getBoundingClientRect(), s2 = t.x + t.width / 2 - (i2.left + o2.offsetLeft), r2 = t.y + t.height / 2 - (i2.top + o2.offsetTop);
        this.result.transformOrigin = `${s2}px ${r2}px`;
      }
      this.isShown = true, this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const e = this.showGroup;
      if (e) {
        let t;
        for (let o2 = 0; o2 < d.length; o2++)
          t = d[o2], t.showGroup !== e && (t.hide(), t.$emit("close-group"));
      }
      d.push(this), document.body.classList.add("v-popper--some-open");
      for (const t of oe(this.theme))
        pe(t).push(this), document.body.classList.add(`v-popper--some-open--${t}`);
      this.$emit("apply-show"), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, await W(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
    },
    async $_applyHide(e = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true, this.$_hideInProgress = false;
        return;
      }
      if (clearTimeout(this.$_scheduleTimer), !this.isShown)
        return;
      this.skipTransition = e, ne(d, this), d.length === 0 && document.body.classList.remove("v-popper--some-open");
      for (const o2 of oe(this.theme)) {
        const i2 = pe(o2);
        ne(i2, this), i2.length === 0 && document.body.classList.remove(`v-popper--some-open--${o2}`);
      }
      g === this && (g = null), this.isShown = false, this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      }), clearTimeout(this.$_disposeTimer);
      const t = this.disposeTimeout;
      t !== null && (this.$_disposeTimer = setTimeout(() => {
        this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
      }, t)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, await W(), this.classes.hideFrom = false, this.classes.hideTo = true;
    },
    $_autoShowHide() {
      this.shown ? this.show() : this.hide();
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let e = this.container;
      if (typeof e == "string" ? e = window.document.querySelector(e) : e === false && (e = this.$_targetNodes[0].parentNode), !e)
        throw new Error("No container for popover: " + this.container);
      e.appendChild(this.$_popperNode), this.isMounted = true;
    },
    $_addEventListeners() {
      const e = (o2) => {
        this.isShown && !this.$_hideInProgress || (o2.usedByTooltip = true, !this.$_preventShow && this.show({ event: o2 }));
      };
      this.$_registerTriggerListeners(this.$_targetNodes, ie, this.triggers, this.showTriggers, e), this.$_registerTriggerListeners([this.$_popperNode], ie, this.popperTriggers, this.popperShowTriggers, e);
      const t = (o2) => {
        o2.usedByTooltip || this.hide({ event: o2 });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, se, this.triggers, this.hideTriggers, t), this.$_registerTriggerListeners([this.$_popperNode], se, this.popperTriggers, this.popperHideTriggers, t);
    },
    $_registerEventListeners(e, t, o2) {
      this.$_events.push({ targetNodes: e, eventType: t, handler: o2 }), e.forEach((i2) => i2.addEventListener(t, o2, _ ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(e, t, o2, i2, s2) {
      let r2 = o2;
      i2 != null && (r2 = typeof i2 == "function" ? i2(r2) : i2), r2.forEach((p2) => {
        const a2 = t[p2];
        a2 && this.$_registerEventListeners(e, a2, s2);
      });
    },
    $_removeEventListeners(e) {
      const t = [];
      this.$_events.forEach((o2) => {
        const { targetNodes: i2, eventType: s2, handler: r2 } = o2;
        !e || e === s2 ? i2.forEach((p2) => p2.removeEventListener(s2, r2)) : t.push(o2);
      }), this.$_events = t;
    },
    $_refreshListeners() {
      this.$_isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
    },
    $_handleGlobalClose(e, t = false) {
      this.$_showFrameLocked || (this.hide({ event: e }), e.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), t && (this.$_preventShow = true, setTimeout(() => {
        this.$_preventShow = false;
      }, 300)));
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(e, t) {
      for (const o2 of this.$_targetNodes) {
        const i2 = o2.getAttribute(e);
        i2 && (o2.removeAttribute(e), o2.setAttribute(t, i2));
      }
    },
    $_applyAttrsToTarget(e) {
      for (const t of this.$_targetNodes)
        for (const o2 in e) {
          const i2 = e[o2];
          i2 == null ? t.removeAttribute(o2) : t.setAttribute(o2, i2);
        }
    },
    $_updateParentShownChildren(e) {
      let t = this.parentPopper;
      for (; t; )
        e ? t.shownChildren.add(this.randomId) : (t.shownChildren.delete(this.randomId), t.$_pendingHide && t.hide()), t = t.parentPopper;
    },
    $_isAimingPopper() {
      const e = this.$_referenceNode.getBoundingClientRect();
      if (v >= e.left && v <= e.right && y >= e.top && y <= e.bottom) {
        const t = this.$_popperNode.getBoundingClientRect(), o2 = v - f, i2 = y - m, r2 = t.left + t.width / 2 - f + (t.top + t.height / 2) - m + t.width + t.height, p2 = f + o2 * r2, a2 = m + i2 * r2;
        return S(f, m, p2, a2, t.left, t.top, t.left, t.bottom) || // Left edge
        S(f, m, p2, a2, t.left, t.top, t.right, t.top) || // Top edge
        S(f, m, p2, a2, t.right, t.top, t.right, t.bottom) || // Right edge
        S(f, m, p2, a2, t.left, t.bottom, t.right, t.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
typeof document < "u" && typeof window < "u" && (me ? (document.addEventListener("touchstart", ae, _ ? {
  passive: true,
  capture: true
} : true), document.addEventListener("touchend", Ze, _ ? {
  passive: true,
  capture: true
} : true)) : (window.addEventListener("mousedown", ae, true), window.addEventListener("click", Qe, true)), window.addEventListener("resize", ot));
function ae(e) {
  for (let t = 0; t < d.length; t++) {
    const o2 = d[t];
    try {
      const i2 = o2.popperNode();
      o2.$_mouseDownContains = i2.contains(e.target);
    } catch {
    }
  }
}
function Qe(e) {
  $e(e);
}
function Ze(e) {
  $e(e, true);
}
function $e(e, t = false) {
  const o2 = {};
  for (let i2 = d.length - 1; i2 >= 0; i2--) {
    const s2 = d[i2];
    try {
      const r2 = s2.$_containsGlobalTarget = et(s2, e);
      s2.$_pendingHide = false, requestAnimationFrame(() => {
        if (s2.$_pendingHide = false, !o2[s2.randomId] && de(s2, r2, e)) {
          if (s2.$_handleGlobalClose(e, t), !e.closeAllPopover && e.closePopover && r2) {
            let a2 = s2.parentPopper;
            for (; a2; )
              o2[a2.randomId] = true, a2 = a2.parentPopper;
            return;
          }
          let p2 = s2.parentPopper;
          for (; p2 && de(p2, p2.$_containsGlobalTarget, e); ) {
            p2.$_handleGlobalClose(e, t);
            p2 = p2.parentPopper;
          }
        }
      });
    } catch {
    }
  }
}
function et(e, t) {
  const o2 = e.popperNode();
  return e.$_mouseDownContains || o2.contains(t.target);
}
function de(e, t, o2) {
  return o2.closeAllPopover || o2.closePopover && t || tt(e, o2) && !t;
}
function tt(e, t) {
  if (typeof e.autoHide == "function") {
    const o2 = e.autoHide(t);
    return e.lastAutoHide = o2, o2;
  }
  return e.autoHide;
}
function ot(e) {
  for (let t = 0; t < d.length; t++)
    d[t].$_computePosition(e);
}
let f = 0, m = 0, v = 0, y = 0;
typeof window < "u" && window.addEventListener("mousemove", (e) => {
  f = v, m = y, v = e.clientX, y = e.clientY;
}, _ ? {
  passive: true
} : void 0);
function S(e, t, o2, i2, s2, r2, p2, a2) {
  const l2 = ((p2 - s2) * (t - r2) - (a2 - r2) * (e - s2)) / ((a2 - r2) * (o2 - e) - (p2 - s2) * (i2 - t)), h2 = ((o2 - e) * (t - r2) - (i2 - t) * (e - s2)) / ((a2 - r2) * (o2 - e) - (p2 - s2) * (i2 - t));
  return l2 >= 0 && l2 <= 1 && h2 >= 0 && h2 <= 1;
}
const it = {
  extends: K()
}, k = (e, t) => {
  const o2 = e.__vccOpts || e;
  for (const [i2, s2] of t)
    o2[i2] = s2;
  return o2;
};
function st(e, t, o2, i2, s2, r2) {
  return openBlock(), createElementBlock("div", {
    ref: "reference",
    class: normalizeClass(["v-popper", {
      "v-popper--shown": e.slotData.isShown
    }])
  }, [
    renderSlot(e.$slots, "default", normalizeProps(guardReactiveProps(e.slotData)))
  ], 2);
}
const nt = /* @__PURE__ */ k(it, [["render", st]]);
function rt() {
  var e = window.navigator.userAgent, t = e.indexOf("MSIE ");
  if (t > 0)
    return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
  var o2 = e.indexOf("Trident/");
  if (o2 > 0) {
    var i2 = e.indexOf("rv:");
    return parseInt(e.substring(i2 + 3, e.indexOf(".", i2)), 10);
  }
  var s2 = e.indexOf("Edge/");
  return s2 > 0 ? parseInt(e.substring(s2 + 5, e.indexOf(".", s2)), 10) : -1;
}
let z;
function U() {
  U.init || (U.init = true, z = rt() !== -1);
}
var E = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    U(), nextTick(() => {
      this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
    });
    const e = document.createElement("object");
    this._resizeObject = e, e.setAttribute("aria-hidden", "true"), e.setAttribute("tabindex", -1), e.onload = this.addResizeHandlers, e.type = "text/html", z && this.$el.appendChild(e), e.data = "about:blank", z || this.$el.appendChild(e);
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
    },
    removeResizeHandlers() {
      this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
    }
  }
};
const pt = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const at = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const dt = /* @__PURE__ */ pt((e, t, o2, i2, s2, r2) => (openBlock(), createBlock("div", at)));
E.render = dt;
E.__scopeId = "data-v-b329ee4c";
E.__file = "src/components/ResizeObserver.vue";
const J = (e = "theme") => ({
  computed: {
    themeClass() {
      return Je(this[e]);
    }
  }
}), ht = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: E
  },
  mixins: [
    J()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(e) {
      return e != null && !isNaN(e) ? `${e}px` : null;
    }
  }
});
const lt = ["id", "aria-hidden", "tabindex", "data-popper-placement"], ut = {
  ref: "inner",
  class: "v-popper__inner"
}, ct = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1), ft = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1), mt = [
  ct,
  ft
];
function gt(e, t, o2, i2, s2, r2) {
  const p2 = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: e.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      e.themeClass,
      e.classes.popperClass,
      {
        "v-popper__popper--shown": e.shown,
        "v-popper__popper--hidden": !e.shown,
        "v-popper__popper--show-from": e.classes.showFrom,
        "v-popper__popper--show-to": e.classes.showTo,
        "v-popper__popper--hide-from": e.classes.hideFrom,
        "v-popper__popper--hide-to": e.classes.hideTo,
        "v-popper__popper--skip-transition": e.skipTransition,
        "v-popper__popper--arrow-overflow": e.result && e.result.arrow.overflow,
        "v-popper__popper--no-positioning": !e.result
      }
    ]]),
    style: normalizeStyle(e.result ? {
      position: e.result.strategy,
      transform: `translate3d(${Math.round(e.result.x)}px,${Math.round(e.result.y)}px,0)`
    } : void 0),
    "aria-hidden": e.shown ? "false" : "true",
    tabindex: e.autoHide ? 0 : void 0,
    "data-popper-placement": e.result ? e.result.placement : void 0,
    onKeyup: t[2] || (t[2] = withKeys((a2) => e.autoHide && e.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__backdrop",
      onClick: t[0] || (t[0] = (a2) => e.autoHide && e.$emit("hide"))
    }),
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(e.result ? {
        transformOrigin: e.result.transformOrigin
      } : void 0)
    }, [
      createBaseVNode("div", ut, [
        e.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(e.$slots, "default")
          ]),
          e.handleResize ? (openBlock(), createBlock(p2, {
            key: 0,
            onNotify: t[1] || (t[1] = (a2) => e.$emit("resize", a2))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(e.result ? {
          left: e.toPx(e.result.arrow.x),
          top: e.toPx(e.result.arrow.y)
        } : void 0)
      }, mt, 4)
    ], 4)
  ], 46, lt);
}
const Q = /* @__PURE__ */ k(ht, [["render", gt]]), Z = {
  methods: {
    show(...e) {
      return this.$refs.popper.show(...e);
    },
    hide(...e) {
      return this.$refs.popper.hide(...e);
    },
    dispose(...e) {
      return this.$refs.popper.dispose(...e);
    },
    onResize(...e) {
      return this.$refs.popper.onResize(...e);
    }
  }
}, $t = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: nt,
    PopperContent: Q
  },
  mixins: [
    Z,
    J("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      return this.theme ?? this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$el.children).filter((e) => e !== this.$refs.popperContent.$el);
    }
  }
});
function _t(e, t, o2, i2, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, {
    ref: "popper",
    theme: e.finalTheme,
    "target-nodes": e.getTargetNodes,
    "popper-node": () => e.$refs.popperContent.$el,
    class: normalizeClass([
      e.themeClass
    ])
  }, {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I,
      show: R2,
      hide: w2,
      handleResize: F2,
      onResize: V,
      classes: j,
      result: Oe
    }) => [
      renderSlot(e.$slots, "default", {
        shown: h2,
        show: R2,
        hide: w2
      }),
      createVNode(p2, {
        ref: "popperContent",
        "popper-id": l2,
        theme: e.finalTheme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I,
        "handle-resize": F2,
        classes: j,
        result: Oe,
        onHide: w2,
        onResize: V
      }, {
        default: withCtx(() => [
          renderSlot(e.$slots, "popper", {
            shown: h2,
            hide: w2
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "popper-node", "class"]);
}
const L = /* @__PURE__ */ k($t, [["render", _t]]), _e = {
  ...L,
  name: "VDropdown",
  vPopperTheme: "dropdown"
};
const we = {
  ...L,
  name: "VMenu",
  vPopperTheme: "menu"
}, ve = {
  ...L,
  name: "VTooltip",
  vPopperTheme: "tooltip"
};
const wt = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: K(),
    PopperContent: Q
  },
  mixins: [
    Z
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (e) => b(e.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (e) => b(e.theme, "loadingContent")
    },
    targetNodes: {
      type: Function,
      required: true
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content == "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick(), this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(e) {
      if (typeof this.content == "function" && this.$_isShown && (e || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null, this.$_loading = true;
        const t = ++this.$_fetchId, o2 = this.content(this);
        o2.then ? o2.then((i2) => this.onResult(t, i2)) : this.onResult(t, o2);
      }
    },
    onResult(e, t) {
      e === this.$_fetchId && (this.$_loading = false, this.asyncContent = t);
    },
    onShow() {
      this.$_isShown = true, this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
}), vt = ["innerHTML"], yt = ["textContent"];
function Pt(e, t, o2, i2, s2, r2) {
  const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
  return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e.$attrs, {
    theme: e.theme,
    "target-nodes": e.targetNodes,
    "popper-node": () => e.$refs.popperContent.$el,
    onApplyShow: e.onShow,
    onApplyHide: e.onHide
  }), {
    default: withCtx(({
      popperId: l2,
      isShown: h2,
      shouldMountContent: B2,
      skipTransition: D2,
      autoHide: I,
      hide: R2,
      handleResize: w2,
      onResize: F2,
      classes: V,
      result: j
    }) => [
      createVNode(p2, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": e.loading
        }),
        "popper-id": l2,
        theme: e.theme,
        shown: h2,
        mounted: B2,
        "skip-transition": D2,
        "auto-hide": I,
        "handle-resize": w2,
        classes: V,
        result: j,
        onHide: R2,
        onResize: F2
      }, {
        default: withCtx(() => [
          e.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: e.finalContent
          }, null, 8, vt)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(e.finalContent)
          }, null, 8, yt))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
}
const ye = /* @__PURE__ */ k(wt, [["render", Pt]]), Pe = "v-popper--has-tooltip";
function Tt(e, t) {
  let o2 = e.placement;
  if (!o2 && t)
    for (const i2 of ge)
      t[i2] && (o2 = i2);
  return o2 || (o2 = b(e.theme || "tooltip", "placement")), o2;
}
function Te(e, t, o2) {
  let i2;
  const s2 = typeof t;
  return s2 === "string" ? i2 = { content: t } : t && s2 === "object" ? i2 = t : i2 = { content: false }, i2.placement = Tt(i2, o2), i2.targetNodes = () => [e], i2.referenceNode = () => e, i2;
}
let q, C, bt = 0;
function Ct() {
  if (q)
    return;
  C = ref([]), q = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives: C
      };
    },
    render() {
      return this.directives.map((t) => h$1(ye, {
        ...t.options,
        shown: t.shown || t.options.shown,
        key: t.id
      }));
    },
    devtools: {
      hide: true
    }
  });
  const e = document.createElement("div");
  document.body.appendChild(e), q.mount(e);
}
function St(e, t, o2) {
  Ct();
  const i2 = ref(Te(e, t, o2)), s2 = ref(false), r2 = {
    id: bt++,
    options: i2,
    shown: s2
  };
  return C.value.push(r2), e.classList && e.classList.add(Pe), e.$_popper = {
    options: i2,
    item: r2,
    show() {
      s2.value = true;
    },
    hide() {
      s2.value = false;
    }
  };
}
function be(e) {
  if (e.$_popper) {
    const t = C.value.indexOf(e.$_popper.item);
    t !== -1 && C.value.splice(t, 1), delete e.$_popper, delete e.$_popperOldShown, delete e.$_popperMountTarget;
  }
  e.classList && e.classList.remove(Pe);
}
function he(e, { value: t, modifiers: o2 }) {
  const i2 = Te(e, t, o2);
  if (!i2.content || b(i2.theme || "tooltip", "disabled"))
    be(e);
  else {
    let s2;
    e.$_popper ? (s2 = e.$_popper, s2.options.value = i2) : s2 = St(e, t, o2), typeof t.shown < "u" && t.shown !== e.$_popperOldShown && (e.$_popperOldShown = t.shown, t.shown ? s2.show() : s2.hide());
  }
}
const Ce = {
  beforeMount: he,
  updated: he,
  beforeUnmount(e) {
    be(e);
  }
};
function le(e) {
  e.addEventListener("click", Se), e.addEventListener("touchstart", ze, _ ? {
    passive: true
  } : false);
}
function ue(e) {
  e.removeEventListener("click", Se), e.removeEventListener("touchstart", ze), e.removeEventListener("touchend", Ne), e.removeEventListener("touchcancel", Ae);
}
function Se(e) {
  const t = e.currentTarget;
  e.closePopover = !t.$_vclosepopover_touch, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;
}
function ze(e) {
  if (e.changedTouches.length === 1) {
    const t = e.currentTarget;
    t.$_vclosepopover_touch = true;
    const o2 = e.changedTouches[0];
    t.$_vclosepopover_touchPoint = o2, t.addEventListener("touchend", Ne), t.addEventListener("touchcancel", Ae);
  }
}
function Ne(e) {
  const t = e.currentTarget;
  if (t.$_vclosepopover_touch = false, e.changedTouches.length === 1) {
    const o2 = e.changedTouches[0], i2 = t.$_vclosepopover_touchPoint;
    e.closePopover = Math.abs(o2.screenY - i2.screenY) < 20 && Math.abs(o2.screenX - i2.screenX) < 20, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;
  }
}
function Ae(e) {
  const t = e.currentTarget;
  t.$_vclosepopover_touch = false;
}
const He = {
  beforeMount(e, { value: t, modifiers: o2 }) {
    e.$_closePopoverModifiers = o2, (typeof t > "u" || t) && le(e);
  },
  updated(e, { value: t, oldValue: o2, modifiers: i2 }) {
    e.$_closePopoverModifiers = i2, t !== o2 && (typeof t > "u" || t ? le(e) : ue(e));
  },
  beforeUnmount(e) {
    ue(e);
  }
}, Ot = u, Et = _e;
function zt(e, t = {}) {
  e.$_vTooltipInstalled || (e.$_vTooltipInstalled = true, fe(u, t), e.directive("tooltip", Ce), e.directive("close-popper", He), e.component("VTooltip", ve), e.component("VDropdown", _e), e.component("VMenu", we));
}
const xt = {
  // eslint-disable-next-line no-undef
  version: "2.0.0-beta.24",
  install: zt,
  options: u
};
const style$1 = "";
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b2) => __defProps$1(a2, __getOwnPropDescs$1(b2));
var textareaCaret = { exports: {} };
(function(module) {
  (function() {
    var properties = [
      "direction",
      "boxSizing",
      "width",
      "height",
      "overflowX",
      "overflowY",
      "borderTopWidth",
      "borderRightWidth",
      "borderBottomWidth",
      "borderLeftWidth",
      "borderStyle",
      "paddingTop",
      "paddingRight",
      "paddingBottom",
      "paddingLeft",
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "fontStretch",
      "fontSize",
      "fontSizeAdjust",
      "lineHeight",
      "fontFamily",
      "textAlign",
      "textTransform",
      "textIndent",
      "textDecoration",
      "letterSpacing",
      "wordSpacing",
      "tabSize",
      "MozTabSize"
    ];
    var isBrowser = typeof window !== "undefined";
    var isFirefox = isBrowser && window.mozInnerScreenX != null;
    function getCaretCoordinates(element, position, options2) {
      if (!isBrowser) {
        throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
      }
      var debug = options2 && options2.debug || false;
      if (debug) {
        var el = document.querySelector("#input-textarea-caret-position-mirror-div");
        if (el)
          el.parentNode.removeChild(el);
      }
      var div = document.createElement("div");
      div.id = "input-textarea-caret-position-mirror-div";
      document.body.appendChild(div);
      var style2 = div.style;
      var computed2 = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;
      var isInput = element.nodeName === "INPUT";
      style2.whiteSpace = "pre-wrap";
      if (!isInput)
        style2.wordWrap = "break-word";
      style2.position = "absolute";
      if (!debug)
        style2.visibility = "hidden";
      properties.forEach(function(prop) {
        if (isInput && prop === "lineHeight") {
          style2.lineHeight = computed2.height;
        } else {
          style2[prop] = computed2[prop];
        }
      });
      if (isFirefox) {
        if (element.scrollHeight > parseInt(computed2.height))
          style2.overflowY = "scroll";
      } else {
        style2.overflow = "hidden";
      }
      div.textContent = element.value.substring(0, position);
      if (isInput)
        div.textContent = div.textContent.replace(/\s/g, " ");
      var span = document.createElement("span");
      span.textContent = element.value.substring(position) || ".";
      div.appendChild(span);
      var coordinates = {
        top: span.offsetTop + parseInt(computed2["borderTopWidth"]),
        left: span.offsetLeft + parseInt(computed2["borderLeftWidth"]),
        height: parseInt(computed2["lineHeight"])
      };
      if (debug) {
        span.style.backgroundColor = "#aaa";
      } else {
        document.body.removeChild(div);
      }
      return coordinates;
    }
    {
      module.exports = getCaretCoordinates;
    }
  })();
})(textareaCaret);
var getCaretPosition = textareaCaret.exports;
var _export_sfc$2 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
Ot.themes.mentionable = {
  $extend: "dropdown",
  placement: "top-start",
  arrowPadding: 6,
  arrowOverflow: false
};
const _sfc_main$b = defineComponent({
  components: {
    VDropdown: Et
  },
  inheritAttrs: false,
  props: {
    keys: {
      type: Array,
      required: true
    },
    items: {
      type: Array,
      default: () => []
    },
    omitKey: {
      type: Boolean,
      default: false
    },
    filteringDisabled: {
      type: Boolean,
      default: false
    },
    insertSpace: {
      type: Boolean,
      default: false
    },
    mapInsert: {
      type: Function,
      default: null
    },
    limit: {
      type: Number,
      default: 8
    },
    theme: {
      type: String,
      default: "mentionable"
    },
    caretHeight: {
      type: Number,
      default: 0
    }
  },
  emits: ["search", "open", "close", "apply"],
  setup(props, { emit: emit2 }) {
    const currentKey = ref(null);
    let currentKeyIndex;
    const oldKey = ref(null);
    const searchText = ref(null);
    watch(searchText, (value, oldValue) => {
      if (value) {
        emit2("search", value, oldValue);
      }
    });
    const filteredItems = computed(() => {
      if (!searchText.value || props.filteringDisabled) {
        return props.items;
      }
      const finalSearchText = searchText.value.toLowerCase();
      return props.items.filter((item) => {
        let text;
        if (item.searchText) {
          text = item.searchText;
        } else if (item.label) {
          text = item.label;
        } else {
          text = "";
          for (const key in item) {
            text += item[key];
          }
        }
        return text.toLowerCase().includes(finalSearchText);
      });
    });
    const displayedItems = computed(() => filteredItems.value.slice(0, props.limit));
    const selectedIndex = ref(0);
    watch(displayedItems, () => {
      selectedIndex.value = 0;
    }, {
      deep: true
    });
    let input;
    const el = ref(null);
    function getInput() {
      var _a, _b;
      return (_b = (_a = el.value.querySelector("input")) != null ? _a : el.value.querySelector("textarea")) != null ? _b : el.value.querySelector('[contenteditable="true"]');
    }
    onMounted(() => {
      input = getInput();
      attach();
    });
    onUpdated(() => {
      const newInput = getInput();
      if (newInput !== input) {
        detach();
        input = newInput;
        attach();
      }
    });
    onUnmounted(() => {
      detach();
    });
    function attach() {
      if (input) {
        input.addEventListener("input", onInput);
        input.addEventListener("keydown", onKeyDown);
        input.addEventListener("keyup", onKeyUp);
        input.addEventListener("scroll", onScroll);
        input.addEventListener("blur", onBlur);
      }
    }
    function detach() {
      if (input) {
        input.removeEventListener("input", onInput);
        input.removeEventListener("keydown", onKeyDown);
        input.removeEventListener("keyup", onKeyUp);
        input.removeEventListener("scroll", onScroll);
        input.removeEventListener("blur", onBlur);
      }
    }
    function onInput() {
      checkKey();
    }
    function onBlur() {
      closeMenu();
    }
    function onKeyDown(e) {
      if (currentKey.value) {
        if (e.key === "ArrowDown") {
          selectedIndex.value++;
          if (selectedIndex.value >= displayedItems.value.length) {
            selectedIndex.value = 0;
          }
          cancelEvent(e);
        }
        if (e.key === "ArrowUp") {
          selectedIndex.value--;
          if (selectedIndex.value < 0) {
            selectedIndex.value = displayedItems.value.length - 1;
          }
          cancelEvent(e);
        }
        if ((e.key === "Enter" || e.key === "Tab") && displayedItems.value.length > 0) {
          applyMention(selectedIndex.value);
          cancelEvent(e);
        }
        if (e.key === "Escape") {
          closeMenu();
          cancelEvent(e);
        }
      }
    }
    let cancelKeyUp = null;
    function onKeyUp(e) {
      if (cancelKeyUp && e.key === cancelKeyUp) {
        cancelEvent(e);
      }
      cancelKeyUp = null;
    }
    function cancelEvent(e) {
      e.preventDefault();
      e.stopPropagation();
      cancelKeyUp = e.key;
    }
    function onScroll() {
      updateCaretPosition();
    }
    function getSelectionStart() {
      return input.isContentEditable ? window.getSelection().anchorOffset : input.selectionStart;
    }
    function setCaretPosition(index) {
      nextTick(() => {
        input.selectionEnd = index;
      });
    }
    function getValue2() {
      return input.isContentEditable ? window.getSelection().anchorNode.textContent : input.value;
    }
    function setValue(value) {
      input.value = value;
      emitInputEvent("input");
    }
    function emitInputEvent(type) {
      input.dispatchEvent(new Event(type));
    }
    let lastSearchText = null;
    function checkKey() {
      const index = getSelectionStart();
      if (index >= 0) {
        const { key, keyIndex } = getLastKeyBeforeCaret(index);
        const text = lastSearchText = getLastSearchText(index, keyIndex);
        if (!(keyIndex < 1 || /\s/.test(getValue2()[keyIndex - 1]))) {
          return false;
        }
        if (text != null) {
          openMenu(key, keyIndex);
          searchText.value = text;
          return true;
        }
      }
      closeMenu();
      return false;
    }
    function getLastKeyBeforeCaret(caretIndex) {
      const [keyData] = props.keys.map((key) => ({
        key,
        keyIndex: getValue2().lastIndexOf(key, caretIndex - 1)
      })).sort((a2, b2) => b2.keyIndex - a2.keyIndex);
      return keyData;
    }
    function getLastSearchText(caretIndex, keyIndex) {
      if (keyIndex !== -1) {
        const text = getValue2().substring(keyIndex + 1, caretIndex);
        if (!/\s/.test(text)) {
          return text;
        }
      }
      return null;
    }
    const caretPosition = ref(null);
    function updateCaretPosition() {
      if (currentKey.value) {
        if (input.isContentEditable) {
          const rect = window.getSelection().getRangeAt(0).getBoundingClientRect();
          const inputRect = input.getBoundingClientRect();
          caretPosition.value = {
            left: rect.left - inputRect.left,
            top: rect.top - inputRect.top,
            height: rect.height
          };
        } else {
          caretPosition.value = getCaretPosition(input, currentKeyIndex);
        }
        caretPosition.value.top -= input.scrollTop;
        if (props.caretHeight) {
          caretPosition.value.height = props.caretHeight;
        } else if (isNaN(caretPosition.value.height)) {
          caretPosition.value.height = 16;
        }
      }
    }
    function openMenu(key, keyIndex) {
      if (currentKey.value !== key) {
        currentKey.value = key;
        currentKeyIndex = keyIndex;
        updateCaretPosition();
        selectedIndex.value = 0;
        emit2("open", currentKey.value);
      }
    }
    function closeMenu() {
      if (currentKey.value != null) {
        oldKey.value = currentKey.value;
        currentKey.value = null;
        emit2("close", oldKey.value);
      }
    }
    function applyMention(itemIndex) {
      const item = displayedItems.value[itemIndex];
      const value = (props.omitKey ? "" : currentKey.value) + String(props.mapInsert ? props.mapInsert(item, currentKey.value) : item.value) + (props.insertSpace ? " " : "");
      if (input.isContentEditable) {
        const range = window.getSelection().getRangeAt(0);
        range.setStart(range.startContainer, range.startOffset - currentKey.value.length - (lastSearchText ? lastSearchText.length : 0));
        range.deleteContents();
        range.insertNode(document.createTextNode(value));
        range.setStart(range.endContainer, range.endOffset);
        emitInputEvent("input");
      } else {
        setValue(replaceText(getValue2(), searchText.value, value, currentKeyIndex));
        setCaretPosition(currentKeyIndex + value.length);
      }
      emit2("apply", item, currentKey.value, value);
      closeMenu();
    }
    function replaceText(text, searchString, newText, index) {
      return text.slice(0, index) + newText + text.slice(index + searchString.length + 1, text.length);
    }
    return {
      el,
      currentKey,
      oldKey,
      caretPosition,
      displayedItems,
      selectedIndex,
      applyMention
    };
  }
});
const _hoisted_1$b = { key: 0 };
const _hoisted_2$b = /* @__PURE__ */ createTextVNode(" No result ");
const _hoisted_3$b = ["onMouseover", "onMousedown"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VDropdown = resolveComponent("VDropdown");
  return openBlock(), createElementBlock("div", {
    ref: "el",
    class: normalizeClass(["mentionable", _ctx.$attrs.class]),
    style: { "position": "relative" }
  }, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_VDropdown, mergeProps({ ref: "popper" }, __spreadProps$1(__spreadValues$1({}, _ctx.$attrs), { class: void 0 }), {
      shown: !!_ctx.currentKey,
      triggers: [],
      "auto-hide": false,
      theme: _ctx.theme,
      class: "popper",
      style: [{ "position": "absolute" }, _ctx.caretPosition ? {
        top: `${_ctx.caretPosition.top}px`,
        left: `${_ctx.caretPosition.left}px`
      } : {}]
    }), {
      popper: withCtx(() => [
        !_ctx.displayedItems.length ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
          renderSlot(_ctx.$slots, "no-result", {}, () => [
            _hoisted_2$b
          ])
        ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.displayedItems, (item, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass(["mention-item", {
              "mention-selected": _ctx.selectedIndex === index
            }]),
            onMouseover: ($event) => _ctx.selectedIndex = index,
            onMousedown: ($event) => _ctx.applyMention(index)
          }, [
            renderSlot(_ctx.$slots, `item-${_ctx.currentKey || _ctx.oldKey}`, {
              item,
              index
            }, () => [
              renderSlot(_ctx.$slots, "item", {
                item,
                index
              }, () => [
                createTextVNode(toDisplayString(item.label || item.value), 1)
              ])
            ])
          ], 42, _hoisted_3$b);
        }), 128))
      ]),
      default: withCtx(() => [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.caretPosition ? {
            height: `${_ctx.caretPosition.height}px`
          } : {})
        }, null, 4)
      ]),
      _: 3
    }, 16, ["shown", "theme", "style"])
  ], 2);
}
var Mentionable = /* @__PURE__ */ _export_sfc$2(_sfc_main$b, [["render", _sfc_render$b]]);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
const EMOJI_REMOTE_SRC = "https://cdn.jsdelivr.net/npm/emoji-datasource-apple@6.0.1/img/apple/64";
const GROUP_NAMES = {
  recent: "Recently used",
  smileys_people: "Smiles & People",
  animals_nature: "Animals & Nature",
  food_drink: "Food & Drink",
  activities: "Activities",
  travel_places: "Travel places",
  objects: "Objects",
  symbols: "Symbols",
  flags: "Flags"
};
const EMOJI_UNICODE_KEY = "u";
const EMOJI_NAME_KEY = "n";
const EMOJI_VARIATIONS_KEY = "v";
const EMOJI_RESULT_KEY = "r";
const DEFAULT_EMOJI = {
  [EMOJI_NAME_KEY]: ["grinning face", "grinning"],
  [EMOJI_UNICODE_KEY]: "1f600",
  [EMOJI_RESULT_KEY]: "1f600"
};
const SKIN_TONE_NEUTRAL = "neutral";
const SKIN_TONE_LIGHT = "1f3fb";
const SKIN_TONE_MEDIUM_LIGHT = "1f3fc";
const SKIN_TONE_MEDIUM = "1f3fd";
const SKIN_TONE_MEDIUM_DARK = "1f3fe";
const SKIN_TONE_DARK = "1f3ff";
const SKIN_TONES = [
  SKIN_TONE_NEUTRAL,
  SKIN_TONE_LIGHT,
  SKIN_TONE_MEDIUM_LIGHT,
  SKIN_TONE_MEDIUM,
  SKIN_TONE_MEDIUM_DARK,
  SKIN_TONE_DARK
];
const STATIC_TEXTS = {
  placeholder: "Search emoji",
  skinTone: "Skin tone"
};
const COLOR_THEMES = ["light", "dark", "auto"];
const smileys_people$1 = [
  {
    n: [
      "grinning face",
      "grinning"
    ],
    u: "1f600"
  },
  {
    n: [
      "grinning face with smiling eyes",
      "grin"
    ],
    u: "1f601"
  },
  {
    n: [
      "face with tears of joy",
      "joy"
    ],
    u: "1f602"
  },
  {
    n: [
      "rolling on the floor laughing",
      "rolling_on_the_floor_laughing"
    ],
    u: "1f923"
  },
  {
    n: [
      "smiling face with open mouth",
      "smiley"
    ],
    u: "1f603"
  },
  {
    n: [
      "smiling face with open mouth and smiling eyes",
      "smile"
    ],
    u: "1f604"
  },
  {
    n: [
      "smiling face with open mouth and cold sweat",
      "sweat_smile"
    ],
    u: "1f605"
  },
  {
    n: [
      "smiling face with open mouth and tightly-closed eyes",
      "laughing",
      "satisfied"
    ],
    u: "1f606"
  },
  {
    n: [
      "winking face",
      "wink"
    ],
    u: "1f609"
  },
  {
    n: [
      "smiling face with smiling eyes",
      "blush"
    ],
    u: "1f60a"
  },
  {
    n: [
      "face savouring delicious food",
      "yum"
    ],
    u: "1f60b"
  },
  {
    n: [
      "smiling face with sunglasses",
      "sunglasses"
    ],
    u: "1f60e"
  },
  {
    n: [
      "smiling face with heart-shaped eyes",
      "heart_eyes"
    ],
    u: "1f60d"
  },
  {
    n: [
      "face throwing a kiss",
      "kissing_heart"
    ],
    u: "1f618"
  },
  {
    n: [
      "kissing face",
      "kissing"
    ],
    u: "1f617"
  },
  {
    n: [
      "kissing face with smiling eyes",
      "kissing_smiling_eyes"
    ],
    u: "1f619"
  },
  {
    n: [
      "kissing face with closed eyes",
      "kissing_closed_eyes"
    ],
    u: "1f61a"
  },
  {
    n: [
      "white smiling face",
      "relaxed"
    ],
    u: "263a-fe0f"
  },
  {
    n: [
      "slightly smiling face",
      "slightly_smiling_face"
    ],
    u: "1f642"
  },
  {
    n: [
      "hugging face",
      "hugging_face"
    ],
    u: "1f917"
  },
  {
    n: [
      "grinning face with star eyes",
      "star-struck",
      "grinning_face_with_star_eyes"
    ],
    u: "1f929"
  },
  {
    n: [
      "thinking face",
      "thinking_face"
    ],
    u: "1f914"
  },
  {
    n: [
      "face with one eyebrow raised",
      "face_with_raised_eyebrow",
      "face_with_one_eyebrow_raised"
    ],
    u: "1f928"
  },
  {
    n: [
      "neutral face",
      "neutral_face"
    ],
    u: "1f610"
  },
  {
    n: [
      "expressionless face",
      "expressionless"
    ],
    u: "1f611"
  },
  {
    n: [
      "face without mouth",
      "no_mouth"
    ],
    u: "1f636"
  },
  {
    n: [
      "face with rolling eyes",
      "face_with_rolling_eyes"
    ],
    u: "1f644"
  },
  {
    n: [
      "smirking face",
      "smirk"
    ],
    u: "1f60f"
  },
  {
    n: [
      "persevering face",
      "persevere"
    ],
    u: "1f623"
  },
  {
    n: [
      "disappointed but relieved face",
      "disappointed_relieved"
    ],
    u: "1f625"
  },
  {
    n: [
      "face with open mouth",
      "open_mouth"
    ],
    u: "1f62e"
  },
  {
    n: [
      "zipper-mouth face",
      "zipper_mouth_face"
    ],
    u: "1f910"
  },
  {
    n: [
      "hushed face",
      "hushed"
    ],
    u: "1f62f"
  },
  {
    n: [
      "sleepy face",
      "sleepy"
    ],
    u: "1f62a"
  },
  {
    n: [
      "tired face",
      "tired_face"
    ],
    u: "1f62b"
  },
  {
    n: [
      "sleeping face",
      "sleeping"
    ],
    u: "1f634"
  },
  {
    n: [
      "relieved face",
      "relieved"
    ],
    u: "1f60c"
  },
  {
    n: [
      "face with stuck-out tongue",
      "stuck_out_tongue"
    ],
    u: "1f61b"
  },
  {
    n: [
      "face with stuck-out tongue and winking eye",
      "stuck_out_tongue_winking_eye"
    ],
    u: "1f61c"
  },
  {
    n: [
      "face with stuck-out tongue and tightly-closed eyes",
      "stuck_out_tongue_closed_eyes"
    ],
    u: "1f61d"
  },
  {
    n: [
      "drooling face",
      "drooling_face"
    ],
    u: "1f924"
  },
  {
    n: [
      "unamused face",
      "unamused"
    ],
    u: "1f612"
  },
  {
    n: [
      "face with cold sweat",
      "sweat"
    ],
    u: "1f613"
  },
  {
    n: [
      "pensive face",
      "pensive"
    ],
    u: "1f614"
  },
  {
    n: [
      "confused face",
      "confused"
    ],
    u: "1f615"
  },
  {
    n: [
      "upside-down face",
      "upside_down_face"
    ],
    u: "1f643"
  },
  {
    n: [
      "money-mouth face",
      "money_mouth_face"
    ],
    u: "1f911"
  },
  {
    n: [
      "astonished face",
      "astonished"
    ],
    u: "1f632"
  },
  {
    n: [
      "white_frowning_face"
    ],
    u: "2639-fe0f"
  },
  {
    n: [
      "slightly frowning face",
      "slightly_frowning_face"
    ],
    u: "1f641"
  },
  {
    n: [
      "confounded face",
      "confounded"
    ],
    u: "1f616"
  },
  {
    n: [
      "disappointed face",
      "disappointed"
    ],
    u: "1f61e"
  },
  {
    n: [
      "worried face",
      "worried"
    ],
    u: "1f61f"
  },
  {
    n: [
      "face with look of triumph",
      "triumph"
    ],
    u: "1f624"
  },
  {
    n: [
      "crying face",
      "cry"
    ],
    u: "1f622"
  },
  {
    n: [
      "loudly crying face",
      "sob"
    ],
    u: "1f62d"
  },
  {
    n: [
      "frowning face with open mouth",
      "frowning"
    ],
    u: "1f626"
  },
  {
    n: [
      "anguished face",
      "anguished"
    ],
    u: "1f627"
  },
  {
    n: [
      "fearful face",
      "fearful"
    ],
    u: "1f628"
  },
  {
    n: [
      "weary face",
      "weary"
    ],
    u: "1f629"
  },
  {
    n: [
      "shocked face with exploding head",
      "exploding_head",
      "shocked_face_with_exploding_head"
    ],
    u: "1f92f"
  },
  {
    n: [
      "grimacing face",
      "grimacing"
    ],
    u: "1f62c"
  },
  {
    n: [
      "face with open mouth and cold sweat",
      "cold_sweat"
    ],
    u: "1f630"
  },
  {
    n: [
      "face screaming in fear",
      "scream"
    ],
    u: "1f631"
  },
  {
    n: [
      "flushed face",
      "flushed"
    ],
    u: "1f633"
  },
  {
    n: [
      "grinning face with one large and one small eye",
      "zany_face",
      "grinning_face_with_one_large_and_one_small_eye"
    ],
    u: "1f92a"
  },
  {
    n: [
      "dizzy face",
      "dizzy_face"
    ],
    u: "1f635"
  },
  {
    n: [
      "pouting face",
      "rage"
    ],
    u: "1f621"
  },
  {
    n: [
      "angry face",
      "angry"
    ],
    u: "1f620"
  },
  {
    n: [
      "serious face with symbols covering mouth",
      "face_with_symbols_on_mouth",
      "serious_face_with_symbols_covering_mouth"
    ],
    u: "1f92c"
  },
  {
    n: [
      "face with medical mask",
      "mask"
    ],
    u: "1f637"
  },
  {
    n: [
      "face with thermometer",
      "face_with_thermometer"
    ],
    u: "1f912"
  },
  {
    n: [
      "face with head-bandage",
      "face_with_head_bandage"
    ],
    u: "1f915"
  },
  {
    n: [
      "nauseated face",
      "nauseated_face"
    ],
    u: "1f922"
  },
  {
    n: [
      "face with open mouth vomiting",
      "face_vomiting",
      "face_with_open_mouth_vomiting"
    ],
    u: "1f92e"
  },
  {
    n: [
      "sneezing face",
      "sneezing_face"
    ],
    u: "1f927"
  },
  {
    n: [
      "smiling face with halo",
      "innocent"
    ],
    u: "1f607"
  },
  {
    n: [
      "face with cowboy hat",
      "face_with_cowboy_hat"
    ],
    u: "1f920"
  },
  {
    n: [
      "clown face",
      "clown_face"
    ],
    u: "1f921"
  },
  {
    n: [
      "lying face",
      "lying_face"
    ],
    u: "1f925"
  },
  {
    n: [
      "face with finger covering closed lips",
      "shushing_face",
      "face_with_finger_covering_closed_lips"
    ],
    u: "1f92b"
  },
  {
    n: [
      "smiling face with smiling eyes and hand covering mouth",
      "face_with_hand_over_mouth",
      "smiling_face_with_smiling_eyes_and_hand_covering_mouth"
    ],
    u: "1f92d"
  },
  {
    n: [
      "face with monocle",
      "face_with_monocle"
    ],
    u: "1f9d0"
  },
  {
    n: [
      "nerd face",
      "nerd_face"
    ],
    u: "1f913"
  },
  {
    n: [
      "smiling face with horns",
      "smiling_imp"
    ],
    u: "1f608"
  },
  {
    n: [
      "imp"
    ],
    u: "1f47f"
  },
  {
    n: [
      "japanese ogre",
      "japanese_ogre"
    ],
    u: "1f479"
  },
  {
    n: [
      "japanese goblin",
      "japanese_goblin"
    ],
    u: "1f47a"
  },
  {
    n: [
      "skull"
    ],
    u: "1f480"
  },
  {
    n: [
      "skull_and_crossbones"
    ],
    u: "2620-fe0f"
  },
  {
    n: [
      "ghost"
    ],
    u: "1f47b"
  },
  {
    n: [
      "extraterrestrial alien",
      "alien"
    ],
    u: "1f47d"
  },
  {
    n: [
      "alien monster",
      "space_invader"
    ],
    u: "1f47e"
  },
  {
    n: [
      "robot face",
      "robot_face"
    ],
    u: "1f916"
  },
  {
    n: [
      "pile of poo",
      "hankey",
      "poop",
      "shit"
    ],
    u: "1f4a9"
  },
  {
    n: [
      "smiling cat face with open mouth",
      "smiley_cat"
    ],
    u: "1f63a"
  },
  {
    n: [
      "grinning cat face with smiling eyes",
      "smile_cat"
    ],
    u: "1f638"
  },
  {
    n: [
      "cat face with tears of joy",
      "joy_cat"
    ],
    u: "1f639"
  },
  {
    n: [
      "smiling cat face with heart-shaped eyes",
      "heart_eyes_cat"
    ],
    u: "1f63b"
  },
  {
    n: [
      "cat face with wry smile",
      "smirk_cat"
    ],
    u: "1f63c"
  },
  {
    n: [
      "kissing cat face with closed eyes",
      "kissing_cat"
    ],
    u: "1f63d"
  },
  {
    n: [
      "weary cat face",
      "scream_cat"
    ],
    u: "1f640"
  },
  {
    n: [
      "crying cat face",
      "crying_cat_face"
    ],
    u: "1f63f"
  },
  {
    n: [
      "pouting cat face",
      "pouting_cat"
    ],
    u: "1f63e"
  },
  {
    n: [
      "see-no-evil monkey",
      "see_no_evil"
    ],
    u: "1f648"
  },
  {
    n: [
      "hear-no-evil monkey",
      "hear_no_evil"
    ],
    u: "1f649"
  },
  {
    n: [
      "speak-no-evil monkey",
      "speak_no_evil"
    ],
    u: "1f64a"
  },
  {
    n: [
      "baby"
    ],
    u: "1f476",
    v: [
      "1f476-1f3fb",
      "1f476-1f3fc",
      "1f476-1f3fd",
      "1f476-1f3fe",
      "1f476-1f3ff"
    ]
  },
  {
    n: [
      "child"
    ],
    u: "1f9d2",
    v: [
      "1f9d2-1f3fb",
      "1f9d2-1f3fc",
      "1f9d2-1f3fd",
      "1f9d2-1f3fe",
      "1f9d2-1f3ff"
    ]
  },
  {
    n: [
      "boy"
    ],
    u: "1f466",
    v: [
      "1f466-1f3fb",
      "1f466-1f3fc",
      "1f466-1f3fd",
      "1f466-1f3fe",
      "1f466-1f3ff"
    ]
  },
  {
    n: [
      "girl"
    ],
    u: "1f467",
    v: [
      "1f467-1f3fb",
      "1f467-1f3fc",
      "1f467-1f3fd",
      "1f467-1f3fe",
      "1f467-1f3ff"
    ]
  },
  {
    n: [
      "adult"
    ],
    u: "1f9d1",
    v: [
      "1f9d1-1f3fb",
      "1f9d1-1f3fc",
      "1f9d1-1f3fd",
      "1f9d1-1f3fe",
      "1f9d1-1f3ff"
    ]
  },
  {
    n: [
      "man"
    ],
    u: "1f468",
    v: [
      "1f468-1f3fb",
      "1f468-1f3fc",
      "1f468-1f3fd",
      "1f468-1f3fe",
      "1f468-1f3ff"
    ]
  },
  {
    n: [
      "woman"
    ],
    u: "1f469",
    v: [
      "1f469-1f3fb",
      "1f469-1f3fc",
      "1f469-1f3fd",
      "1f469-1f3fe",
      "1f469-1f3ff"
    ]
  },
  {
    n: [
      "older adult",
      "older_adult"
    ],
    u: "1f9d3",
    v: [
      "1f9d3-1f3fb",
      "1f9d3-1f3fc",
      "1f9d3-1f3fd",
      "1f9d3-1f3fe",
      "1f9d3-1f3ff"
    ]
  },
  {
    n: [
      "older man",
      "older_man"
    ],
    u: "1f474",
    v: [
      "1f474-1f3fb",
      "1f474-1f3fc",
      "1f474-1f3fd",
      "1f474-1f3fe",
      "1f474-1f3ff"
    ]
  },
  {
    n: [
      "older woman",
      "older_woman"
    ],
    u: "1f475",
    v: [
      "1f475-1f3fb",
      "1f475-1f3fc",
      "1f475-1f3fd",
      "1f475-1f3fe",
      "1f475-1f3ff"
    ]
  },
  {
    n: [
      "male-doctor"
    ],
    u: "1f468-200d-2695-fe0f",
    v: [
      "1f468-1f3fb-200d-2695-fe0f",
      "1f468-1f3fc-200d-2695-fe0f",
      "1f468-1f3fd-200d-2695-fe0f",
      "1f468-1f3fe-200d-2695-fe0f",
      "1f468-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "female-doctor"
    ],
    u: "1f469-200d-2695-fe0f",
    v: [
      "1f469-1f3fb-200d-2695-fe0f",
      "1f469-1f3fc-200d-2695-fe0f",
      "1f469-1f3fd-200d-2695-fe0f",
      "1f469-1f3fe-200d-2695-fe0f",
      "1f469-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "male-student"
    ],
    u: "1f468-200d-1f393",
    v: [
      "1f468-1f3fb-200d-1f393",
      "1f468-1f3fc-200d-1f393",
      "1f468-1f3fd-200d-1f393",
      "1f468-1f3fe-200d-1f393",
      "1f468-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "female-student"
    ],
    u: "1f469-200d-1f393",
    v: [
      "1f469-1f3fb-200d-1f393",
      "1f469-1f3fc-200d-1f393",
      "1f469-1f3fd-200d-1f393",
      "1f469-1f3fe-200d-1f393",
      "1f469-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "male-teacher"
    ],
    u: "1f468-200d-1f3eb",
    v: [
      "1f468-1f3fb-200d-1f3eb",
      "1f468-1f3fc-200d-1f3eb",
      "1f468-1f3fd-200d-1f3eb",
      "1f468-1f3fe-200d-1f3eb",
      "1f468-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "female-teacher"
    ],
    u: "1f469-200d-1f3eb",
    v: [
      "1f469-1f3fb-200d-1f3eb",
      "1f469-1f3fc-200d-1f3eb",
      "1f469-1f3fd-200d-1f3eb",
      "1f469-1f3fe-200d-1f3eb",
      "1f469-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "male-judge"
    ],
    u: "1f468-200d-2696-fe0f",
    v: [
      "1f468-1f3fb-200d-2696-fe0f",
      "1f468-1f3fc-200d-2696-fe0f",
      "1f468-1f3fd-200d-2696-fe0f",
      "1f468-1f3fe-200d-2696-fe0f",
      "1f468-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "female-judge"
    ],
    u: "1f469-200d-2696-fe0f",
    v: [
      "1f469-1f3fb-200d-2696-fe0f",
      "1f469-1f3fc-200d-2696-fe0f",
      "1f469-1f3fd-200d-2696-fe0f",
      "1f469-1f3fe-200d-2696-fe0f",
      "1f469-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "male-farmer"
    ],
    u: "1f468-200d-1f33e",
    v: [
      "1f468-1f3fb-200d-1f33e",
      "1f468-1f3fc-200d-1f33e",
      "1f468-1f3fd-200d-1f33e",
      "1f468-1f3fe-200d-1f33e",
      "1f468-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "female-farmer"
    ],
    u: "1f469-200d-1f33e",
    v: [
      "1f469-1f3fb-200d-1f33e",
      "1f469-1f3fc-200d-1f33e",
      "1f469-1f3fd-200d-1f33e",
      "1f469-1f3fe-200d-1f33e",
      "1f469-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "male-cook"
    ],
    u: "1f468-200d-1f373",
    v: [
      "1f468-1f3fb-200d-1f373",
      "1f468-1f3fc-200d-1f373",
      "1f468-1f3fd-200d-1f373",
      "1f468-1f3fe-200d-1f373",
      "1f468-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "female-cook"
    ],
    u: "1f469-200d-1f373",
    v: [
      "1f469-1f3fb-200d-1f373",
      "1f469-1f3fc-200d-1f373",
      "1f469-1f3fd-200d-1f373",
      "1f469-1f3fe-200d-1f373",
      "1f469-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "male-mechanic"
    ],
    u: "1f468-200d-1f527",
    v: [
      "1f468-1f3fb-200d-1f527",
      "1f468-1f3fc-200d-1f527",
      "1f468-1f3fd-200d-1f527",
      "1f468-1f3fe-200d-1f527",
      "1f468-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "female-mechanic"
    ],
    u: "1f469-200d-1f527",
    v: [
      "1f469-1f3fb-200d-1f527",
      "1f469-1f3fc-200d-1f527",
      "1f469-1f3fd-200d-1f527",
      "1f469-1f3fe-200d-1f527",
      "1f469-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "male-factory-worker"
    ],
    u: "1f468-200d-1f3ed",
    v: [
      "1f468-1f3fb-200d-1f3ed",
      "1f468-1f3fc-200d-1f3ed",
      "1f468-1f3fd-200d-1f3ed",
      "1f468-1f3fe-200d-1f3ed",
      "1f468-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "female-factory-worker"
    ],
    u: "1f469-200d-1f3ed",
    v: [
      "1f469-1f3fb-200d-1f3ed",
      "1f469-1f3fc-200d-1f3ed",
      "1f469-1f3fd-200d-1f3ed",
      "1f469-1f3fe-200d-1f3ed",
      "1f469-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "male-office-worker"
    ],
    u: "1f468-200d-1f4bc",
    v: [
      "1f468-1f3fb-200d-1f4bc",
      "1f468-1f3fc-200d-1f4bc",
      "1f468-1f3fd-200d-1f4bc",
      "1f468-1f3fe-200d-1f4bc",
      "1f468-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "female-office-worker"
    ],
    u: "1f469-200d-1f4bc",
    v: [
      "1f469-1f3fb-200d-1f4bc",
      "1f469-1f3fc-200d-1f4bc",
      "1f469-1f3fd-200d-1f4bc",
      "1f469-1f3fe-200d-1f4bc",
      "1f469-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "male-scientist"
    ],
    u: "1f468-200d-1f52c",
    v: [
      "1f468-1f3fb-200d-1f52c",
      "1f468-1f3fc-200d-1f52c",
      "1f468-1f3fd-200d-1f52c",
      "1f468-1f3fe-200d-1f52c",
      "1f468-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "female-scientist"
    ],
    u: "1f469-200d-1f52c",
    v: [
      "1f469-1f3fb-200d-1f52c",
      "1f469-1f3fc-200d-1f52c",
      "1f469-1f3fd-200d-1f52c",
      "1f469-1f3fe-200d-1f52c",
      "1f469-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "male-technologist"
    ],
    u: "1f468-200d-1f4bb",
    v: [
      "1f468-1f3fb-200d-1f4bb",
      "1f468-1f3fc-200d-1f4bb",
      "1f468-1f3fd-200d-1f4bb",
      "1f468-1f3fe-200d-1f4bb",
      "1f468-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "female-technologist"
    ],
    u: "1f469-200d-1f4bb",
    v: [
      "1f469-1f3fb-200d-1f4bb",
      "1f469-1f3fc-200d-1f4bb",
      "1f469-1f3fd-200d-1f4bb",
      "1f469-1f3fe-200d-1f4bb",
      "1f469-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "male-singer"
    ],
    u: "1f468-200d-1f3a4",
    v: [
      "1f468-1f3fb-200d-1f3a4",
      "1f468-1f3fc-200d-1f3a4",
      "1f468-1f3fd-200d-1f3a4",
      "1f468-1f3fe-200d-1f3a4",
      "1f468-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "female-singer"
    ],
    u: "1f469-200d-1f3a4",
    v: [
      "1f469-1f3fb-200d-1f3a4",
      "1f469-1f3fc-200d-1f3a4",
      "1f469-1f3fd-200d-1f3a4",
      "1f469-1f3fe-200d-1f3a4",
      "1f469-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "male-artist"
    ],
    u: "1f468-200d-1f3a8",
    v: [
      "1f468-1f3fb-200d-1f3a8",
      "1f468-1f3fc-200d-1f3a8",
      "1f468-1f3fd-200d-1f3a8",
      "1f468-1f3fe-200d-1f3a8",
      "1f468-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "female-artist"
    ],
    u: "1f469-200d-1f3a8",
    v: [
      "1f469-1f3fb-200d-1f3a8",
      "1f469-1f3fc-200d-1f3a8",
      "1f469-1f3fd-200d-1f3a8",
      "1f469-1f3fe-200d-1f3a8",
      "1f469-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "male-pilot"
    ],
    u: "1f468-200d-2708-fe0f",
    v: [
      "1f468-1f3fb-200d-2708-fe0f",
      "1f468-1f3fc-200d-2708-fe0f",
      "1f468-1f3fd-200d-2708-fe0f",
      "1f468-1f3fe-200d-2708-fe0f",
      "1f468-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "female-pilot"
    ],
    u: "1f469-200d-2708-fe0f",
    v: [
      "1f469-1f3fb-200d-2708-fe0f",
      "1f469-1f3fc-200d-2708-fe0f",
      "1f469-1f3fd-200d-2708-fe0f",
      "1f469-1f3fe-200d-2708-fe0f",
      "1f469-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "male-astronaut"
    ],
    u: "1f468-200d-1f680",
    v: [
      "1f468-1f3fb-200d-1f680",
      "1f468-1f3fc-200d-1f680",
      "1f468-1f3fd-200d-1f680",
      "1f468-1f3fe-200d-1f680",
      "1f468-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "female-astronaut"
    ],
    u: "1f469-200d-1f680",
    v: [
      "1f469-1f3fb-200d-1f680",
      "1f469-1f3fc-200d-1f680",
      "1f469-1f3fd-200d-1f680",
      "1f469-1f3fe-200d-1f680",
      "1f469-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "male-firefighter"
    ],
    u: "1f468-200d-1f692",
    v: [
      "1f468-1f3fb-200d-1f692",
      "1f468-1f3fc-200d-1f692",
      "1f468-1f3fd-200d-1f692",
      "1f468-1f3fe-200d-1f692",
      "1f468-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "female-firefighter"
    ],
    u: "1f469-200d-1f692",
    v: [
      "1f469-1f3fb-200d-1f692",
      "1f469-1f3fc-200d-1f692",
      "1f469-1f3fd-200d-1f692",
      "1f469-1f3fe-200d-1f692",
      "1f469-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "police officer",
      "cop"
    ],
    u: "1f46e",
    v: [
      "1f46e-1f3fb",
      "1f46e-1f3fc",
      "1f46e-1f3fd",
      "1f46e-1f3fe",
      "1f46e-1f3ff"
    ]
  },
  {
    n: [
      "male-police-officer"
    ],
    u: "1f46e-200d-2642-fe0f",
    v: [
      "1f46e-1f3fb-200d-2642-fe0f",
      "1f46e-1f3fc-200d-2642-fe0f",
      "1f46e-1f3fd-200d-2642-fe0f",
      "1f46e-1f3fe-200d-2642-fe0f",
      "1f46e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-police-officer"
    ],
    u: "1f46e-200d-2640-fe0f",
    v: [
      "1f46e-1f3fb-200d-2640-fe0f",
      "1f46e-1f3fc-200d-2640-fe0f",
      "1f46e-1f3fd-200d-2640-fe0f",
      "1f46e-1f3fe-200d-2640-fe0f",
      "1f46e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "sleuth_or_spy"
    ],
    u: "1f575-fe0f",
    v: [
      "1f575-1f3fb",
      "1f575-1f3fc",
      "1f575-1f3fd",
      "1f575-1f3fe",
      "1f575-1f3ff"
    ]
  },
  {
    n: [
      "male-detective"
    ],
    u: "1f575-fe0f-200d-2642-fe0f",
    v: [
      "1f575-1f3fb-200d-2642-fe0f",
      "1f575-1f3fc-200d-2642-fe0f",
      "1f575-1f3fd-200d-2642-fe0f",
      "1f575-1f3fe-200d-2642-fe0f",
      "1f575-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-detective"
    ],
    u: "1f575-fe0f-200d-2640-fe0f",
    v: [
      "1f575-1f3fb-200d-2640-fe0f",
      "1f575-1f3fc-200d-2640-fe0f",
      "1f575-1f3fd-200d-2640-fe0f",
      "1f575-1f3fe-200d-2640-fe0f",
      "1f575-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "guardsman"
    ],
    u: "1f482",
    v: [
      "1f482-1f3fb",
      "1f482-1f3fc",
      "1f482-1f3fd",
      "1f482-1f3fe",
      "1f482-1f3ff"
    ]
  },
  {
    n: [
      "male-guard"
    ],
    u: "1f482-200d-2642-fe0f",
    v: [
      "1f482-1f3fb-200d-2642-fe0f",
      "1f482-1f3fc-200d-2642-fe0f",
      "1f482-1f3fd-200d-2642-fe0f",
      "1f482-1f3fe-200d-2642-fe0f",
      "1f482-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-guard"
    ],
    u: "1f482-200d-2640-fe0f",
    v: [
      "1f482-1f3fb-200d-2640-fe0f",
      "1f482-1f3fc-200d-2640-fe0f",
      "1f482-1f3fd-200d-2640-fe0f",
      "1f482-1f3fe-200d-2640-fe0f",
      "1f482-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "construction worker",
      "construction_worker"
    ],
    u: "1f477",
    v: [
      "1f477-1f3fb",
      "1f477-1f3fc",
      "1f477-1f3fd",
      "1f477-1f3fe",
      "1f477-1f3ff"
    ]
  },
  {
    n: [
      "male-construction-worker"
    ],
    u: "1f477-200d-2642-fe0f",
    v: [
      "1f477-1f3fb-200d-2642-fe0f",
      "1f477-1f3fc-200d-2642-fe0f",
      "1f477-1f3fd-200d-2642-fe0f",
      "1f477-1f3fe-200d-2642-fe0f",
      "1f477-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-construction-worker"
    ],
    u: "1f477-200d-2640-fe0f",
    v: [
      "1f477-1f3fb-200d-2640-fe0f",
      "1f477-1f3fc-200d-2640-fe0f",
      "1f477-1f3fd-200d-2640-fe0f",
      "1f477-1f3fe-200d-2640-fe0f",
      "1f477-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "prince"
    ],
    u: "1f934",
    v: [
      "1f934-1f3fb",
      "1f934-1f3fc",
      "1f934-1f3fd",
      "1f934-1f3fe",
      "1f934-1f3ff"
    ]
  },
  {
    n: [
      "princess"
    ],
    u: "1f478",
    v: [
      "1f478-1f3fb",
      "1f478-1f3fc",
      "1f478-1f3fd",
      "1f478-1f3fe",
      "1f478-1f3ff"
    ]
  },
  {
    n: [
      "man with turban",
      "man_with_turban"
    ],
    u: "1f473",
    v: [
      "1f473-1f3fb",
      "1f473-1f3fc",
      "1f473-1f3fd",
      "1f473-1f3fe",
      "1f473-1f3ff"
    ]
  },
  {
    n: [
      "man-wearing-turban"
    ],
    u: "1f473-200d-2642-fe0f",
    v: [
      "1f473-1f3fb-200d-2642-fe0f",
      "1f473-1f3fc-200d-2642-fe0f",
      "1f473-1f3fd-200d-2642-fe0f",
      "1f473-1f3fe-200d-2642-fe0f",
      "1f473-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-wearing-turban"
    ],
    u: "1f473-200d-2640-fe0f",
    v: [
      "1f473-1f3fb-200d-2640-fe0f",
      "1f473-1f3fc-200d-2640-fe0f",
      "1f473-1f3fd-200d-2640-fe0f",
      "1f473-1f3fe-200d-2640-fe0f",
      "1f473-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man with gua pi mao",
      "man_with_gua_pi_mao"
    ],
    u: "1f472",
    v: [
      "1f472-1f3fb",
      "1f472-1f3fc",
      "1f472-1f3fd",
      "1f472-1f3fe",
      "1f472-1f3ff"
    ]
  },
  {
    n: [
      "person with headscarf",
      "person_with_headscarf"
    ],
    u: "1f9d5",
    v: [
      "1f9d5-1f3fb",
      "1f9d5-1f3fc",
      "1f9d5-1f3fd",
      "1f9d5-1f3fe",
      "1f9d5-1f3ff"
    ]
  },
  {
    n: [
      "bearded person",
      "bearded_person"
    ],
    u: "1f9d4",
    v: [
      "1f9d4-1f3fb",
      "1f9d4-1f3fc",
      "1f9d4-1f3fd",
      "1f9d4-1f3fe",
      "1f9d4-1f3ff"
    ]
  },
  {
    n: [
      "person with blond hair",
      "person_with_blond_hair"
    ],
    u: "1f471",
    v: [
      "1f471-1f3fb",
      "1f471-1f3fc",
      "1f471-1f3fd",
      "1f471-1f3fe",
      "1f471-1f3ff"
    ]
  },
  {
    n: [
      "blond-haired-man"
    ],
    u: "1f471-200d-2642-fe0f",
    v: [
      "1f471-1f3fb-200d-2642-fe0f",
      "1f471-1f3fc-200d-2642-fe0f",
      "1f471-1f3fd-200d-2642-fe0f",
      "1f471-1f3fe-200d-2642-fe0f",
      "1f471-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "blond-haired-woman"
    ],
    u: "1f471-200d-2640-fe0f",
    v: [
      "1f471-1f3fb-200d-2640-fe0f",
      "1f471-1f3fc-200d-2640-fe0f",
      "1f471-1f3fd-200d-2640-fe0f",
      "1f471-1f3fe-200d-2640-fe0f",
      "1f471-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man in tuxedo",
      "man_in_tuxedo"
    ],
    u: "1f935",
    v: [
      "1f935-1f3fb",
      "1f935-1f3fc",
      "1f935-1f3fd",
      "1f935-1f3fe",
      "1f935-1f3ff"
    ]
  },
  {
    n: [
      "bride with veil",
      "bride_with_veil"
    ],
    u: "1f470",
    v: [
      "1f470-1f3fb",
      "1f470-1f3fc",
      "1f470-1f3fd",
      "1f470-1f3fe",
      "1f470-1f3ff"
    ]
  },
  {
    n: [
      "pregnant woman",
      "pregnant_woman"
    ],
    u: "1f930",
    v: [
      "1f930-1f3fb",
      "1f930-1f3fc",
      "1f930-1f3fd",
      "1f930-1f3fe",
      "1f930-1f3ff"
    ]
  },
  {
    n: [
      "breast-feeding"
    ],
    u: "1f931",
    v: [
      "1f931-1f3fb",
      "1f931-1f3fc",
      "1f931-1f3fd",
      "1f931-1f3fe",
      "1f931-1f3ff"
    ]
  },
  {
    n: [
      "baby angel",
      "angel"
    ],
    u: "1f47c",
    v: [
      "1f47c-1f3fb",
      "1f47c-1f3fc",
      "1f47c-1f3fd",
      "1f47c-1f3fe",
      "1f47c-1f3ff"
    ]
  },
  {
    n: [
      "father christmas",
      "santa"
    ],
    u: "1f385",
    v: [
      "1f385-1f3fb",
      "1f385-1f3fc",
      "1f385-1f3fd",
      "1f385-1f3fe",
      "1f385-1f3ff"
    ]
  },
  {
    n: [
      "mother christmas",
      "mrs_claus",
      "mother_christmas"
    ],
    u: "1f936",
    v: [
      "1f936-1f3fb",
      "1f936-1f3fc",
      "1f936-1f3fd",
      "1f936-1f3fe",
      "1f936-1f3ff"
    ]
  },
  {
    n: [
      "mage"
    ],
    u: "1f9d9",
    v: [
      "1f9d9-1f3fb",
      "1f9d9-1f3fc",
      "1f9d9-1f3fd",
      "1f9d9-1f3fe",
      "1f9d9-1f3ff"
    ]
  },
  {
    n: [
      "female_mage"
    ],
    u: "1f9d9-200d-2640-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2640-fe0f",
      "1f9d9-1f3fc-200d-2640-fe0f",
      "1f9d9-1f3fd-200d-2640-fe0f",
      "1f9d9-1f3fe-200d-2640-fe0f",
      "1f9d9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_mage"
    ],
    u: "1f9d9-200d-2642-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2642-fe0f",
      "1f9d9-1f3fc-200d-2642-fe0f",
      "1f9d9-1f3fd-200d-2642-fe0f",
      "1f9d9-1f3fe-200d-2642-fe0f",
      "1f9d9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "fairy"
    ],
    u: "1f9da",
    v: [
      "1f9da-1f3fb",
      "1f9da-1f3fc",
      "1f9da-1f3fd",
      "1f9da-1f3fe",
      "1f9da-1f3ff"
    ]
  },
  {
    n: [
      "female_fairy"
    ],
    u: "1f9da-200d-2640-fe0f",
    v: [
      "1f9da-1f3fb-200d-2640-fe0f",
      "1f9da-1f3fc-200d-2640-fe0f",
      "1f9da-1f3fd-200d-2640-fe0f",
      "1f9da-1f3fe-200d-2640-fe0f",
      "1f9da-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_fairy"
    ],
    u: "1f9da-200d-2642-fe0f",
    v: [
      "1f9da-1f3fb-200d-2642-fe0f",
      "1f9da-1f3fc-200d-2642-fe0f",
      "1f9da-1f3fd-200d-2642-fe0f",
      "1f9da-1f3fe-200d-2642-fe0f",
      "1f9da-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "vampire"
    ],
    u: "1f9db",
    v: [
      "1f9db-1f3fb",
      "1f9db-1f3fc",
      "1f9db-1f3fd",
      "1f9db-1f3fe",
      "1f9db-1f3ff"
    ]
  },
  {
    n: [
      "female_vampire"
    ],
    u: "1f9db-200d-2640-fe0f",
    v: [
      "1f9db-1f3fb-200d-2640-fe0f",
      "1f9db-1f3fc-200d-2640-fe0f",
      "1f9db-1f3fd-200d-2640-fe0f",
      "1f9db-1f3fe-200d-2640-fe0f",
      "1f9db-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_vampire"
    ],
    u: "1f9db-200d-2642-fe0f",
    v: [
      "1f9db-1f3fb-200d-2642-fe0f",
      "1f9db-1f3fc-200d-2642-fe0f",
      "1f9db-1f3fd-200d-2642-fe0f",
      "1f9db-1f3fe-200d-2642-fe0f",
      "1f9db-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "merperson"
    ],
    u: "1f9dc",
    v: [
      "1f9dc-1f3fb",
      "1f9dc-1f3fc",
      "1f9dc-1f3fd",
      "1f9dc-1f3fe",
      "1f9dc-1f3ff"
    ]
  },
  {
    n: [
      "mermaid"
    ],
    u: "1f9dc-200d-2640-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2640-fe0f",
      "1f9dc-1f3fc-200d-2640-fe0f",
      "1f9dc-1f3fd-200d-2640-fe0f",
      "1f9dc-1f3fe-200d-2640-fe0f",
      "1f9dc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "merman"
    ],
    u: "1f9dc-200d-2642-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2642-fe0f",
      "1f9dc-1f3fc-200d-2642-fe0f",
      "1f9dc-1f3fd-200d-2642-fe0f",
      "1f9dc-1f3fe-200d-2642-fe0f",
      "1f9dc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "elf"
    ],
    u: "1f9dd",
    v: [
      "1f9dd-1f3fb",
      "1f9dd-1f3fc",
      "1f9dd-1f3fd",
      "1f9dd-1f3fe",
      "1f9dd-1f3ff"
    ]
  },
  {
    n: [
      "female_elf"
    ],
    u: "1f9dd-200d-2640-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2640-fe0f",
      "1f9dd-1f3fc-200d-2640-fe0f",
      "1f9dd-1f3fd-200d-2640-fe0f",
      "1f9dd-1f3fe-200d-2640-fe0f",
      "1f9dd-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_elf"
    ],
    u: "1f9dd-200d-2642-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2642-fe0f",
      "1f9dd-1f3fc-200d-2642-fe0f",
      "1f9dd-1f3fd-200d-2642-fe0f",
      "1f9dd-1f3fe-200d-2642-fe0f",
      "1f9dd-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "genie"
    ],
    u: "1f9de"
  },
  {
    n: [
      "female_genie"
    ],
    u: "1f9de-200d-2640-fe0f"
  },
  {
    n: [
      "male_genie"
    ],
    u: "1f9de-200d-2642-fe0f"
  },
  {
    n: [
      "zombie"
    ],
    u: "1f9df"
  },
  {
    n: [
      "female_zombie"
    ],
    u: "1f9df-200d-2640-fe0f"
  },
  {
    n: [
      "male_zombie"
    ],
    u: "1f9df-200d-2642-fe0f"
  },
  {
    n: [
      "person frowning",
      "person_frowning"
    ],
    u: "1f64d",
    v: [
      "1f64d-1f3fb",
      "1f64d-1f3fc",
      "1f64d-1f3fd",
      "1f64d-1f3fe",
      "1f64d-1f3ff"
    ]
  },
  {
    n: [
      "man-frowning"
    ],
    u: "1f64d-200d-2642-fe0f",
    v: [
      "1f64d-1f3fb-200d-2642-fe0f",
      "1f64d-1f3fc-200d-2642-fe0f",
      "1f64d-1f3fd-200d-2642-fe0f",
      "1f64d-1f3fe-200d-2642-fe0f",
      "1f64d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-frowning"
    ],
    u: "1f64d-200d-2640-fe0f",
    v: [
      "1f64d-1f3fb-200d-2640-fe0f",
      "1f64d-1f3fc-200d-2640-fe0f",
      "1f64d-1f3fd-200d-2640-fe0f",
      "1f64d-1f3fe-200d-2640-fe0f",
      "1f64d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person with pouting face",
      "person_with_pouting_face"
    ],
    u: "1f64e",
    v: [
      "1f64e-1f3fb",
      "1f64e-1f3fc",
      "1f64e-1f3fd",
      "1f64e-1f3fe",
      "1f64e-1f3ff"
    ]
  },
  {
    n: [
      "man-pouting"
    ],
    u: "1f64e-200d-2642-fe0f",
    v: [
      "1f64e-1f3fb-200d-2642-fe0f",
      "1f64e-1f3fc-200d-2642-fe0f",
      "1f64e-1f3fd-200d-2642-fe0f",
      "1f64e-1f3fe-200d-2642-fe0f",
      "1f64e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-pouting"
    ],
    u: "1f64e-200d-2640-fe0f",
    v: [
      "1f64e-1f3fb-200d-2640-fe0f",
      "1f64e-1f3fc-200d-2640-fe0f",
      "1f64e-1f3fd-200d-2640-fe0f",
      "1f64e-1f3fe-200d-2640-fe0f",
      "1f64e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with no good gesture",
      "no_good"
    ],
    u: "1f645",
    v: [
      "1f645-1f3fb",
      "1f645-1f3fc",
      "1f645-1f3fd",
      "1f645-1f3fe",
      "1f645-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-no"
    ],
    u: "1f645-200d-2642-fe0f",
    v: [
      "1f645-1f3fb-200d-2642-fe0f",
      "1f645-1f3fc-200d-2642-fe0f",
      "1f645-1f3fd-200d-2642-fe0f",
      "1f645-1f3fe-200d-2642-fe0f",
      "1f645-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-no"
    ],
    u: "1f645-200d-2640-fe0f",
    v: [
      "1f645-1f3fb-200d-2640-fe0f",
      "1f645-1f3fc-200d-2640-fe0f",
      "1f645-1f3fd-200d-2640-fe0f",
      "1f645-1f3fe-200d-2640-fe0f",
      "1f645-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with ok gesture",
      "ok_woman"
    ],
    u: "1f646",
    v: [
      "1f646-1f3fb",
      "1f646-1f3fc",
      "1f646-1f3fd",
      "1f646-1f3fe",
      "1f646-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-ok"
    ],
    u: "1f646-200d-2642-fe0f",
    v: [
      "1f646-1f3fb-200d-2642-fe0f",
      "1f646-1f3fc-200d-2642-fe0f",
      "1f646-1f3fd-200d-2642-fe0f",
      "1f646-1f3fe-200d-2642-fe0f",
      "1f646-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-ok"
    ],
    u: "1f646-200d-2640-fe0f",
    v: [
      "1f646-1f3fb-200d-2640-fe0f",
      "1f646-1f3fc-200d-2640-fe0f",
      "1f646-1f3fd-200d-2640-fe0f",
      "1f646-1f3fe-200d-2640-fe0f",
      "1f646-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "information desk person",
      "information_desk_person"
    ],
    u: "1f481",
    v: [
      "1f481-1f3fb",
      "1f481-1f3fc",
      "1f481-1f3fd",
      "1f481-1f3fe",
      "1f481-1f3ff"
    ]
  },
  {
    n: [
      "man-tipping-hand"
    ],
    u: "1f481-200d-2642-fe0f",
    v: [
      "1f481-1f3fb-200d-2642-fe0f",
      "1f481-1f3fc-200d-2642-fe0f",
      "1f481-1f3fd-200d-2642-fe0f",
      "1f481-1f3fe-200d-2642-fe0f",
      "1f481-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-tipping-hand"
    ],
    u: "1f481-200d-2640-fe0f",
    v: [
      "1f481-1f3fb-200d-2640-fe0f",
      "1f481-1f3fc-200d-2640-fe0f",
      "1f481-1f3fd-200d-2640-fe0f",
      "1f481-1f3fe-200d-2640-fe0f",
      "1f481-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "happy person raising one hand",
      "raising_hand"
    ],
    u: "1f64b",
    v: [
      "1f64b-1f3fb",
      "1f64b-1f3fc",
      "1f64b-1f3fd",
      "1f64b-1f3fe",
      "1f64b-1f3ff"
    ]
  },
  {
    n: [
      "man-raising-hand"
    ],
    u: "1f64b-200d-2642-fe0f",
    v: [
      "1f64b-1f3fb-200d-2642-fe0f",
      "1f64b-1f3fc-200d-2642-fe0f",
      "1f64b-1f3fd-200d-2642-fe0f",
      "1f64b-1f3fe-200d-2642-fe0f",
      "1f64b-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-raising-hand"
    ],
    u: "1f64b-200d-2640-fe0f",
    v: [
      "1f64b-1f3fb-200d-2640-fe0f",
      "1f64b-1f3fc-200d-2640-fe0f",
      "1f64b-1f3fd-200d-2640-fe0f",
      "1f64b-1f3fe-200d-2640-fe0f",
      "1f64b-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person bowing deeply",
      "bow"
    ],
    u: "1f647",
    v: [
      "1f647-1f3fb",
      "1f647-1f3fc",
      "1f647-1f3fd",
      "1f647-1f3fe",
      "1f647-1f3ff"
    ]
  },
  {
    n: [
      "man-bowing"
    ],
    u: "1f647-200d-2642-fe0f",
    v: [
      "1f647-1f3fb-200d-2642-fe0f",
      "1f647-1f3fc-200d-2642-fe0f",
      "1f647-1f3fd-200d-2642-fe0f",
      "1f647-1f3fe-200d-2642-fe0f",
      "1f647-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bowing"
    ],
    u: "1f647-200d-2640-fe0f",
    v: [
      "1f647-1f3fb-200d-2640-fe0f",
      "1f647-1f3fc-200d-2640-fe0f",
      "1f647-1f3fd-200d-2640-fe0f",
      "1f647-1f3fe-200d-2640-fe0f",
      "1f647-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face palm",
      "face_palm"
    ],
    u: "1f926",
    v: [
      "1f926-1f3fb",
      "1f926-1f3fc",
      "1f926-1f3fd",
      "1f926-1f3fe",
      "1f926-1f3ff"
    ]
  },
  {
    n: [
      "man-facepalming"
    ],
    u: "1f926-200d-2642-fe0f",
    v: [
      "1f926-1f3fb-200d-2642-fe0f",
      "1f926-1f3fc-200d-2642-fe0f",
      "1f926-1f3fd-200d-2642-fe0f",
      "1f926-1f3fe-200d-2642-fe0f",
      "1f926-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-facepalming"
    ],
    u: "1f926-200d-2640-fe0f",
    v: [
      "1f926-1f3fb-200d-2640-fe0f",
      "1f926-1f3fc-200d-2640-fe0f",
      "1f926-1f3fd-200d-2640-fe0f",
      "1f926-1f3fe-200d-2640-fe0f",
      "1f926-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "shrug"
    ],
    u: "1f937",
    v: [
      "1f937-1f3fb",
      "1f937-1f3fc",
      "1f937-1f3fd",
      "1f937-1f3fe",
      "1f937-1f3ff"
    ]
  },
  {
    n: [
      "man-shrugging"
    ],
    u: "1f937-200d-2642-fe0f",
    v: [
      "1f937-1f3fb-200d-2642-fe0f",
      "1f937-1f3fc-200d-2642-fe0f",
      "1f937-1f3fd-200d-2642-fe0f",
      "1f937-1f3fe-200d-2642-fe0f",
      "1f937-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-shrugging"
    ],
    u: "1f937-200d-2640-fe0f",
    v: [
      "1f937-1f3fb-200d-2640-fe0f",
      "1f937-1f3fc-200d-2640-fe0f",
      "1f937-1f3fd-200d-2640-fe0f",
      "1f937-1f3fe-200d-2640-fe0f",
      "1f937-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face massage",
      "massage"
    ],
    u: "1f486",
    v: [
      "1f486-1f3fb",
      "1f486-1f3fc",
      "1f486-1f3fd",
      "1f486-1f3fe",
      "1f486-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-massage"
    ],
    u: "1f486-200d-2642-fe0f",
    v: [
      "1f486-1f3fb-200d-2642-fe0f",
      "1f486-1f3fc-200d-2642-fe0f",
      "1f486-1f3fd-200d-2642-fe0f",
      "1f486-1f3fe-200d-2642-fe0f",
      "1f486-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-massage"
    ],
    u: "1f486-200d-2640-fe0f",
    v: [
      "1f486-1f3fb-200d-2640-fe0f",
      "1f486-1f3fc-200d-2640-fe0f",
      "1f486-1f3fd-200d-2640-fe0f",
      "1f486-1f3fe-200d-2640-fe0f",
      "1f486-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "haircut"
    ],
    u: "1f487",
    v: [
      "1f487-1f3fb",
      "1f487-1f3fc",
      "1f487-1f3fd",
      "1f487-1f3fe",
      "1f487-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-haircut"
    ],
    u: "1f487-200d-2642-fe0f",
    v: [
      "1f487-1f3fb-200d-2642-fe0f",
      "1f487-1f3fc-200d-2642-fe0f",
      "1f487-1f3fd-200d-2642-fe0f",
      "1f487-1f3fe-200d-2642-fe0f",
      "1f487-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-haircut"
    ],
    u: "1f487-200d-2640-fe0f",
    v: [
      "1f487-1f3fb-200d-2640-fe0f",
      "1f487-1f3fc-200d-2640-fe0f",
      "1f487-1f3fd-200d-2640-fe0f",
      "1f487-1f3fe-200d-2640-fe0f",
      "1f487-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "pedestrian",
      "walking"
    ],
    u: "1f6b6",
    v: [
      "1f6b6-1f3fb",
      "1f6b6-1f3fc",
      "1f6b6-1f3fd",
      "1f6b6-1f3fe",
      "1f6b6-1f3ff"
    ]
  },
  {
    n: [
      "man-walking"
    ],
    u: "1f6b6-200d-2642-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2642-fe0f",
      "1f6b6-1f3fc-200d-2642-fe0f",
      "1f6b6-1f3fd-200d-2642-fe0f",
      "1f6b6-1f3fe-200d-2642-fe0f",
      "1f6b6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-walking"
    ],
    u: "1f6b6-200d-2640-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2640-fe0f",
      "1f6b6-1f3fc-200d-2640-fe0f",
      "1f6b6-1f3fd-200d-2640-fe0f",
      "1f6b6-1f3fe-200d-2640-fe0f",
      "1f6b6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "runner",
      "running"
    ],
    u: "1f3c3",
    v: [
      "1f3c3-1f3fb",
      "1f3c3-1f3fc",
      "1f3c3-1f3fd",
      "1f3c3-1f3fe",
      "1f3c3-1f3ff"
    ]
  },
  {
    n: [
      "man-running"
    ],
    u: "1f3c3-200d-2642-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2642-fe0f",
      "1f3c3-1f3fc-200d-2642-fe0f",
      "1f3c3-1f3fd-200d-2642-fe0f",
      "1f3c3-1f3fe-200d-2642-fe0f",
      "1f3c3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-running"
    ],
    u: "1f3c3-200d-2640-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2640-fe0f",
      "1f3c3-1f3fc-200d-2640-fe0f",
      "1f3c3-1f3fd-200d-2640-fe0f",
      "1f3c3-1f3fe-200d-2640-fe0f",
      "1f3c3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "dancer"
    ],
    u: "1f483",
    v: [
      "1f483-1f3fb",
      "1f483-1f3fc",
      "1f483-1f3fd",
      "1f483-1f3fe",
      "1f483-1f3ff"
    ]
  },
  {
    n: [
      "man dancing",
      "man_dancing"
    ],
    u: "1f57a",
    v: [
      "1f57a-1f3fb",
      "1f57a-1f3fc",
      "1f57a-1f3fd",
      "1f57a-1f3fe",
      "1f57a-1f3ff"
    ]
  },
  {
    n: [
      "woman with bunny ears",
      "dancers"
    ],
    u: "1f46f"
  },
  {
    n: [
      "man-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2642-fe0f"
  },
  {
    n: [
      "woman-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2640-fe0f"
  },
  {
    n: [
      "person in steamy room",
      "person_in_steamy_room"
    ],
    u: "1f9d6",
    v: [
      "1f9d6-1f3fb",
      "1f9d6-1f3fc",
      "1f9d6-1f3fd",
      "1f9d6-1f3fe",
      "1f9d6-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_steamy_room"
    ],
    u: "1f9d6-200d-2640-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2640-fe0f",
      "1f9d6-1f3fc-200d-2640-fe0f",
      "1f9d6-1f3fd-200d-2640-fe0f",
      "1f9d6-1f3fe-200d-2640-fe0f",
      "1f9d6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_steamy_room"
    ],
    u: "1f9d6-200d-2642-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2642-fe0f",
      "1f9d6-1f3fc-200d-2642-fe0f",
      "1f9d6-1f3fd-200d-2642-fe0f",
      "1f9d6-1f3fe-200d-2642-fe0f",
      "1f9d6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person climbing",
      "person_climbing"
    ],
    u: "1f9d7",
    v: [
      "1f9d7-1f3fb",
      "1f9d7-1f3fc",
      "1f9d7-1f3fd",
      "1f9d7-1f3fe",
      "1f9d7-1f3ff"
    ]
  },
  {
    n: [
      "woman_climbing"
    ],
    u: "1f9d7-200d-2640-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2640-fe0f",
      "1f9d7-1f3fc-200d-2640-fe0f",
      "1f9d7-1f3fd-200d-2640-fe0f",
      "1f9d7-1f3fe-200d-2640-fe0f",
      "1f9d7-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_climbing"
    ],
    u: "1f9d7-200d-2642-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2642-fe0f",
      "1f9d7-1f3fc-200d-2642-fe0f",
      "1f9d7-1f3fd-200d-2642-fe0f",
      "1f9d7-1f3fe-200d-2642-fe0f",
      "1f9d7-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person in lotus position",
      "person_in_lotus_position"
    ],
    u: "1f9d8",
    v: [
      "1f9d8-1f3fb",
      "1f9d8-1f3fc",
      "1f9d8-1f3fd",
      "1f9d8-1f3fe",
      "1f9d8-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_lotus_position"
    ],
    u: "1f9d8-200d-2640-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2640-fe0f",
      "1f9d8-1f3fc-200d-2640-fe0f",
      "1f9d8-1f3fd-200d-2640-fe0f",
      "1f9d8-1f3fe-200d-2640-fe0f",
      "1f9d8-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_lotus_position"
    ],
    u: "1f9d8-200d-2642-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2642-fe0f",
      "1f9d8-1f3fc-200d-2642-fe0f",
      "1f9d8-1f3fd-200d-2642-fe0f",
      "1f9d8-1f3fe-200d-2642-fe0f",
      "1f9d8-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "bath"
    ],
    u: "1f6c0",
    v: [
      "1f6c0-1f3fb",
      "1f6c0-1f3fc",
      "1f6c0-1f3fd",
      "1f6c0-1f3fe",
      "1f6c0-1f3ff"
    ]
  },
  {
    n: [
      "sleeping accommodation",
      "sleeping_accommodation"
    ],
    u: "1f6cc",
    v: [
      "1f6cc-1f3fb",
      "1f6cc-1f3fc",
      "1f6cc-1f3fd",
      "1f6cc-1f3fe",
      "1f6cc-1f3ff"
    ]
  },
  {
    n: [
      "man_in_business_suit_levitating"
    ],
    u: "1f574-fe0f",
    v: [
      "1f574-1f3fb",
      "1f574-1f3fc",
      "1f574-1f3fd",
      "1f574-1f3fe",
      "1f574-1f3ff"
    ]
  },
  {
    n: [
      "speaking_head_in_silhouette"
    ],
    u: "1f5e3-fe0f"
  },
  {
    n: [
      "bust in silhouette",
      "bust_in_silhouette"
    ],
    u: "1f464"
  },
  {
    n: [
      "busts in silhouette",
      "busts_in_silhouette"
    ],
    u: "1f465"
  },
  {
    n: [
      "fencer"
    ],
    u: "1f93a"
  },
  {
    n: [
      "horse racing",
      "horse_racing"
    ],
    u: "1f3c7",
    v: [
      "1f3c7-1f3fb",
      "1f3c7-1f3fc",
      "1f3c7-1f3fd",
      "1f3c7-1f3fe",
      "1f3c7-1f3ff"
    ]
  },
  {
    n: [
      "skier"
    ],
    u: "26f7-fe0f"
  },
  {
    n: [
      "snowboarder"
    ],
    u: "1f3c2",
    v: [
      "1f3c2-1f3fb",
      "1f3c2-1f3fc",
      "1f3c2-1f3fd",
      "1f3c2-1f3fe",
      "1f3c2-1f3ff"
    ]
  },
  {
    n: [
      "golfer"
    ],
    u: "1f3cc-fe0f",
    v: [
      "1f3cc-1f3fb",
      "1f3cc-1f3fc",
      "1f3cc-1f3fd",
      "1f3cc-1f3fe",
      "1f3cc-1f3ff"
    ]
  },
  {
    n: [
      "man-golfing"
    ],
    u: "1f3cc-fe0f-200d-2642-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2642-fe0f",
      "1f3cc-1f3fc-200d-2642-fe0f",
      "1f3cc-1f3fd-200d-2642-fe0f",
      "1f3cc-1f3fe-200d-2642-fe0f",
      "1f3cc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-golfing"
    ],
    u: "1f3cc-fe0f-200d-2640-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2640-fe0f",
      "1f3cc-1f3fc-200d-2640-fe0f",
      "1f3cc-1f3fd-200d-2640-fe0f",
      "1f3cc-1f3fe-200d-2640-fe0f",
      "1f3cc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "surfer"
    ],
    u: "1f3c4",
    v: [
      "1f3c4-1f3fb",
      "1f3c4-1f3fc",
      "1f3c4-1f3fd",
      "1f3c4-1f3fe",
      "1f3c4-1f3ff"
    ]
  },
  {
    n: [
      "man-surfing"
    ],
    u: "1f3c4-200d-2642-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2642-fe0f",
      "1f3c4-1f3fc-200d-2642-fe0f",
      "1f3c4-1f3fd-200d-2642-fe0f",
      "1f3c4-1f3fe-200d-2642-fe0f",
      "1f3c4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-surfing"
    ],
    u: "1f3c4-200d-2640-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2640-fe0f",
      "1f3c4-1f3fc-200d-2640-fe0f",
      "1f3c4-1f3fd-200d-2640-fe0f",
      "1f3c4-1f3fe-200d-2640-fe0f",
      "1f3c4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "rowboat"
    ],
    u: "1f6a3",
    v: [
      "1f6a3-1f3fb",
      "1f6a3-1f3fc",
      "1f6a3-1f3fd",
      "1f6a3-1f3fe",
      "1f6a3-1f3ff"
    ]
  },
  {
    n: [
      "man-rowing-boat"
    ],
    u: "1f6a3-200d-2642-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2642-fe0f",
      "1f6a3-1f3fc-200d-2642-fe0f",
      "1f6a3-1f3fd-200d-2642-fe0f",
      "1f6a3-1f3fe-200d-2642-fe0f",
      "1f6a3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-rowing-boat"
    ],
    u: "1f6a3-200d-2640-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2640-fe0f",
      "1f6a3-1f3fc-200d-2640-fe0f",
      "1f6a3-1f3fd-200d-2640-fe0f",
      "1f6a3-1f3fe-200d-2640-fe0f",
      "1f6a3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "swimmer"
    ],
    u: "1f3ca",
    v: [
      "1f3ca-1f3fb",
      "1f3ca-1f3fc",
      "1f3ca-1f3fd",
      "1f3ca-1f3fe",
      "1f3ca-1f3ff"
    ]
  },
  {
    n: [
      "man-swimming"
    ],
    u: "1f3ca-200d-2642-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2642-fe0f",
      "1f3ca-1f3fc-200d-2642-fe0f",
      "1f3ca-1f3fd-200d-2642-fe0f",
      "1f3ca-1f3fe-200d-2642-fe0f",
      "1f3ca-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-swimming"
    ],
    u: "1f3ca-200d-2640-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2640-fe0f",
      "1f3ca-1f3fc-200d-2640-fe0f",
      "1f3ca-1f3fd-200d-2640-fe0f",
      "1f3ca-1f3fe-200d-2640-fe0f",
      "1f3ca-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person_with_ball"
    ],
    u: "26f9-fe0f",
    v: [
      "26f9-1f3fb",
      "26f9-1f3fc",
      "26f9-1f3fd",
      "26f9-1f3fe",
      "26f9-1f3ff"
    ]
  },
  {
    n: [
      "man-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2642-fe0f",
    v: [
      "26f9-1f3fb-200d-2642-fe0f",
      "26f9-1f3fc-200d-2642-fe0f",
      "26f9-1f3fd-200d-2642-fe0f",
      "26f9-1f3fe-200d-2642-fe0f",
      "26f9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2640-fe0f",
    v: [
      "26f9-1f3fb-200d-2640-fe0f",
      "26f9-1f3fc-200d-2640-fe0f",
      "26f9-1f3fd-200d-2640-fe0f",
      "26f9-1f3fe-200d-2640-fe0f",
      "26f9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "weight_lifter"
    ],
    u: "1f3cb-fe0f",
    v: [
      "1f3cb-1f3fb",
      "1f3cb-1f3fc",
      "1f3cb-1f3fd",
      "1f3cb-1f3fe",
      "1f3cb-1f3ff"
    ]
  },
  {
    n: [
      "man-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2642-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2642-fe0f",
      "1f3cb-1f3fc-200d-2642-fe0f",
      "1f3cb-1f3fd-200d-2642-fe0f",
      "1f3cb-1f3fe-200d-2642-fe0f",
      "1f3cb-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2640-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2640-fe0f",
      "1f3cb-1f3fc-200d-2640-fe0f",
      "1f3cb-1f3fd-200d-2640-fe0f",
      "1f3cb-1f3fe-200d-2640-fe0f",
      "1f3cb-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "bicyclist"
    ],
    u: "1f6b4",
    v: [
      "1f6b4-1f3fb",
      "1f6b4-1f3fc",
      "1f6b4-1f3fd",
      "1f6b4-1f3fe",
      "1f6b4-1f3ff"
    ]
  },
  {
    n: [
      "man-biking"
    ],
    u: "1f6b4-200d-2642-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2642-fe0f",
      "1f6b4-1f3fc-200d-2642-fe0f",
      "1f6b4-1f3fd-200d-2642-fe0f",
      "1f6b4-1f3fe-200d-2642-fe0f",
      "1f6b4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-biking"
    ],
    u: "1f6b4-200d-2640-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2640-fe0f",
      "1f6b4-1f3fc-200d-2640-fe0f",
      "1f6b4-1f3fd-200d-2640-fe0f",
      "1f6b4-1f3fe-200d-2640-fe0f",
      "1f6b4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "mountain bicyclist",
      "mountain_bicyclist"
    ],
    u: "1f6b5",
    v: [
      "1f6b5-1f3fb",
      "1f6b5-1f3fc",
      "1f6b5-1f3fd",
      "1f6b5-1f3fe",
      "1f6b5-1f3ff"
    ]
  },
  {
    n: [
      "man-mountain-biking"
    ],
    u: "1f6b5-200d-2642-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2642-fe0f",
      "1f6b5-1f3fc-200d-2642-fe0f",
      "1f6b5-1f3fd-200d-2642-fe0f",
      "1f6b5-1f3fe-200d-2642-fe0f",
      "1f6b5-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-mountain-biking"
    ],
    u: "1f6b5-200d-2640-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2640-fe0f",
      "1f6b5-1f3fc-200d-2640-fe0f",
      "1f6b5-1f3fd-200d-2640-fe0f",
      "1f6b5-1f3fe-200d-2640-fe0f",
      "1f6b5-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "racing_car"
    ],
    u: "1f3ce-fe0f"
  },
  {
    n: [
      "racing_motorcycle"
    ],
    u: "1f3cd-fe0f"
  },
  {
    n: [
      "person doing cartwheel",
      "person_doing_cartwheel"
    ],
    u: "1f938",
    v: [
      "1f938-1f3fb",
      "1f938-1f3fc",
      "1f938-1f3fd",
      "1f938-1f3fe",
      "1f938-1f3ff"
    ]
  },
  {
    n: [
      "man-cartwheeling"
    ],
    u: "1f938-200d-2642-fe0f",
    v: [
      "1f938-1f3fb-200d-2642-fe0f",
      "1f938-1f3fc-200d-2642-fe0f",
      "1f938-1f3fd-200d-2642-fe0f",
      "1f938-1f3fe-200d-2642-fe0f",
      "1f938-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-cartwheeling"
    ],
    u: "1f938-200d-2640-fe0f",
    v: [
      "1f938-1f3fb-200d-2640-fe0f",
      "1f938-1f3fc-200d-2640-fe0f",
      "1f938-1f3fd-200d-2640-fe0f",
      "1f938-1f3fe-200d-2640-fe0f",
      "1f938-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "wrestlers"
    ],
    u: "1f93c"
  },
  {
    n: [
      "man-wrestling"
    ],
    u: "1f93c-200d-2642-fe0f"
  },
  {
    n: [
      "woman-wrestling"
    ],
    u: "1f93c-200d-2640-fe0f"
  },
  {
    n: [
      "water polo",
      "water_polo"
    ],
    u: "1f93d",
    v: [
      "1f93d-1f3fb",
      "1f93d-1f3fc",
      "1f93d-1f3fd",
      "1f93d-1f3fe",
      "1f93d-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-water-polo"
    ],
    u: "1f93d-200d-2642-fe0f",
    v: [
      "1f93d-1f3fb-200d-2642-fe0f",
      "1f93d-1f3fc-200d-2642-fe0f",
      "1f93d-1f3fd-200d-2642-fe0f",
      "1f93d-1f3fe-200d-2642-fe0f",
      "1f93d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-water-polo"
    ],
    u: "1f93d-200d-2640-fe0f",
    v: [
      "1f93d-1f3fb-200d-2640-fe0f",
      "1f93d-1f3fc-200d-2640-fe0f",
      "1f93d-1f3fd-200d-2640-fe0f",
      "1f93d-1f3fe-200d-2640-fe0f",
      "1f93d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "handball"
    ],
    u: "1f93e",
    v: [
      "1f93e-1f3fb",
      "1f93e-1f3fc",
      "1f93e-1f3fd",
      "1f93e-1f3fe",
      "1f93e-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-handball"
    ],
    u: "1f93e-200d-2642-fe0f",
    v: [
      "1f93e-1f3fb-200d-2642-fe0f",
      "1f93e-1f3fc-200d-2642-fe0f",
      "1f93e-1f3fd-200d-2642-fe0f",
      "1f93e-1f3fe-200d-2642-fe0f",
      "1f93e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-handball"
    ],
    u: "1f93e-200d-2640-fe0f",
    v: [
      "1f93e-1f3fb-200d-2640-fe0f",
      "1f93e-1f3fc-200d-2640-fe0f",
      "1f93e-1f3fd-200d-2640-fe0f",
      "1f93e-1f3fe-200d-2640-fe0f",
      "1f93e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "juggling"
    ],
    u: "1f939",
    v: [
      "1f939-1f3fb",
      "1f939-1f3fc",
      "1f939-1f3fd",
      "1f939-1f3fe",
      "1f939-1f3ff"
    ]
  },
  {
    n: [
      "man-juggling"
    ],
    u: "1f939-200d-2642-fe0f",
    v: [
      "1f939-1f3fb-200d-2642-fe0f",
      "1f939-1f3fc-200d-2642-fe0f",
      "1f939-1f3fd-200d-2642-fe0f",
      "1f939-1f3fe-200d-2642-fe0f",
      "1f939-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-juggling"
    ],
    u: "1f939-200d-2640-fe0f",
    v: [
      "1f939-1f3fb-200d-2640-fe0f",
      "1f939-1f3fc-200d-2640-fe0f",
      "1f939-1f3fd-200d-2640-fe0f",
      "1f939-1f3fe-200d-2640-fe0f",
      "1f939-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man and woman holding hands",
      "couple",
      "man_and_woman_holding_hands"
    ],
    u: "1f46b"
  },
  {
    n: [
      "two men holding hands",
      "two_men_holding_hands"
    ],
    u: "1f46c"
  },
  {
    n: [
      "two women holding hands",
      "two_women_holding_hands"
    ],
    u: "1f46d"
  },
  {
    n: [
      "kiss",
      "couplekiss"
    ],
    u: "1f48f"
  },
  {
    n: [
      "woman-kiss-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "man-kiss-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "woman-kiss-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469"
  },
  {
    n: [
      "couple with heart",
      "couple_with_heart"
    ],
    u: "1f491"
  },
  {
    n: [
      "woman-heart-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "man-heart-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "woman-heart-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f469"
  },
  {
    n: [
      "family",
      "man-woman-boy"
    ],
    u: "1f46a"
  },
  {
    n: [
      "man-woman-boy",
      "family"
    ],
    u: "1f468-200d-1f469-200d-1f466"
  },
  {
    n: [
      "man-woman-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467"
  },
  {
    n: [
      "man-woman-girl-boy"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-woman-boy-boy"
    ],
    u: "1f468-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-woman-girl-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-man-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466"
  },
  {
    n: [
      "man-man-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467"
  },
  {
    n: [
      "man-man-girl-boy"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-man-boy-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-man-girl-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-woman-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467"
  },
  {
    n: [
      "woman-woman-girl-boy"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-woman-boy-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-boy"
    ],
    u: "1f468-200d-1f466"
  },
  {
    n: [
      "man-boy-boy"
    ],
    u: "1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-girl"
    ],
    u: "1f468-200d-1f467"
  },
  {
    n: [
      "man-girl-boy"
    ],
    u: "1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-girl-girl"
    ],
    u: "1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-boy"
    ],
    u: "1f469-200d-1f466"
  },
  {
    n: [
      "woman-boy-boy"
    ],
    u: "1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-girl"
    ],
    u: "1f469-200d-1f467"
  },
  {
    n: [
      "woman-girl-boy"
    ],
    u: "1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-girl-girl"
    ],
    u: "1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "selfie"
    ],
    u: "1f933",
    v: [
      "1f933-1f3fb",
      "1f933-1f3fc",
      "1f933-1f3fd",
      "1f933-1f3fe",
      "1f933-1f3ff"
    ]
  },
  {
    n: [
      "flexed biceps",
      "muscle"
    ],
    u: "1f4aa",
    v: [
      "1f4aa-1f3fb",
      "1f4aa-1f3fc",
      "1f4aa-1f3fd",
      "1f4aa-1f3fe",
      "1f4aa-1f3ff"
    ]
  },
  {
    n: [
      "white left pointing backhand index",
      "point_left"
    ],
    u: "1f448",
    v: [
      "1f448-1f3fb",
      "1f448-1f3fc",
      "1f448-1f3fd",
      "1f448-1f3fe",
      "1f448-1f3ff"
    ]
  },
  {
    n: [
      "white right pointing backhand index",
      "point_right"
    ],
    u: "1f449",
    v: [
      "1f449-1f3fb",
      "1f449-1f3fc",
      "1f449-1f3fd",
      "1f449-1f3fe",
      "1f449-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing index",
      "point_up"
    ],
    u: "261d-fe0f",
    v: [
      "261d-1f3fb",
      "261d-1f3fc",
      "261d-1f3fd",
      "261d-1f3fe",
      "261d-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing backhand index",
      "point_up_2"
    ],
    u: "1f446",
    v: [
      "1f446-1f3fb",
      "1f446-1f3fc",
      "1f446-1f3fd",
      "1f446-1f3fe",
      "1f446-1f3ff"
    ]
  },
  {
    n: [
      "reversed hand with middle finger extended",
      "middle_finger",
      "reversed_hand_with_middle_finger_extended"
    ],
    u: "1f595",
    v: [
      "1f595-1f3fb",
      "1f595-1f3fc",
      "1f595-1f3fd",
      "1f595-1f3fe",
      "1f595-1f3ff"
    ]
  },
  {
    n: [
      "white down pointing backhand index",
      "point_down"
    ],
    u: "1f447",
    v: [
      "1f447-1f3fb",
      "1f447-1f3fc",
      "1f447-1f3fd",
      "1f447-1f3fe",
      "1f447-1f3ff"
    ]
  },
  {
    n: [
      "victory hand",
      "v"
    ],
    u: "270c-fe0f",
    v: [
      "270c-1f3fb",
      "270c-1f3fc",
      "270c-1f3fd",
      "270c-1f3fe",
      "270c-1f3ff"
    ]
  },
  {
    n: [
      "hand with index and middle fingers crossed",
      "crossed_fingers",
      "hand_with_index_and_middle_fingers_crossed"
    ],
    u: "1f91e",
    v: [
      "1f91e-1f3fb",
      "1f91e-1f3fc",
      "1f91e-1f3fd",
      "1f91e-1f3fe",
      "1f91e-1f3ff"
    ]
  },
  {
    n: [
      "raised hand with part between middle and ring fingers",
      "spock-hand"
    ],
    u: "1f596",
    v: [
      "1f596-1f3fb",
      "1f596-1f3fc",
      "1f596-1f3fd",
      "1f596-1f3fe",
      "1f596-1f3ff"
    ]
  },
  {
    n: [
      "sign of the horns",
      "the_horns",
      "sign_of_the_horns"
    ],
    u: "1f918",
    v: [
      "1f918-1f3fb",
      "1f918-1f3fc",
      "1f918-1f3fd",
      "1f918-1f3fe",
      "1f918-1f3ff"
    ]
  },
  {
    n: [
      "call me hand",
      "call_me_hand"
    ],
    u: "1f919",
    v: [
      "1f919-1f3fb",
      "1f919-1f3fc",
      "1f919-1f3fd",
      "1f919-1f3fe",
      "1f919-1f3ff"
    ]
  },
  {
    n: [
      "raised_hand_with_fingers_splayed"
    ],
    u: "1f590-fe0f",
    v: [
      "1f590-1f3fb",
      "1f590-1f3fc",
      "1f590-1f3fd",
      "1f590-1f3fe",
      "1f590-1f3ff"
    ]
  },
  {
    n: [
      "raised hand",
      "hand",
      "raised_hand"
    ],
    u: "270b",
    v: [
      "270b-1f3fb",
      "270b-1f3fc",
      "270b-1f3fd",
      "270b-1f3fe",
      "270b-1f3ff"
    ]
  },
  {
    n: [
      "ok hand sign",
      "ok_hand"
    ],
    u: "1f44c",
    v: [
      "1f44c-1f3fb",
      "1f44c-1f3fc",
      "1f44c-1f3fd",
      "1f44c-1f3fe",
      "1f44c-1f3ff"
    ]
  },
  {
    n: [
      "thumbs up sign",
      "+1",
      "thumbsup"
    ],
    u: "1f44d",
    v: [
      "1f44d-1f3fb",
      "1f44d-1f3fc",
      "1f44d-1f3fd",
      "1f44d-1f3fe",
      "1f44d-1f3ff"
    ]
  },
  {
    n: [
      "thumbs down sign",
      "-1",
      "thumbsdown"
    ],
    u: "1f44e",
    v: [
      "1f44e-1f3fb",
      "1f44e-1f3fc",
      "1f44e-1f3fd",
      "1f44e-1f3fe",
      "1f44e-1f3ff"
    ]
  },
  {
    n: [
      "raised fist",
      "fist"
    ],
    u: "270a",
    v: [
      "270a-1f3fb",
      "270a-1f3fc",
      "270a-1f3fd",
      "270a-1f3fe",
      "270a-1f3ff"
    ]
  },
  {
    n: [
      "fisted hand sign",
      "facepunch",
      "punch"
    ],
    u: "1f44a",
    v: [
      "1f44a-1f3fb",
      "1f44a-1f3fc",
      "1f44a-1f3fd",
      "1f44a-1f3fe",
      "1f44a-1f3ff"
    ]
  },
  {
    n: [
      "left-facing fist",
      "left-facing_fist"
    ],
    u: "1f91b",
    v: [
      "1f91b-1f3fb",
      "1f91b-1f3fc",
      "1f91b-1f3fd",
      "1f91b-1f3fe",
      "1f91b-1f3ff"
    ]
  },
  {
    n: [
      "right-facing fist",
      "right-facing_fist"
    ],
    u: "1f91c",
    v: [
      "1f91c-1f3fb",
      "1f91c-1f3fc",
      "1f91c-1f3fd",
      "1f91c-1f3fe",
      "1f91c-1f3ff"
    ]
  },
  {
    n: [
      "raised back of hand",
      "raised_back_of_hand"
    ],
    u: "1f91a",
    v: [
      "1f91a-1f3fb",
      "1f91a-1f3fc",
      "1f91a-1f3fd",
      "1f91a-1f3fe",
      "1f91a-1f3ff"
    ]
  },
  {
    n: [
      "waving hand sign",
      "wave"
    ],
    u: "1f44b",
    v: [
      "1f44b-1f3fb",
      "1f44b-1f3fc",
      "1f44b-1f3fd",
      "1f44b-1f3fe",
      "1f44b-1f3ff"
    ]
  },
  {
    n: [
      "i love you hand sign",
      "i_love_you_hand_sign"
    ],
    u: "1f91f",
    v: [
      "1f91f-1f3fb",
      "1f91f-1f3fc",
      "1f91f-1f3fd",
      "1f91f-1f3fe",
      "1f91f-1f3ff"
    ]
  },
  {
    n: [
      "writing_hand"
    ],
    u: "270d-fe0f",
    v: [
      "270d-1f3fb",
      "270d-1f3fc",
      "270d-1f3fd",
      "270d-1f3fe",
      "270d-1f3ff"
    ]
  },
  {
    n: [
      "clapping hands sign",
      "clap"
    ],
    u: "1f44f",
    v: [
      "1f44f-1f3fb",
      "1f44f-1f3fc",
      "1f44f-1f3fd",
      "1f44f-1f3fe",
      "1f44f-1f3ff"
    ]
  },
  {
    n: [
      "open hands sign",
      "open_hands"
    ],
    u: "1f450",
    v: [
      "1f450-1f3fb",
      "1f450-1f3fc",
      "1f450-1f3fd",
      "1f450-1f3fe",
      "1f450-1f3ff"
    ]
  },
  {
    n: [
      "person raising both hands in celebration",
      "raised_hands"
    ],
    u: "1f64c",
    v: [
      "1f64c-1f3fb",
      "1f64c-1f3fc",
      "1f64c-1f3fd",
      "1f64c-1f3fe",
      "1f64c-1f3ff"
    ]
  },
  {
    n: [
      "palms up together",
      "palms_up_together"
    ],
    u: "1f932",
    v: [
      "1f932-1f3fb",
      "1f932-1f3fc",
      "1f932-1f3fd",
      "1f932-1f3fe",
      "1f932-1f3ff"
    ]
  },
  {
    n: [
      "person with folded hands",
      "pray"
    ],
    u: "1f64f",
    v: [
      "1f64f-1f3fb",
      "1f64f-1f3fc",
      "1f64f-1f3fd",
      "1f64f-1f3fe",
      "1f64f-1f3ff"
    ]
  },
  {
    n: [
      "handshake"
    ],
    u: "1f91d"
  },
  {
    n: [
      "nail polish",
      "nail_care"
    ],
    u: "1f485",
    v: [
      "1f485-1f3fb",
      "1f485-1f3fc",
      "1f485-1f3fd",
      "1f485-1f3fe",
      "1f485-1f3ff"
    ]
  },
  {
    n: [
      "ear"
    ],
    u: "1f442",
    v: [
      "1f442-1f3fb",
      "1f442-1f3fc",
      "1f442-1f3fd",
      "1f442-1f3fe",
      "1f442-1f3ff"
    ]
  },
  {
    n: [
      "nose"
    ],
    u: "1f443",
    v: [
      "1f443-1f3fb",
      "1f443-1f3fc",
      "1f443-1f3fd",
      "1f443-1f3fe",
      "1f443-1f3ff"
    ]
  },
  {
    n: [
      "footprints"
    ],
    u: "1f463"
  },
  {
    n: [
      "eyes"
    ],
    u: "1f440"
  },
  {
    n: [
      "eye"
    ],
    u: "1f441-fe0f"
  },
  {
    n: [
      "eye-in-speech-bubble"
    ],
    u: "1f441-fe0f-200d-1f5e8-fe0f"
  },
  {
    n: [
      "brain"
    ],
    u: "1f9e0"
  },
  {
    n: [
      "tongue"
    ],
    u: "1f445"
  },
  {
    n: [
      "mouth",
      "lips"
    ],
    u: "1f444"
  },
  {
    n: [
      "kiss mark",
      "kiss"
    ],
    u: "1f48b"
  },
  {
    n: [
      "heart with arrow",
      "cupid"
    ],
    u: "1f498"
  },
  {
    n: [
      "heavy black heart",
      "heart"
    ],
    u: "2764-fe0f"
  },
  {
    n: [
      "beating heart",
      "heartbeat"
    ],
    u: "1f493"
  },
  {
    n: [
      "broken heart",
      "broken_heart"
    ],
    u: "1f494"
  },
  {
    n: [
      "two hearts",
      "two_hearts"
    ],
    u: "1f495"
  },
  {
    n: [
      "sparkling heart",
      "sparkling_heart"
    ],
    u: "1f496"
  },
  {
    n: [
      "growing heart",
      "heartpulse"
    ],
    u: "1f497"
  },
  {
    n: [
      "blue heart",
      "blue_heart"
    ],
    u: "1f499"
  },
  {
    n: [
      "green heart",
      "green_heart"
    ],
    u: "1f49a"
  },
  {
    n: [
      "yellow heart",
      "yellow_heart"
    ],
    u: "1f49b"
  },
  {
    n: [
      "orange heart",
      "orange_heart"
    ],
    u: "1f9e1"
  },
  {
    n: [
      "purple heart",
      "purple_heart"
    ],
    u: "1f49c"
  },
  {
    n: [
      "black heart",
      "black_heart"
    ],
    u: "1f5a4"
  },
  {
    n: [
      "heart with ribbon",
      "gift_heart"
    ],
    u: "1f49d"
  },
  {
    n: [
      "revolving hearts",
      "revolving_hearts"
    ],
    u: "1f49e"
  },
  {
    n: [
      "heart decoration",
      "heart_decoration"
    ],
    u: "1f49f"
  },
  {
    n: [
      "heavy_heart_exclamation_mark_ornament"
    ],
    u: "2763-fe0f"
  },
  {
    n: [
      "love letter",
      "love_letter"
    ],
    u: "1f48c"
  },
  {
    n: [
      "sleeping symbol",
      "zzz"
    ],
    u: "1f4a4"
  },
  {
    n: [
      "anger symbol",
      "anger"
    ],
    u: "1f4a2"
  },
  {
    n: [
      "bomb"
    ],
    u: "1f4a3"
  },
  {
    n: [
      "collision symbol",
      "boom",
      "collision"
    ],
    u: "1f4a5"
  },
  {
    n: [
      "splashing sweat symbol",
      "sweat_drops"
    ],
    u: "1f4a6"
  },
  {
    n: [
      "dash symbol",
      "dash"
    ],
    u: "1f4a8"
  },
  {
    n: [
      "dizzy symbol",
      "dizzy"
    ],
    u: "1f4ab"
  },
  {
    n: [
      "speech balloon",
      "speech_balloon"
    ],
    u: "1f4ac"
  },
  {
    n: [
      "left_speech_bubble"
    ],
    u: "1f5e8-fe0f"
  },
  {
    n: [
      "right_anger_bubble"
    ],
    u: "1f5ef-fe0f"
  },
  {
    n: [
      "thought balloon",
      "thought_balloon"
    ],
    u: "1f4ad"
  },
  {
    n: [
      "hole"
    ],
    u: "1f573-fe0f"
  },
  {
    n: [
      "eyeglasses"
    ],
    u: "1f453"
  },
  {
    n: [
      "dark_sunglasses"
    ],
    u: "1f576-fe0f"
  },
  {
    n: [
      "necktie"
    ],
    u: "1f454"
  },
  {
    n: [
      "t-shirt",
      "shirt",
      "tshirt"
    ],
    u: "1f455"
  },
  {
    n: [
      "jeans"
    ],
    u: "1f456"
  },
  {
    n: [
      "scarf"
    ],
    u: "1f9e3"
  },
  {
    n: [
      "gloves"
    ],
    u: "1f9e4"
  },
  {
    n: [
      "coat"
    ],
    u: "1f9e5"
  },
  {
    n: [
      "socks"
    ],
    u: "1f9e6"
  },
  {
    n: [
      "dress"
    ],
    u: "1f457"
  },
  {
    n: [
      "kimono"
    ],
    u: "1f458"
  },
  {
    n: [
      "bikini"
    ],
    u: "1f459"
  },
  {
    n: [
      "womans clothes",
      "womans_clothes"
    ],
    u: "1f45a"
  },
  {
    n: [
      "purse"
    ],
    u: "1f45b"
  },
  {
    n: [
      "handbag"
    ],
    u: "1f45c"
  },
  {
    n: [
      "pouch"
    ],
    u: "1f45d"
  },
  {
    n: [
      "shopping_bags"
    ],
    u: "1f6cd-fe0f"
  },
  {
    n: [
      "school satchel",
      "school_satchel"
    ],
    u: "1f392"
  },
  {
    n: [
      "mans shoe",
      "mans_shoe",
      "shoe"
    ],
    u: "1f45e"
  },
  {
    n: [
      "athletic shoe",
      "athletic_shoe"
    ],
    u: "1f45f"
  },
  {
    n: [
      "high-heeled shoe",
      "high_heel"
    ],
    u: "1f460"
  },
  {
    n: [
      "womans sandal",
      "sandal"
    ],
    u: "1f461"
  },
  {
    n: [
      "womans boots",
      "boot"
    ],
    u: "1f462"
  },
  {
    n: [
      "crown"
    ],
    u: "1f451"
  },
  {
    n: [
      "womans hat",
      "womans_hat"
    ],
    u: "1f452"
  },
  {
    n: [
      "top hat",
      "tophat"
    ],
    u: "1f3a9"
  },
  {
    n: [
      "graduation cap",
      "mortar_board"
    ],
    u: "1f393"
  },
  {
    n: [
      "billed cap",
      "billed_cap"
    ],
    u: "1f9e2"
  },
  {
    n: [
      "helmet_with_white_cross"
    ],
    u: "26d1-fe0f"
  },
  {
    n: [
      "prayer beads",
      "prayer_beads"
    ],
    u: "1f4ff"
  },
  {
    n: [
      "lipstick"
    ],
    u: "1f484"
  },
  {
    n: [
      "ring"
    ],
    u: "1f48d"
  },
  {
    n: [
      "gem stone",
      "gem"
    ],
    u: "1f48e"
  }
];
const animals_nature$1 = [
  {
    n: [
      "monkey face",
      "monkey_face"
    ],
    u: "1f435"
  },
  {
    n: [
      "monkey"
    ],
    u: "1f412"
  },
  {
    n: [
      "gorilla"
    ],
    u: "1f98d"
  },
  {
    n: [
      "dog face",
      "dog"
    ],
    u: "1f436"
  },
  {
    n: [
      "dog",
      "dog2"
    ],
    u: "1f415"
  },
  {
    n: [
      "poodle"
    ],
    u: "1f429"
  },
  {
    n: [
      "wolf face",
      "wolf"
    ],
    u: "1f43a"
  },
  {
    n: [
      "fox face",
      "fox_face"
    ],
    u: "1f98a"
  },
  {
    n: [
      "cat face",
      "cat"
    ],
    u: "1f431"
  },
  {
    n: [
      "cat",
      "cat2"
    ],
    u: "1f408"
  },
  {
    n: [
      "lion face",
      "lion_face"
    ],
    u: "1f981"
  },
  {
    n: [
      "tiger face",
      "tiger"
    ],
    u: "1f42f"
  },
  {
    n: [
      "tiger",
      "tiger2"
    ],
    u: "1f405"
  },
  {
    n: [
      "leopard"
    ],
    u: "1f406"
  },
  {
    n: [
      "horse face",
      "horse"
    ],
    u: "1f434"
  },
  {
    n: [
      "horse",
      "racehorse"
    ],
    u: "1f40e"
  },
  {
    n: [
      "unicorn face",
      "unicorn_face"
    ],
    u: "1f984"
  },
  {
    n: [
      "zebra face",
      "zebra_face"
    ],
    u: "1f993"
  },
  {
    n: [
      "deer"
    ],
    u: "1f98c"
  },
  {
    n: [
      "cow face",
      "cow"
    ],
    u: "1f42e"
  },
  {
    n: [
      "ox"
    ],
    u: "1f402"
  },
  {
    n: [
      "water buffalo",
      "water_buffalo"
    ],
    u: "1f403"
  },
  {
    n: [
      "cow",
      "cow2"
    ],
    u: "1f404"
  },
  {
    n: [
      "pig face",
      "pig"
    ],
    u: "1f437"
  },
  {
    n: [
      "pig",
      "pig2"
    ],
    u: "1f416"
  },
  {
    n: [
      "boar"
    ],
    u: "1f417"
  },
  {
    n: [
      "pig nose",
      "pig_nose"
    ],
    u: "1f43d"
  },
  {
    n: [
      "ram"
    ],
    u: "1f40f"
  },
  {
    n: [
      "sheep"
    ],
    u: "1f411"
  },
  {
    n: [
      "goat"
    ],
    u: "1f410"
  },
  {
    n: [
      "dromedary camel",
      "dromedary_camel"
    ],
    u: "1f42a"
  },
  {
    n: [
      "bactrian camel",
      "camel"
    ],
    u: "1f42b"
  },
  {
    n: [
      "giraffe face",
      "giraffe_face"
    ],
    u: "1f992"
  },
  {
    n: [
      "elephant"
    ],
    u: "1f418"
  },
  {
    n: [
      "rhinoceros"
    ],
    u: "1f98f"
  },
  {
    n: [
      "mouse face",
      "mouse"
    ],
    u: "1f42d"
  },
  {
    n: [
      "mouse",
      "mouse2"
    ],
    u: "1f401"
  },
  {
    n: [
      "rat"
    ],
    u: "1f400"
  },
  {
    n: [
      "hamster face",
      "hamster"
    ],
    u: "1f439"
  },
  {
    n: [
      "rabbit face",
      "rabbit"
    ],
    u: "1f430"
  },
  {
    n: [
      "rabbit",
      "rabbit2"
    ],
    u: "1f407"
  },
  {
    n: [
      "chipmunk"
    ],
    u: "1f43f-fe0f"
  },
  {
    n: [
      "hedgehog"
    ],
    u: "1f994"
  },
  {
    n: [
      "bat"
    ],
    u: "1f987"
  },
  {
    n: [
      "bear face",
      "bear"
    ],
    u: "1f43b"
  },
  {
    n: [
      "koala"
    ],
    u: "1f428"
  },
  {
    n: [
      "panda face",
      "panda_face"
    ],
    u: "1f43c"
  },
  {
    n: [
      "paw prints",
      "feet",
      "paw_prints"
    ],
    u: "1f43e"
  },
  {
    n: [
      "turkey"
    ],
    u: "1f983"
  },
  {
    n: [
      "chicken"
    ],
    u: "1f414"
  },
  {
    n: [
      "rooster"
    ],
    u: "1f413"
  },
  {
    n: [
      "hatching chick",
      "hatching_chick"
    ],
    u: "1f423"
  },
  {
    n: [
      "baby chick",
      "baby_chick"
    ],
    u: "1f424"
  },
  {
    n: [
      "front-facing baby chick",
      "hatched_chick"
    ],
    u: "1f425"
  },
  {
    n: [
      "bird"
    ],
    u: "1f426"
  },
  {
    n: [
      "penguin"
    ],
    u: "1f427"
  },
  {
    n: [
      "dove_of_peace"
    ],
    u: "1f54a-fe0f"
  },
  {
    n: [
      "eagle"
    ],
    u: "1f985"
  },
  {
    n: [
      "duck"
    ],
    u: "1f986"
  },
  {
    n: [
      "owl"
    ],
    u: "1f989"
  },
  {
    n: [
      "frog face",
      "frog"
    ],
    u: "1f438"
  },
  {
    n: [
      "crocodile"
    ],
    u: "1f40a"
  },
  {
    n: [
      "turtle"
    ],
    u: "1f422"
  },
  {
    n: [
      "lizard"
    ],
    u: "1f98e"
  },
  {
    n: [
      "snake"
    ],
    u: "1f40d"
  },
  {
    n: [
      "dragon face",
      "dragon_face"
    ],
    u: "1f432"
  },
  {
    n: [
      "dragon"
    ],
    u: "1f409"
  },
  {
    n: [
      "sauropod"
    ],
    u: "1f995"
  },
  {
    n: [
      "t-rex"
    ],
    u: "1f996"
  },
  {
    n: [
      "spouting whale",
      "whale"
    ],
    u: "1f433"
  },
  {
    n: [
      "whale",
      "whale2"
    ],
    u: "1f40b"
  },
  {
    n: [
      "dolphin",
      "flipper"
    ],
    u: "1f42c"
  },
  {
    n: [
      "fish"
    ],
    u: "1f41f"
  },
  {
    n: [
      "tropical fish",
      "tropical_fish"
    ],
    u: "1f420"
  },
  {
    n: [
      "blowfish"
    ],
    u: "1f421"
  },
  {
    n: [
      "shark"
    ],
    u: "1f988"
  },
  {
    n: [
      "octopus"
    ],
    u: "1f419"
  },
  {
    n: [
      "spiral shell",
      "shell"
    ],
    u: "1f41a"
  },
  {
    n: [
      "crab"
    ],
    u: "1f980"
  },
  {
    n: [
      "shrimp"
    ],
    u: "1f990"
  },
  {
    n: [
      "squid"
    ],
    u: "1f991"
  },
  {
    n: [
      "snail"
    ],
    u: "1f40c"
  },
  {
    n: [
      "butterfly"
    ],
    u: "1f98b"
  },
  {
    n: [
      "bug"
    ],
    u: "1f41b"
  },
  {
    n: [
      "ant"
    ],
    u: "1f41c"
  },
  {
    n: [
      "honeybee",
      "bee"
    ],
    u: "1f41d"
  },
  {
    n: [
      "lady beetle",
      "beetle"
    ],
    u: "1f41e"
  },
  {
    n: [
      "cricket"
    ],
    u: "1f997"
  },
  {
    n: [
      "spider"
    ],
    u: "1f577-fe0f"
  },
  {
    n: [
      "spider_web"
    ],
    u: "1f578-fe0f"
  },
  {
    n: [
      "scorpion"
    ],
    u: "1f982"
  },
  {
    n: [
      "bouquet"
    ],
    u: "1f490"
  },
  {
    n: [
      "cherry blossom",
      "cherry_blossom"
    ],
    u: "1f338"
  },
  {
    n: [
      "white flower",
      "white_flower"
    ],
    u: "1f4ae"
  },
  {
    n: [
      "rosette"
    ],
    u: "1f3f5-fe0f"
  },
  {
    n: [
      "rose"
    ],
    u: "1f339"
  },
  {
    n: [
      "wilted flower",
      "wilted_flower"
    ],
    u: "1f940"
  },
  {
    n: [
      "hibiscus"
    ],
    u: "1f33a"
  },
  {
    n: [
      "sunflower"
    ],
    u: "1f33b"
  },
  {
    n: [
      "blossom"
    ],
    u: "1f33c"
  },
  {
    n: [
      "tulip"
    ],
    u: "1f337"
  },
  {
    n: [
      "seedling"
    ],
    u: "1f331"
  },
  {
    n: [
      "evergreen tree",
      "evergreen_tree"
    ],
    u: "1f332"
  },
  {
    n: [
      "deciduous tree",
      "deciduous_tree"
    ],
    u: "1f333"
  },
  {
    n: [
      "palm tree",
      "palm_tree"
    ],
    u: "1f334"
  },
  {
    n: [
      "cactus"
    ],
    u: "1f335"
  },
  {
    n: [
      "ear of rice",
      "ear_of_rice"
    ],
    u: "1f33e"
  },
  {
    n: [
      "herb"
    ],
    u: "1f33f"
  },
  {
    n: [
      "shamrock"
    ],
    u: "2618-fe0f"
  },
  {
    n: [
      "four leaf clover",
      "four_leaf_clover"
    ],
    u: "1f340"
  },
  {
    n: [
      "maple leaf",
      "maple_leaf"
    ],
    u: "1f341"
  },
  {
    n: [
      "fallen leaf",
      "fallen_leaf"
    ],
    u: "1f342"
  },
  {
    n: [
      "leaf fluttering in wind",
      "leaves"
    ],
    u: "1f343"
  }
];
const food_drink$1 = [
  {
    n: [
      "grapes"
    ],
    u: "1f347"
  },
  {
    n: [
      "melon"
    ],
    u: "1f348"
  },
  {
    n: [
      "watermelon"
    ],
    u: "1f349"
  },
  {
    n: [
      "tangerine"
    ],
    u: "1f34a"
  },
  {
    n: [
      "lemon"
    ],
    u: "1f34b"
  },
  {
    n: [
      "banana"
    ],
    u: "1f34c"
  },
  {
    n: [
      "pineapple"
    ],
    u: "1f34d"
  },
  {
    n: [
      "red apple",
      "apple"
    ],
    u: "1f34e"
  },
  {
    n: [
      "green apple",
      "green_apple"
    ],
    u: "1f34f"
  },
  {
    n: [
      "pear"
    ],
    u: "1f350"
  },
  {
    n: [
      "peach"
    ],
    u: "1f351"
  },
  {
    n: [
      "cherries"
    ],
    u: "1f352"
  },
  {
    n: [
      "strawberry"
    ],
    u: "1f353"
  },
  {
    n: [
      "kiwifruit"
    ],
    u: "1f95d"
  },
  {
    n: [
      "tomato"
    ],
    u: "1f345"
  },
  {
    n: [
      "coconut"
    ],
    u: "1f965"
  },
  {
    n: [
      "avocado"
    ],
    u: "1f951"
  },
  {
    n: [
      "aubergine",
      "eggplant"
    ],
    u: "1f346"
  },
  {
    n: [
      "potato"
    ],
    u: "1f954"
  },
  {
    n: [
      "carrot"
    ],
    u: "1f955"
  },
  {
    n: [
      "ear of maize",
      "corn"
    ],
    u: "1f33d"
  },
  {
    n: [
      "hot_pepper"
    ],
    u: "1f336-fe0f"
  },
  {
    n: [
      "cucumber"
    ],
    u: "1f952"
  },
  {
    n: [
      "broccoli"
    ],
    u: "1f966"
  },
  {
    n: [
      "mushroom"
    ],
    u: "1f344"
  },
  {
    n: [
      "peanuts"
    ],
    u: "1f95c"
  },
  {
    n: [
      "chestnut"
    ],
    u: "1f330"
  },
  {
    n: [
      "bread"
    ],
    u: "1f35e"
  },
  {
    n: [
      "croissant"
    ],
    u: "1f950"
  },
  {
    n: [
      "baguette bread",
      "baguette_bread"
    ],
    u: "1f956"
  },
  {
    n: [
      "pretzel"
    ],
    u: "1f968"
  },
  {
    n: [
      "pancakes"
    ],
    u: "1f95e"
  },
  {
    n: [
      "cheese wedge",
      "cheese_wedge"
    ],
    u: "1f9c0"
  },
  {
    n: [
      "meat on bone",
      "meat_on_bone"
    ],
    u: "1f356"
  },
  {
    n: [
      "poultry leg",
      "poultry_leg"
    ],
    u: "1f357"
  },
  {
    n: [
      "cut of meat",
      "cut_of_meat"
    ],
    u: "1f969"
  },
  {
    n: [
      "bacon"
    ],
    u: "1f953"
  },
  {
    n: [
      "hamburger"
    ],
    u: "1f354"
  },
  {
    n: [
      "french fries",
      "fries"
    ],
    u: "1f35f"
  },
  {
    n: [
      "slice of pizza",
      "pizza"
    ],
    u: "1f355"
  },
  {
    n: [
      "hot dog",
      "hotdog"
    ],
    u: "1f32d"
  },
  {
    n: [
      "sandwich"
    ],
    u: "1f96a"
  },
  {
    n: [
      "taco"
    ],
    u: "1f32e"
  },
  {
    n: [
      "burrito"
    ],
    u: "1f32f"
  },
  {
    n: [
      "stuffed flatbread",
      "stuffed_flatbread"
    ],
    u: "1f959"
  },
  {
    n: [
      "egg"
    ],
    u: "1f95a"
  },
  {
    n: [
      "cooking",
      "fried_egg"
    ],
    u: "1f373"
  },
  {
    n: [
      "shallow pan of food",
      "shallow_pan_of_food"
    ],
    u: "1f958"
  },
  {
    n: [
      "pot of food",
      "stew"
    ],
    u: "1f372"
  },
  {
    n: [
      "bowl with spoon",
      "bowl_with_spoon"
    ],
    u: "1f963"
  },
  {
    n: [
      "green salad",
      "green_salad"
    ],
    u: "1f957"
  },
  {
    n: [
      "popcorn"
    ],
    u: "1f37f"
  },
  {
    n: [
      "canned food",
      "canned_food"
    ],
    u: "1f96b"
  },
  {
    n: [
      "bento box",
      "bento"
    ],
    u: "1f371"
  },
  {
    n: [
      "rice cracker",
      "rice_cracker"
    ],
    u: "1f358"
  },
  {
    n: [
      "rice ball",
      "rice_ball"
    ],
    u: "1f359"
  },
  {
    n: [
      "cooked rice",
      "rice"
    ],
    u: "1f35a"
  },
  {
    n: [
      "curry and rice",
      "curry"
    ],
    u: "1f35b"
  },
  {
    n: [
      "steaming bowl",
      "ramen"
    ],
    u: "1f35c"
  },
  {
    n: [
      "spaghetti"
    ],
    u: "1f35d"
  },
  {
    n: [
      "roasted sweet potato",
      "sweet_potato"
    ],
    u: "1f360"
  },
  {
    n: [
      "oden"
    ],
    u: "1f362"
  },
  {
    n: [
      "sushi"
    ],
    u: "1f363"
  },
  {
    n: [
      "fried shrimp",
      "fried_shrimp"
    ],
    u: "1f364"
  },
  {
    n: [
      "fish cake with swirl design",
      "fish_cake"
    ],
    u: "1f365"
  },
  {
    n: [
      "dango"
    ],
    u: "1f361"
  },
  {
    n: [
      "dumpling"
    ],
    u: "1f95f"
  },
  {
    n: [
      "fortune cookie",
      "fortune_cookie"
    ],
    u: "1f960"
  },
  {
    n: [
      "takeout box",
      "takeout_box"
    ],
    u: "1f961"
  },
  {
    n: [
      "soft ice cream",
      "icecream"
    ],
    u: "1f366"
  },
  {
    n: [
      "shaved ice",
      "shaved_ice"
    ],
    u: "1f367"
  },
  {
    n: [
      "ice cream",
      "ice_cream"
    ],
    u: "1f368"
  },
  {
    n: [
      "doughnut"
    ],
    u: "1f369"
  },
  {
    n: [
      "cookie"
    ],
    u: "1f36a"
  },
  {
    n: [
      "birthday cake",
      "birthday"
    ],
    u: "1f382"
  },
  {
    n: [
      "shortcake",
      "cake"
    ],
    u: "1f370"
  },
  {
    n: [
      "pie"
    ],
    u: "1f967"
  },
  {
    n: [
      "chocolate bar",
      "chocolate_bar"
    ],
    u: "1f36b"
  },
  {
    n: [
      "candy"
    ],
    u: "1f36c"
  },
  {
    n: [
      "lollipop"
    ],
    u: "1f36d"
  },
  {
    n: [
      "custard"
    ],
    u: "1f36e"
  },
  {
    n: [
      "honey pot",
      "honey_pot"
    ],
    u: "1f36f"
  },
  {
    n: [
      "baby bottle",
      "baby_bottle"
    ],
    u: "1f37c"
  },
  {
    n: [
      "glass of milk",
      "glass_of_milk"
    ],
    u: "1f95b"
  },
  {
    n: [
      "hot beverage",
      "coffee"
    ],
    u: "2615"
  },
  {
    n: [
      "teacup without handle",
      "tea"
    ],
    u: "1f375"
  },
  {
    n: [
      "sake bottle and cup",
      "sake"
    ],
    u: "1f376"
  },
  {
    n: [
      "bottle with popping cork",
      "champagne"
    ],
    u: "1f37e"
  },
  {
    n: [
      "wine glass",
      "wine_glass"
    ],
    u: "1f377"
  },
  {
    n: [
      "cocktail glass",
      "cocktail"
    ],
    u: "1f378"
  },
  {
    n: [
      "tropical drink",
      "tropical_drink"
    ],
    u: "1f379"
  },
  {
    n: [
      "beer mug",
      "beer"
    ],
    u: "1f37a"
  },
  {
    n: [
      "clinking beer mugs",
      "beers"
    ],
    u: "1f37b"
  },
  {
    n: [
      "clinking glasses",
      "clinking_glasses"
    ],
    u: "1f942"
  },
  {
    n: [
      "tumbler glass",
      "tumbler_glass"
    ],
    u: "1f943"
  },
  {
    n: [
      "cup with straw",
      "cup_with_straw"
    ],
    u: "1f964"
  },
  {
    n: [
      "chopsticks"
    ],
    u: "1f962"
  },
  {
    n: [
      "knife_fork_plate"
    ],
    u: "1f37d-fe0f"
  },
  {
    n: [
      "fork and knife",
      "fork_and_knife"
    ],
    u: "1f374"
  },
  {
    n: [
      "spoon"
    ],
    u: "1f944"
  },
  {
    n: [
      "hocho",
      "knife"
    ],
    u: "1f52a"
  },
  {
    n: [
      "amphora"
    ],
    u: "1f3fa"
  }
];
const activities$1 = [
  {
    n: [
      "jack-o-lantern",
      "jack_o_lantern"
    ],
    u: "1f383"
  },
  {
    n: [
      "christmas tree",
      "christmas_tree"
    ],
    u: "1f384"
  },
  {
    n: [
      "fireworks"
    ],
    u: "1f386"
  },
  {
    n: [
      "firework sparkler",
      "sparkler"
    ],
    u: "1f387"
  },
  {
    n: [
      "sparkles"
    ],
    u: "2728"
  },
  {
    n: [
      "balloon"
    ],
    u: "1f388"
  },
  {
    n: [
      "party popper",
      "tada"
    ],
    u: "1f389"
  },
  {
    n: [
      "confetti ball",
      "confetti_ball"
    ],
    u: "1f38a"
  },
  {
    n: [
      "tanabata tree",
      "tanabata_tree"
    ],
    u: "1f38b"
  },
  {
    n: [
      "pine decoration",
      "bamboo"
    ],
    u: "1f38d"
  },
  {
    n: [
      "japanese dolls",
      "dolls"
    ],
    u: "1f38e"
  },
  {
    n: [
      "carp streamer",
      "flags"
    ],
    u: "1f38f"
  },
  {
    n: [
      "wind chime",
      "wind_chime"
    ],
    u: "1f390"
  },
  {
    n: [
      "moon viewing ceremony",
      "rice_scene"
    ],
    u: "1f391"
  },
  {
    n: [
      "ribbon"
    ],
    u: "1f380"
  },
  {
    n: [
      "wrapped present",
      "gift"
    ],
    u: "1f381"
  },
  {
    n: [
      "reminder_ribbon"
    ],
    u: "1f397-fe0f"
  },
  {
    n: [
      "admission_tickets"
    ],
    u: "1f39f-fe0f"
  },
  {
    n: [
      "ticket"
    ],
    u: "1f3ab"
  },
  {
    n: [
      "medal"
    ],
    u: "1f396-fe0f"
  },
  {
    n: [
      "trophy"
    ],
    u: "1f3c6"
  },
  {
    n: [
      "sports medal",
      "sports_medal"
    ],
    u: "1f3c5"
  },
  {
    n: [
      "first place medal",
      "first_place_medal"
    ],
    u: "1f947"
  },
  {
    n: [
      "second place medal",
      "second_place_medal"
    ],
    u: "1f948"
  },
  {
    n: [
      "third place medal",
      "third_place_medal"
    ],
    u: "1f949"
  },
  {
    n: [
      "soccer ball",
      "soccer"
    ],
    u: "26bd"
  },
  {
    n: [
      "baseball"
    ],
    u: "26be"
  },
  {
    n: [
      "basketball and hoop",
      "basketball"
    ],
    u: "1f3c0"
  },
  {
    n: [
      "volleyball"
    ],
    u: "1f3d0"
  },
  {
    n: [
      "american football",
      "football"
    ],
    u: "1f3c8"
  },
  {
    n: [
      "rugby football",
      "rugby_football"
    ],
    u: "1f3c9"
  },
  {
    n: [
      "tennis racquet and ball",
      "tennis"
    ],
    u: "1f3be"
  },
  {
    n: [
      "billiards",
      "8ball"
    ],
    u: "1f3b1"
  },
  {
    n: [
      "bowling"
    ],
    u: "1f3b3"
  },
  {
    n: [
      "cricket bat and ball",
      "cricket_bat_and_ball"
    ],
    u: "1f3cf"
  },
  {
    n: [
      "field hockey stick and ball",
      "field_hockey_stick_and_ball"
    ],
    u: "1f3d1"
  },
  {
    n: [
      "ice hockey stick and puck",
      "ice_hockey_stick_and_puck"
    ],
    u: "1f3d2"
  },
  {
    n: [
      "table tennis paddle and ball",
      "table_tennis_paddle_and_ball"
    ],
    u: "1f3d3"
  },
  {
    n: [
      "badminton racquet and shuttlecock",
      "badminton_racquet_and_shuttlecock"
    ],
    u: "1f3f8"
  },
  {
    n: [
      "boxing glove",
      "boxing_glove"
    ],
    u: "1f94a"
  },
  {
    n: [
      "martial arts uniform",
      "martial_arts_uniform"
    ],
    u: "1f94b"
  },
  {
    n: [
      "goal net",
      "goal_net"
    ],
    u: "1f945"
  },
  {
    n: [
      "direct hit",
      "dart"
    ],
    u: "1f3af"
  },
  {
    n: [
      "flag in hole",
      "golf"
    ],
    u: "26f3"
  },
  {
    n: [
      "ice_skate"
    ],
    u: "26f8-fe0f"
  },
  {
    n: [
      "fishing pole and fish",
      "fishing_pole_and_fish"
    ],
    u: "1f3a3"
  },
  {
    n: [
      "running shirt with sash",
      "running_shirt_with_sash"
    ],
    u: "1f3bd"
  },
  {
    n: [
      "ski and ski boot",
      "ski"
    ],
    u: "1f3bf"
  },
  {
    n: [
      "sled"
    ],
    u: "1f6f7"
  },
  {
    n: [
      "curling stone",
      "curling_stone"
    ],
    u: "1f94c"
  },
  {
    n: [
      "video game",
      "video_game"
    ],
    u: "1f3ae"
  },
  {
    n: [
      "joystick"
    ],
    u: "1f579-fe0f"
  },
  {
    n: [
      "game die",
      "game_die"
    ],
    u: "1f3b2"
  },
  {
    n: [
      "black spade suit",
      "spades"
    ],
    u: "2660-fe0f"
  },
  {
    n: [
      "black heart suit",
      "hearts"
    ],
    u: "2665-fe0f"
  },
  {
    n: [
      "black diamond suit",
      "diamonds"
    ],
    u: "2666-fe0f"
  },
  {
    n: [
      "black club suit",
      "clubs"
    ],
    u: "2663-fe0f"
  },
  {
    n: [
      "playing card black joker",
      "black_joker"
    ],
    u: "1f0cf"
  },
  {
    n: [
      "mahjong tile red dragon",
      "mahjong"
    ],
    u: "1f004"
  },
  {
    n: [
      "flower playing cards",
      "flower_playing_cards"
    ],
    u: "1f3b4"
  }
];
const travel_places$1 = [
  {
    n: [
      "earth globe europe-africa",
      "earth_africa"
    ],
    u: "1f30d"
  },
  {
    n: [
      "earth globe americas",
      "earth_americas"
    ],
    u: "1f30e"
  },
  {
    n: [
      "earth globe asia-australia",
      "earth_asia"
    ],
    u: "1f30f"
  },
  {
    n: [
      "globe with meridians",
      "globe_with_meridians"
    ],
    u: "1f310"
  },
  {
    n: [
      "world_map"
    ],
    u: "1f5fa-fe0f"
  },
  {
    n: [
      "silhouette of japan",
      "japan"
    ],
    u: "1f5fe"
  },
  {
    n: [
      "snow_capped_mountain"
    ],
    u: "1f3d4-fe0f"
  },
  {
    n: [
      "mountain"
    ],
    u: "26f0-fe0f"
  },
  {
    n: [
      "volcano"
    ],
    u: "1f30b"
  },
  {
    n: [
      "mount fuji",
      "mount_fuji"
    ],
    u: "1f5fb"
  },
  {
    n: [
      "camping"
    ],
    u: "1f3d5-fe0f"
  },
  {
    n: [
      "beach_with_umbrella"
    ],
    u: "1f3d6-fe0f"
  },
  {
    n: [
      "desert"
    ],
    u: "1f3dc-fe0f"
  },
  {
    n: [
      "desert_island"
    ],
    u: "1f3dd-fe0f"
  },
  {
    n: [
      "national_park"
    ],
    u: "1f3de-fe0f"
  },
  {
    n: [
      "stadium"
    ],
    u: "1f3df-fe0f"
  },
  {
    n: [
      "classical_building"
    ],
    u: "1f3db-fe0f"
  },
  {
    n: [
      "building_construction"
    ],
    u: "1f3d7-fe0f"
  },
  {
    n: [
      "house_buildings"
    ],
    u: "1f3d8-fe0f"
  },
  {
    n: [
      "cityscape"
    ],
    u: "1f3d9-fe0f"
  },
  {
    n: [
      "derelict_house_building"
    ],
    u: "1f3da-fe0f"
  },
  {
    n: [
      "house building",
      "house"
    ],
    u: "1f3e0"
  },
  {
    n: [
      "house with garden",
      "house_with_garden"
    ],
    u: "1f3e1"
  },
  {
    n: [
      "office building",
      "office"
    ],
    u: "1f3e2"
  },
  {
    n: [
      "japanese post office",
      "post_office"
    ],
    u: "1f3e3"
  },
  {
    n: [
      "european post office",
      "european_post_office"
    ],
    u: "1f3e4"
  },
  {
    n: [
      "hospital"
    ],
    u: "1f3e5"
  },
  {
    n: [
      "bank"
    ],
    u: "1f3e6"
  },
  {
    n: [
      "hotel"
    ],
    u: "1f3e8"
  },
  {
    n: [
      "love hotel",
      "love_hotel"
    ],
    u: "1f3e9"
  },
  {
    n: [
      "convenience store",
      "convenience_store"
    ],
    u: "1f3ea"
  },
  {
    n: [
      "school"
    ],
    u: "1f3eb"
  },
  {
    n: [
      "department store",
      "department_store"
    ],
    u: "1f3ec"
  },
  {
    n: [
      "factory"
    ],
    u: "1f3ed"
  },
  {
    n: [
      "japanese castle",
      "japanese_castle"
    ],
    u: "1f3ef"
  },
  {
    n: [
      "european castle",
      "european_castle"
    ],
    u: "1f3f0"
  },
  {
    n: [
      "wedding"
    ],
    u: "1f492"
  },
  {
    n: [
      "tokyo tower",
      "tokyo_tower"
    ],
    u: "1f5fc"
  },
  {
    n: [
      "statue of liberty",
      "statue_of_liberty"
    ],
    u: "1f5fd"
  },
  {
    n: [
      "church"
    ],
    u: "26ea"
  },
  {
    n: [
      "mosque"
    ],
    u: "1f54c"
  },
  {
    n: [
      "synagogue"
    ],
    u: "1f54d"
  },
  {
    n: [
      "shinto_shrine"
    ],
    u: "26e9-fe0f"
  },
  {
    n: [
      "kaaba"
    ],
    u: "1f54b"
  },
  {
    n: [
      "fountain"
    ],
    u: "26f2"
  },
  {
    n: [
      "tent"
    ],
    u: "26fa"
  },
  {
    n: [
      "foggy"
    ],
    u: "1f301"
  },
  {
    n: [
      "night with stars",
      "night_with_stars"
    ],
    u: "1f303"
  },
  {
    n: [
      "sunrise over mountains",
      "sunrise_over_mountains"
    ],
    u: "1f304"
  },
  {
    n: [
      "sunrise"
    ],
    u: "1f305"
  },
  {
    n: [
      "cityscape at dusk",
      "city_sunset"
    ],
    u: "1f306"
  },
  {
    n: [
      "sunset over buildings",
      "city_sunrise"
    ],
    u: "1f307"
  },
  {
    n: [
      "bridge at night",
      "bridge_at_night"
    ],
    u: "1f309"
  },
  {
    n: [
      "hot springs",
      "hotsprings"
    ],
    u: "2668-fe0f"
  },
  {
    n: [
      "milky way",
      "milky_way"
    ],
    u: "1f30c"
  },
  {
    n: [
      "carousel horse",
      "carousel_horse"
    ],
    u: "1f3a0"
  },
  {
    n: [
      "ferris wheel",
      "ferris_wheel"
    ],
    u: "1f3a1"
  },
  {
    n: [
      "roller coaster",
      "roller_coaster"
    ],
    u: "1f3a2"
  },
  {
    n: [
      "barber pole",
      "barber"
    ],
    u: "1f488"
  },
  {
    n: [
      "circus tent",
      "circus_tent"
    ],
    u: "1f3aa"
  },
  {
    n: [
      "performing arts",
      "performing_arts"
    ],
    u: "1f3ad"
  },
  {
    n: [
      "frame_with_picture"
    ],
    u: "1f5bc-fe0f"
  },
  {
    n: [
      "artist palette",
      "art"
    ],
    u: "1f3a8"
  },
  {
    n: [
      "slot machine",
      "slot_machine"
    ],
    u: "1f3b0"
  },
  {
    n: [
      "steam locomotive",
      "steam_locomotive"
    ],
    u: "1f682"
  },
  {
    n: [
      "railway car",
      "railway_car"
    ],
    u: "1f683"
  },
  {
    n: [
      "high-speed train",
      "bullettrain_side"
    ],
    u: "1f684"
  },
  {
    n: [
      "high-speed train with bullet nose",
      "bullettrain_front"
    ],
    u: "1f685"
  },
  {
    n: [
      "train",
      "train2"
    ],
    u: "1f686"
  },
  {
    n: [
      "metro"
    ],
    u: "1f687"
  },
  {
    n: [
      "light rail",
      "light_rail"
    ],
    u: "1f688"
  },
  {
    n: [
      "station"
    ],
    u: "1f689"
  },
  {
    n: [
      "tram"
    ],
    u: "1f68a"
  },
  {
    n: [
      "monorail"
    ],
    u: "1f69d"
  },
  {
    n: [
      "mountain railway",
      "mountain_railway"
    ],
    u: "1f69e"
  },
  {
    n: [
      "tram car",
      "train"
    ],
    u: "1f68b"
  },
  {
    n: [
      "bus"
    ],
    u: "1f68c"
  },
  {
    n: [
      "oncoming bus",
      "oncoming_bus"
    ],
    u: "1f68d"
  },
  {
    n: [
      "trolleybus"
    ],
    u: "1f68e"
  },
  {
    n: [
      "minibus"
    ],
    u: "1f690"
  },
  {
    n: [
      "ambulance"
    ],
    u: "1f691"
  },
  {
    n: [
      "fire engine",
      "fire_engine"
    ],
    u: "1f692"
  },
  {
    n: [
      "police car",
      "police_car"
    ],
    u: "1f693"
  },
  {
    n: [
      "oncoming police car",
      "oncoming_police_car"
    ],
    u: "1f694"
  },
  {
    n: [
      "taxi"
    ],
    u: "1f695"
  },
  {
    n: [
      "oncoming taxi",
      "oncoming_taxi"
    ],
    u: "1f696"
  },
  {
    n: [
      "automobile",
      "car",
      "red_car"
    ],
    u: "1f697"
  },
  {
    n: [
      "oncoming automobile",
      "oncoming_automobile"
    ],
    u: "1f698"
  },
  {
    n: [
      "recreational vehicle",
      "blue_car"
    ],
    u: "1f699"
  },
  {
    n: [
      "delivery truck",
      "truck"
    ],
    u: "1f69a"
  },
  {
    n: [
      "articulated lorry",
      "articulated_lorry"
    ],
    u: "1f69b"
  },
  {
    n: [
      "tractor"
    ],
    u: "1f69c"
  },
  {
    n: [
      "bicycle",
      "bike"
    ],
    u: "1f6b2"
  },
  {
    n: [
      "scooter"
    ],
    u: "1f6f4"
  },
  {
    n: [
      "motor scooter",
      "motor_scooter"
    ],
    u: "1f6f5"
  },
  {
    n: [
      "bus stop",
      "busstop"
    ],
    u: "1f68f"
  },
  {
    n: [
      "motorway"
    ],
    u: "1f6e3-fe0f"
  },
  {
    n: [
      "railway_track"
    ],
    u: "1f6e4-fe0f"
  },
  {
    n: [
      "fuel pump",
      "fuelpump"
    ],
    u: "26fd"
  },
  {
    n: [
      "police cars revolving light",
      "rotating_light"
    ],
    u: "1f6a8"
  },
  {
    n: [
      "horizontal traffic light",
      "traffic_light"
    ],
    u: "1f6a5"
  },
  {
    n: [
      "vertical traffic light",
      "vertical_traffic_light"
    ],
    u: "1f6a6"
  },
  {
    n: [
      "construction sign",
      "construction"
    ],
    u: "1f6a7"
  },
  {
    n: [
      "octagonal sign",
      "octagonal_sign"
    ],
    u: "1f6d1"
  },
  {
    n: [
      "anchor"
    ],
    u: "2693"
  },
  {
    n: [
      "sailboat",
      "boat"
    ],
    u: "26f5"
  },
  {
    n: [
      "canoe"
    ],
    u: "1f6f6"
  },
  {
    n: [
      "speedboat"
    ],
    u: "1f6a4"
  },
  {
    n: [
      "passenger_ship"
    ],
    u: "1f6f3-fe0f"
  },
  {
    n: [
      "ferry"
    ],
    u: "26f4-fe0f"
  },
  {
    n: [
      "motor_boat"
    ],
    u: "1f6e5-fe0f"
  },
  {
    n: [
      "ship"
    ],
    u: "1f6a2"
  },
  {
    n: [
      "airplane"
    ],
    u: "2708-fe0f"
  },
  {
    n: [
      "small_airplane"
    ],
    u: "1f6e9-fe0f"
  },
  {
    n: [
      "airplane departure",
      "airplane_departure"
    ],
    u: "1f6eb"
  },
  {
    n: [
      "airplane arriving",
      "airplane_arriving"
    ],
    u: "1f6ec"
  },
  {
    n: [
      "seat"
    ],
    u: "1f4ba"
  },
  {
    n: [
      "helicopter"
    ],
    u: "1f681"
  },
  {
    n: [
      "suspension railway",
      "suspension_railway"
    ],
    u: "1f69f"
  },
  {
    n: [
      "mountain cableway",
      "mountain_cableway"
    ],
    u: "1f6a0"
  },
  {
    n: [
      "aerial tramway",
      "aerial_tramway"
    ],
    u: "1f6a1"
  },
  {
    n: [
      "satellite"
    ],
    u: "1f6f0-fe0f"
  },
  {
    n: [
      "rocket"
    ],
    u: "1f680"
  },
  {
    n: [
      "flying saucer",
      "flying_saucer"
    ],
    u: "1f6f8"
  },
  {
    n: [
      "bellhop_bell"
    ],
    u: "1f6ce-fe0f"
  },
  {
    n: [
      "door"
    ],
    u: "1f6aa"
  },
  {
    n: [
      "bed"
    ],
    u: "1f6cf-fe0f"
  },
  {
    n: [
      "couch_and_lamp"
    ],
    u: "1f6cb-fe0f"
  },
  {
    n: [
      "toilet"
    ],
    u: "1f6bd"
  },
  {
    n: [
      "shower"
    ],
    u: "1f6bf"
  },
  {
    n: [
      "bathtub"
    ],
    u: "1f6c1"
  },
  {
    n: [
      "hourglass"
    ],
    u: "231b"
  },
  {
    n: [
      "hourglass with flowing sand",
      "hourglass_flowing_sand"
    ],
    u: "23f3"
  },
  {
    n: [
      "watch"
    ],
    u: "231a"
  },
  {
    n: [
      "alarm clock",
      "alarm_clock"
    ],
    u: "23f0"
  },
  {
    n: [
      "stopwatch"
    ],
    u: "23f1-fe0f"
  },
  {
    n: [
      "timer_clock"
    ],
    u: "23f2-fe0f"
  },
  {
    n: [
      "mantelpiece_clock"
    ],
    u: "1f570-fe0f"
  },
  {
    n: [
      "clock face twelve oclock",
      "clock12"
    ],
    u: "1f55b"
  },
  {
    n: [
      "clock face twelve-thirty",
      "clock1230"
    ],
    u: "1f567"
  },
  {
    n: [
      "clock face one oclock",
      "clock1"
    ],
    u: "1f550"
  },
  {
    n: [
      "clock face one-thirty",
      "clock130"
    ],
    u: "1f55c"
  },
  {
    n: [
      "clock face two oclock",
      "clock2"
    ],
    u: "1f551"
  },
  {
    n: [
      "clock face two-thirty",
      "clock230"
    ],
    u: "1f55d"
  },
  {
    n: [
      "clock face three oclock",
      "clock3"
    ],
    u: "1f552"
  },
  {
    n: [
      "clock face three-thirty",
      "clock330"
    ],
    u: "1f55e"
  },
  {
    n: [
      "clock face four oclock",
      "clock4"
    ],
    u: "1f553"
  },
  {
    n: [
      "clock face four-thirty",
      "clock430"
    ],
    u: "1f55f"
  },
  {
    n: [
      "clock face five oclock",
      "clock5"
    ],
    u: "1f554"
  },
  {
    n: [
      "clock face five-thirty",
      "clock530"
    ],
    u: "1f560"
  },
  {
    n: [
      "clock face six oclock",
      "clock6"
    ],
    u: "1f555"
  },
  {
    n: [
      "clock face six-thirty",
      "clock630"
    ],
    u: "1f561"
  },
  {
    n: [
      "clock face seven oclock",
      "clock7"
    ],
    u: "1f556"
  },
  {
    n: [
      "clock face seven-thirty",
      "clock730"
    ],
    u: "1f562"
  },
  {
    n: [
      "clock face eight oclock",
      "clock8"
    ],
    u: "1f557"
  },
  {
    n: [
      "clock face eight-thirty",
      "clock830"
    ],
    u: "1f563"
  },
  {
    n: [
      "clock face nine oclock",
      "clock9"
    ],
    u: "1f558"
  },
  {
    n: [
      "clock face nine-thirty",
      "clock930"
    ],
    u: "1f564"
  },
  {
    n: [
      "clock face ten oclock",
      "clock10"
    ],
    u: "1f559"
  },
  {
    n: [
      "clock face ten-thirty",
      "clock1030"
    ],
    u: "1f565"
  },
  {
    n: [
      "clock face eleven oclock",
      "clock11"
    ],
    u: "1f55a"
  },
  {
    n: [
      "clock face eleven-thirty",
      "clock1130"
    ],
    u: "1f566"
  },
  {
    n: [
      "new moon symbol",
      "new_moon"
    ],
    u: "1f311"
  },
  {
    n: [
      "waxing crescent moon symbol",
      "waxing_crescent_moon"
    ],
    u: "1f312"
  },
  {
    n: [
      "first quarter moon symbol",
      "first_quarter_moon"
    ],
    u: "1f313"
  },
  {
    n: [
      "waxing gibbous moon symbol",
      "moon",
      "waxing_gibbous_moon"
    ],
    u: "1f314"
  },
  {
    n: [
      "full moon symbol",
      "full_moon"
    ],
    u: "1f315"
  },
  {
    n: [
      "waning gibbous moon symbol",
      "waning_gibbous_moon"
    ],
    u: "1f316"
  },
  {
    n: [
      "last quarter moon symbol",
      "last_quarter_moon"
    ],
    u: "1f317"
  },
  {
    n: [
      "waning crescent moon symbol",
      "waning_crescent_moon"
    ],
    u: "1f318"
  },
  {
    n: [
      "crescent moon",
      "crescent_moon"
    ],
    u: "1f319"
  },
  {
    n: [
      "new moon with face",
      "new_moon_with_face"
    ],
    u: "1f31a"
  },
  {
    n: [
      "first quarter moon with face",
      "first_quarter_moon_with_face"
    ],
    u: "1f31b"
  },
  {
    n: [
      "last quarter moon with face",
      "last_quarter_moon_with_face"
    ],
    u: "1f31c"
  },
  {
    n: [
      "thermometer"
    ],
    u: "1f321-fe0f"
  },
  {
    n: [
      "black sun with rays",
      "sunny"
    ],
    u: "2600-fe0f"
  },
  {
    n: [
      "full moon with face",
      "full_moon_with_face"
    ],
    u: "1f31d"
  },
  {
    n: [
      "sun with face",
      "sun_with_face"
    ],
    u: "1f31e"
  },
  {
    n: [
      "white medium star",
      "star"
    ],
    u: "2b50"
  },
  {
    n: [
      "glowing star",
      "star2"
    ],
    u: "1f31f"
  },
  {
    n: [
      "shooting star",
      "stars"
    ],
    u: "1f320"
  },
  {
    n: [
      "cloud"
    ],
    u: "2601-fe0f"
  },
  {
    n: [
      "sun behind cloud",
      "partly_sunny"
    ],
    u: "26c5"
  },
  {
    n: [
      "thunder_cloud_and_rain"
    ],
    u: "26c8-fe0f"
  },
  {
    n: [
      "mostly_sunny",
      "sun_small_cloud"
    ],
    u: "1f324-fe0f"
  },
  {
    n: [
      "barely_sunny",
      "sun_behind_cloud"
    ],
    u: "1f325-fe0f"
  },
  {
    n: [
      "partly_sunny_rain",
      "sun_behind_rain_cloud"
    ],
    u: "1f326-fe0f"
  },
  {
    n: [
      "rain_cloud"
    ],
    u: "1f327-fe0f"
  },
  {
    n: [
      "snow_cloud"
    ],
    u: "1f328-fe0f"
  },
  {
    n: [
      "lightning",
      "lightning_cloud"
    ],
    u: "1f329-fe0f"
  },
  {
    n: [
      "tornado",
      "tornado_cloud"
    ],
    u: "1f32a-fe0f"
  },
  {
    n: [
      "fog"
    ],
    u: "1f32b-fe0f"
  },
  {
    n: [
      "wind_blowing_face"
    ],
    u: "1f32c-fe0f"
  },
  {
    n: [
      "cyclone"
    ],
    u: "1f300"
  },
  {
    n: [
      "rainbow"
    ],
    u: "1f308"
  },
  {
    n: [
      "closed umbrella",
      "closed_umbrella"
    ],
    u: "1f302"
  },
  {
    n: [
      "umbrella"
    ],
    u: "2602-fe0f"
  },
  {
    n: [
      "umbrella with rain drops",
      "umbrella_with_rain_drops"
    ],
    u: "2614"
  },
  {
    n: [
      "umbrella_on_ground"
    ],
    u: "26f1-fe0f"
  },
  {
    n: [
      "high voltage sign",
      "zap"
    ],
    u: "26a1"
  },
  {
    n: [
      "snowflake"
    ],
    u: "2744-fe0f"
  },
  {
    n: [
      "snowman"
    ],
    u: "2603-fe0f"
  },
  {
    n: [
      "snowman without snow",
      "snowman_without_snow"
    ],
    u: "26c4"
  },
  {
    n: [
      "comet"
    ],
    u: "2604-fe0f"
  },
  {
    n: [
      "fire"
    ],
    u: "1f525"
  },
  {
    n: [
      "droplet"
    ],
    u: "1f4a7"
  },
  {
    n: [
      "water wave",
      "ocean"
    ],
    u: "1f30a"
  }
];
const objects$1 = [
  {
    n: [
      "speaker with cancellation stroke",
      "mute"
    ],
    u: "1f507"
  },
  {
    n: [
      "speaker"
    ],
    u: "1f508"
  },
  {
    n: [
      "speaker with one sound wave",
      "sound"
    ],
    u: "1f509"
  },
  {
    n: [
      "speaker with three sound waves",
      "loud_sound"
    ],
    u: "1f50a"
  },
  {
    n: [
      "public address loudspeaker",
      "loudspeaker"
    ],
    u: "1f4e2"
  },
  {
    n: [
      "cheering megaphone",
      "mega"
    ],
    u: "1f4e3"
  },
  {
    n: [
      "postal horn",
      "postal_horn"
    ],
    u: "1f4ef"
  },
  {
    n: [
      "bell"
    ],
    u: "1f514"
  },
  {
    n: [
      "bell with cancellation stroke",
      "no_bell"
    ],
    u: "1f515"
  },
  {
    n: [
      "musical score",
      "musical_score"
    ],
    u: "1f3bc"
  },
  {
    n: [
      "musical note",
      "musical_note"
    ],
    u: "1f3b5"
  },
  {
    n: [
      "multiple musical notes",
      "notes"
    ],
    u: "1f3b6"
  },
  {
    n: [
      "studio_microphone"
    ],
    u: "1f399-fe0f"
  },
  {
    n: [
      "level_slider"
    ],
    u: "1f39a-fe0f"
  },
  {
    n: [
      "control_knobs"
    ],
    u: "1f39b-fe0f"
  },
  {
    n: [
      "microphone"
    ],
    u: "1f3a4"
  },
  {
    n: [
      "headphone",
      "headphones"
    ],
    u: "1f3a7"
  },
  {
    n: [
      "radio"
    ],
    u: "1f4fb"
  },
  {
    n: [
      "saxophone"
    ],
    u: "1f3b7"
  },
  {
    n: [
      "guitar"
    ],
    u: "1f3b8"
  },
  {
    n: [
      "musical keyboard",
      "musical_keyboard"
    ],
    u: "1f3b9"
  },
  {
    n: [
      "trumpet"
    ],
    u: "1f3ba"
  },
  {
    n: [
      "violin"
    ],
    u: "1f3bb"
  },
  {
    n: [
      "drum with drumsticks",
      "drum_with_drumsticks"
    ],
    u: "1f941"
  },
  {
    n: [
      "mobile phone",
      "iphone"
    ],
    u: "1f4f1"
  },
  {
    n: [
      "mobile phone with rightwards arrow at left",
      "calling"
    ],
    u: "1f4f2"
  },
  {
    n: [
      "black telephone",
      "phone",
      "telephone"
    ],
    u: "260e-fe0f"
  },
  {
    n: [
      "telephone receiver",
      "telephone_receiver"
    ],
    u: "1f4de"
  },
  {
    n: [
      "pager"
    ],
    u: "1f4df"
  },
  {
    n: [
      "fax machine",
      "fax"
    ],
    u: "1f4e0"
  },
  {
    n: [
      "battery"
    ],
    u: "1f50b"
  },
  {
    n: [
      "electric plug",
      "electric_plug"
    ],
    u: "1f50c"
  },
  {
    n: [
      "personal computer",
      "computer"
    ],
    u: "1f4bb"
  },
  {
    n: [
      "desktop_computer"
    ],
    u: "1f5a5-fe0f"
  },
  {
    n: [
      "printer"
    ],
    u: "1f5a8-fe0f"
  },
  {
    n: [
      "keyboard"
    ],
    u: "2328-fe0f"
  },
  {
    n: [
      "three_button_mouse"
    ],
    u: "1f5b1-fe0f"
  },
  {
    n: [
      "trackball"
    ],
    u: "1f5b2-fe0f"
  },
  {
    n: [
      "minidisc"
    ],
    u: "1f4bd"
  },
  {
    n: [
      "floppy disk",
      "floppy_disk"
    ],
    u: "1f4be"
  },
  {
    n: [
      "optical disc",
      "cd"
    ],
    u: "1f4bf"
  },
  {
    n: [
      "dvd"
    ],
    u: "1f4c0"
  },
  {
    n: [
      "movie camera",
      "movie_camera"
    ],
    u: "1f3a5"
  },
  {
    n: [
      "film_frames"
    ],
    u: "1f39e-fe0f"
  },
  {
    n: [
      "film_projector"
    ],
    u: "1f4fd-fe0f"
  },
  {
    n: [
      "clapper board",
      "clapper"
    ],
    u: "1f3ac"
  },
  {
    n: [
      "television",
      "tv"
    ],
    u: "1f4fa"
  },
  {
    n: [
      "camera"
    ],
    u: "1f4f7"
  },
  {
    n: [
      "camera with flash",
      "camera_with_flash"
    ],
    u: "1f4f8"
  },
  {
    n: [
      "video camera",
      "video_camera"
    ],
    u: "1f4f9"
  },
  {
    n: [
      "videocassette",
      "vhs"
    ],
    u: "1f4fc"
  },
  {
    n: [
      "left-pointing magnifying glass",
      "mag"
    ],
    u: "1f50d"
  },
  {
    n: [
      "right-pointing magnifying glass",
      "mag_right"
    ],
    u: "1f50e"
  },
  {
    n: [
      "microscope"
    ],
    u: "1f52c"
  },
  {
    n: [
      "telescope"
    ],
    u: "1f52d"
  },
  {
    n: [
      "satellite antenna",
      "satellite_antenna"
    ],
    u: "1f4e1"
  },
  {
    n: [
      "candle"
    ],
    u: "1f56f-fe0f"
  },
  {
    n: [
      "electric light bulb",
      "bulb"
    ],
    u: "1f4a1"
  },
  {
    n: [
      "electric torch",
      "flashlight"
    ],
    u: "1f526"
  },
  {
    n: [
      "izakaya lantern",
      "izakaya_lantern",
      "lantern"
    ],
    u: "1f3ee"
  },
  {
    n: [
      "notebook with decorative cover",
      "notebook_with_decorative_cover"
    ],
    u: "1f4d4"
  },
  {
    n: [
      "closed book",
      "closed_book"
    ],
    u: "1f4d5"
  },
  {
    n: [
      "open book",
      "book",
      "open_book"
    ],
    u: "1f4d6"
  },
  {
    n: [
      "green book",
      "green_book"
    ],
    u: "1f4d7"
  },
  {
    n: [
      "blue book",
      "blue_book"
    ],
    u: "1f4d8"
  },
  {
    n: [
      "orange book",
      "orange_book"
    ],
    u: "1f4d9"
  },
  {
    n: [
      "books"
    ],
    u: "1f4da"
  },
  {
    n: [
      "notebook"
    ],
    u: "1f4d3"
  },
  {
    n: [
      "ledger"
    ],
    u: "1f4d2"
  },
  {
    n: [
      "page with curl",
      "page_with_curl"
    ],
    u: "1f4c3"
  },
  {
    n: [
      "scroll"
    ],
    u: "1f4dc"
  },
  {
    n: [
      "page facing up",
      "page_facing_up"
    ],
    u: "1f4c4"
  },
  {
    n: [
      "newspaper"
    ],
    u: "1f4f0"
  },
  {
    n: [
      "rolled_up_newspaper"
    ],
    u: "1f5de-fe0f"
  },
  {
    n: [
      "bookmark tabs",
      "bookmark_tabs"
    ],
    u: "1f4d1"
  },
  {
    n: [
      "bookmark"
    ],
    u: "1f516"
  },
  {
    n: [
      "label"
    ],
    u: "1f3f7-fe0f"
  },
  {
    n: [
      "money bag",
      "moneybag"
    ],
    u: "1f4b0"
  },
  {
    n: [
      "banknote with yen sign",
      "yen"
    ],
    u: "1f4b4"
  },
  {
    n: [
      "banknote with dollar sign",
      "dollar"
    ],
    u: "1f4b5"
  },
  {
    n: [
      "banknote with euro sign",
      "euro"
    ],
    u: "1f4b6"
  },
  {
    n: [
      "banknote with pound sign",
      "pound"
    ],
    u: "1f4b7"
  },
  {
    n: [
      "money with wings",
      "money_with_wings"
    ],
    u: "1f4b8"
  },
  {
    n: [
      "credit card",
      "credit_card"
    ],
    u: "1f4b3"
  },
  {
    n: [
      "chart with upwards trend and yen sign",
      "chart"
    ],
    u: "1f4b9"
  },
  {
    n: [
      "currency exchange",
      "currency_exchange"
    ],
    u: "1f4b1"
  },
  {
    n: [
      "heavy dollar sign",
      "heavy_dollar_sign"
    ],
    u: "1f4b2"
  },
  {
    n: [
      "envelope",
      "email"
    ],
    u: "2709-fe0f"
  },
  {
    n: [
      "e-mail symbol",
      "e-mail"
    ],
    u: "1f4e7"
  },
  {
    n: [
      "incoming envelope",
      "incoming_envelope"
    ],
    u: "1f4e8"
  },
  {
    n: [
      "envelope with downwards arrow above",
      "envelope_with_arrow"
    ],
    u: "1f4e9"
  },
  {
    n: [
      "outbox tray",
      "outbox_tray"
    ],
    u: "1f4e4"
  },
  {
    n: [
      "inbox tray",
      "inbox_tray"
    ],
    u: "1f4e5"
  },
  {
    n: [
      "package"
    ],
    u: "1f4e6"
  },
  {
    n: [
      "closed mailbox with raised flag",
      "mailbox"
    ],
    u: "1f4eb"
  },
  {
    n: [
      "closed mailbox with lowered flag",
      "mailbox_closed"
    ],
    u: "1f4ea"
  },
  {
    n: [
      "open mailbox with raised flag",
      "mailbox_with_mail"
    ],
    u: "1f4ec"
  },
  {
    n: [
      "open mailbox with lowered flag",
      "mailbox_with_no_mail"
    ],
    u: "1f4ed"
  },
  {
    n: [
      "postbox"
    ],
    u: "1f4ee"
  },
  {
    n: [
      "ballot_box_with_ballot"
    ],
    u: "1f5f3-fe0f"
  },
  {
    n: [
      "pencil",
      "pencil2"
    ],
    u: "270f-fe0f"
  },
  {
    n: [
      "black nib",
      "black_nib"
    ],
    u: "2712-fe0f"
  },
  {
    n: [
      "lower_left_fountain_pen"
    ],
    u: "1f58b-fe0f"
  },
  {
    n: [
      "lower_left_ballpoint_pen"
    ],
    u: "1f58a-fe0f"
  },
  {
    n: [
      "lower_left_paintbrush"
    ],
    u: "1f58c-fe0f"
  },
  {
    n: [
      "lower_left_crayon"
    ],
    u: "1f58d-fe0f"
  },
  {
    n: [
      "memo",
      "pencil"
    ],
    u: "1f4dd"
  },
  {
    n: [
      "briefcase"
    ],
    u: "1f4bc"
  },
  {
    n: [
      "file folder",
      "file_folder"
    ],
    u: "1f4c1"
  },
  {
    n: [
      "open file folder",
      "open_file_folder"
    ],
    u: "1f4c2"
  },
  {
    n: [
      "card_index_dividers"
    ],
    u: "1f5c2-fe0f"
  },
  {
    n: [
      "calendar",
      "date"
    ],
    u: "1f4c5"
  },
  {
    n: [
      "tear-off calendar",
      "calendar"
    ],
    u: "1f4c6"
  },
  {
    n: [
      "spiral_note_pad"
    ],
    u: "1f5d2-fe0f"
  },
  {
    n: [
      "spiral_calendar_pad"
    ],
    u: "1f5d3-fe0f"
  },
  {
    n: [
      "card index",
      "card_index"
    ],
    u: "1f4c7"
  },
  {
    n: [
      "chart with upwards trend",
      "chart_with_upwards_trend"
    ],
    u: "1f4c8"
  },
  {
    n: [
      "chart with downwards trend",
      "chart_with_downwards_trend"
    ],
    u: "1f4c9"
  },
  {
    n: [
      "bar chart",
      "bar_chart"
    ],
    u: "1f4ca"
  },
  {
    n: [
      "clipboard"
    ],
    u: "1f4cb"
  },
  {
    n: [
      "pushpin"
    ],
    u: "1f4cc"
  },
  {
    n: [
      "round pushpin",
      "round_pushpin"
    ],
    u: "1f4cd"
  },
  {
    n: [
      "paperclip"
    ],
    u: "1f4ce"
  },
  {
    n: [
      "linked_paperclips"
    ],
    u: "1f587-fe0f"
  },
  {
    n: [
      "straight ruler",
      "straight_ruler"
    ],
    u: "1f4cf"
  },
  {
    n: [
      "triangular ruler",
      "triangular_ruler"
    ],
    u: "1f4d0"
  },
  {
    n: [
      "black scissors",
      "scissors"
    ],
    u: "2702-fe0f"
  },
  {
    n: [
      "card_file_box"
    ],
    u: "1f5c3-fe0f"
  },
  {
    n: [
      "file_cabinet"
    ],
    u: "1f5c4-fe0f"
  },
  {
    n: [
      "wastebasket"
    ],
    u: "1f5d1-fe0f"
  },
  {
    n: [
      "lock"
    ],
    u: "1f512"
  },
  {
    n: [
      "open lock",
      "unlock"
    ],
    u: "1f513"
  },
  {
    n: [
      "lock with ink pen",
      "lock_with_ink_pen"
    ],
    u: "1f50f"
  },
  {
    n: [
      "closed lock with key",
      "closed_lock_with_key"
    ],
    u: "1f510"
  },
  {
    n: [
      "key"
    ],
    u: "1f511"
  },
  {
    n: [
      "old_key"
    ],
    u: "1f5dd-fe0f"
  },
  {
    n: [
      "hammer"
    ],
    u: "1f528"
  },
  {
    n: [
      "pick"
    ],
    u: "26cf-fe0f"
  },
  {
    n: [
      "hammer_and_pick"
    ],
    u: "2692-fe0f"
  },
  {
    n: [
      "hammer_and_wrench"
    ],
    u: "1f6e0-fe0f"
  },
  {
    n: [
      "dagger_knife"
    ],
    u: "1f5e1-fe0f"
  },
  {
    n: [
      "crossed_swords"
    ],
    u: "2694-fe0f"
  },
  {
    n: [
      "pistol",
      "gun"
    ],
    u: "1f52b"
  },
  {
    n: [
      "bow and arrow",
      "bow_and_arrow"
    ],
    u: "1f3f9"
  },
  {
    n: [
      "shield"
    ],
    u: "1f6e1-fe0f"
  },
  {
    n: [
      "wrench"
    ],
    u: "1f527"
  },
  {
    n: [
      "nut and bolt",
      "nut_and_bolt"
    ],
    u: "1f529"
  },
  {
    n: [
      "gear"
    ],
    u: "2699-fe0f"
  },
  {
    n: [
      "compression"
    ],
    u: "1f5dc-fe0f"
  },
  {
    n: [
      "alembic"
    ],
    u: "2697-fe0f"
  },
  {
    n: [
      "scales"
    ],
    u: "2696-fe0f"
  },
  {
    n: [
      "link symbol",
      "link"
    ],
    u: "1f517"
  },
  {
    n: [
      "chains"
    ],
    u: "26d3-fe0f"
  },
  {
    n: [
      "syringe"
    ],
    u: "1f489"
  },
  {
    n: [
      "pill"
    ],
    u: "1f48a"
  },
  {
    n: [
      "smoking symbol",
      "smoking"
    ],
    u: "1f6ac"
  },
  {
    n: [
      "coffin"
    ],
    u: "26b0-fe0f"
  },
  {
    n: [
      "funeral_urn"
    ],
    u: "26b1-fe0f"
  },
  {
    n: [
      "moyai"
    ],
    u: "1f5ff"
  },
  {
    n: [
      "oil_drum"
    ],
    u: "1f6e2-fe0f"
  },
  {
    n: [
      "crystal ball",
      "crystal_ball"
    ],
    u: "1f52e"
  },
  {
    n: [
      "shopping trolley",
      "shopping_trolley"
    ],
    u: "1f6d2"
  }
];
const symbols$1 = [
  {
    n: [
      "automated teller machine",
      "atm"
    ],
    u: "1f3e7"
  },
  {
    n: [
      "put litter in its place symbol",
      "put_litter_in_its_place"
    ],
    u: "1f6ae"
  },
  {
    n: [
      "potable water symbol",
      "potable_water"
    ],
    u: "1f6b0"
  },
  {
    n: [
      "wheelchair symbol",
      "wheelchair"
    ],
    u: "267f"
  },
  {
    n: [
      "mens symbol",
      "mens"
    ],
    u: "1f6b9"
  },
  {
    n: [
      "womens symbol",
      "womens"
    ],
    u: "1f6ba"
  },
  {
    n: [
      "restroom"
    ],
    u: "1f6bb"
  },
  {
    n: [
      "baby symbol",
      "baby_symbol"
    ],
    u: "1f6bc"
  },
  {
    n: [
      "water closet",
      "wc"
    ],
    u: "1f6be"
  },
  {
    n: [
      "passport control",
      "passport_control"
    ],
    u: "1f6c2"
  },
  {
    n: [
      "customs"
    ],
    u: "1f6c3"
  },
  {
    n: [
      "baggage claim",
      "baggage_claim"
    ],
    u: "1f6c4"
  },
  {
    n: [
      "left luggage",
      "left_luggage"
    ],
    u: "1f6c5"
  },
  {
    n: [
      "warning sign",
      "warning"
    ],
    u: "26a0-fe0f"
  },
  {
    n: [
      "children crossing",
      "children_crossing"
    ],
    u: "1f6b8"
  },
  {
    n: [
      "no entry",
      "no_entry"
    ],
    u: "26d4"
  },
  {
    n: [
      "no entry sign",
      "no_entry_sign"
    ],
    u: "1f6ab"
  },
  {
    n: [
      "no bicycles",
      "no_bicycles"
    ],
    u: "1f6b3"
  },
  {
    n: [
      "no smoking symbol",
      "no_smoking"
    ],
    u: "1f6ad"
  },
  {
    n: [
      "do not litter symbol",
      "do_not_litter"
    ],
    u: "1f6af"
  },
  {
    n: [
      "non-potable water symbol",
      "non-potable_water"
    ],
    u: "1f6b1"
  },
  {
    n: [
      "no pedestrians",
      "no_pedestrians"
    ],
    u: "1f6b7"
  },
  {
    n: [
      "no mobile phones",
      "no_mobile_phones"
    ],
    u: "1f4f5"
  },
  {
    n: [
      "no one under eighteen symbol",
      "underage"
    ],
    u: "1f51e"
  },
  {
    n: [
      "radioactive_sign"
    ],
    u: "2622-fe0f"
  },
  {
    n: [
      "biohazard_sign"
    ],
    u: "2623-fe0f"
  },
  {
    n: [
      "upwards black arrow",
      "arrow_up"
    ],
    u: "2b06-fe0f"
  },
  {
    n: [
      "north east arrow",
      "arrow_upper_right"
    ],
    u: "2197-fe0f"
  },
  {
    n: [
      "black rightwards arrow",
      "arrow_right"
    ],
    u: "27a1-fe0f"
  },
  {
    n: [
      "south east arrow",
      "arrow_lower_right"
    ],
    u: "2198-fe0f"
  },
  {
    n: [
      "downwards black arrow",
      "arrow_down"
    ],
    u: "2b07-fe0f"
  },
  {
    n: [
      "south west arrow",
      "arrow_lower_left"
    ],
    u: "2199-fe0f"
  },
  {
    n: [
      "leftwards black arrow",
      "arrow_left"
    ],
    u: "2b05-fe0f"
  },
  {
    n: [
      "north west arrow",
      "arrow_upper_left"
    ],
    u: "2196-fe0f"
  },
  {
    n: [
      "up down arrow",
      "arrow_up_down"
    ],
    u: "2195-fe0f"
  },
  {
    n: [
      "left right arrow",
      "left_right_arrow"
    ],
    u: "2194-fe0f"
  },
  {
    n: [
      "leftwards arrow with hook",
      "leftwards_arrow_with_hook"
    ],
    u: "21a9-fe0f"
  },
  {
    n: [
      "rightwards arrow with hook",
      "arrow_right_hook"
    ],
    u: "21aa-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving upwards",
      "arrow_heading_up"
    ],
    u: "2934-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving downwards",
      "arrow_heading_down"
    ],
    u: "2935-fe0f"
  },
  {
    n: [
      "clockwise downwards and upwards open circle arrows",
      "arrows_clockwise"
    ],
    u: "1f503"
  },
  {
    n: [
      "anticlockwise downwards and upwards open circle arrows",
      "arrows_counterclockwise"
    ],
    u: "1f504"
  },
  {
    n: [
      "back with leftwards arrow above",
      "back"
    ],
    u: "1f519"
  },
  {
    n: [
      "end with leftwards arrow above",
      "end"
    ],
    u: "1f51a"
  },
  {
    n: [
      "on with exclamation mark with left right arrow above",
      "on"
    ],
    u: "1f51b"
  },
  {
    n: [
      "soon with rightwards arrow above",
      "soon"
    ],
    u: "1f51c"
  },
  {
    n: [
      "top with upwards arrow above",
      "top"
    ],
    u: "1f51d"
  },
  {
    n: [
      "place of worship",
      "place_of_worship"
    ],
    u: "1f6d0"
  },
  {
    n: [
      "atom_symbol"
    ],
    u: "269b-fe0f"
  },
  {
    n: [
      "om_symbol"
    ],
    u: "1f549-fe0f"
  },
  {
    n: [
      "star_of_david"
    ],
    u: "2721-fe0f"
  },
  {
    n: [
      "wheel_of_dharma"
    ],
    u: "2638-fe0f"
  },
  {
    n: [
      "yin_yang"
    ],
    u: "262f-fe0f"
  },
  {
    n: [
      "latin_cross"
    ],
    u: "271d-fe0f"
  },
  {
    n: [
      "orthodox_cross"
    ],
    u: "2626-fe0f"
  },
  {
    n: [
      "star_and_crescent"
    ],
    u: "262a-fe0f"
  },
  {
    n: [
      "peace_symbol"
    ],
    u: "262e-fe0f"
  },
  {
    n: [
      "menorah with nine branches",
      "menorah_with_nine_branches"
    ],
    u: "1f54e"
  },
  {
    n: [
      "six pointed star with middle dot",
      "six_pointed_star"
    ],
    u: "1f52f"
  },
  {
    n: [
      "aries"
    ],
    u: "2648"
  },
  {
    n: [
      "taurus"
    ],
    u: "2649"
  },
  {
    n: [
      "gemini"
    ],
    u: "264a"
  },
  {
    n: [
      "cancer"
    ],
    u: "264b"
  },
  {
    n: [
      "leo"
    ],
    u: "264c"
  },
  {
    n: [
      "virgo"
    ],
    u: "264d"
  },
  {
    n: [
      "libra"
    ],
    u: "264e"
  },
  {
    n: [
      "scorpius"
    ],
    u: "264f"
  },
  {
    n: [
      "sagittarius"
    ],
    u: "2650"
  },
  {
    n: [
      "capricorn"
    ],
    u: "2651"
  },
  {
    n: [
      "aquarius"
    ],
    u: "2652"
  },
  {
    n: [
      "pisces"
    ],
    u: "2653"
  },
  {
    n: [
      "ophiuchus"
    ],
    u: "26ce"
  },
  {
    n: [
      "twisted rightwards arrows",
      "twisted_rightwards_arrows"
    ],
    u: "1f500"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows",
      "repeat"
    ],
    u: "1f501"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows with circled one overlay",
      "repeat_one"
    ],
    u: "1f502"
  },
  {
    n: [
      "black right-pointing triangle",
      "arrow_forward"
    ],
    u: "25b6-fe0f"
  },
  {
    n: [
      "black right-pointing double triangle",
      "fast_forward"
    ],
    u: "23e9"
  },
  {
    n: [
      "black_right_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ed-fe0f"
  },
  {
    n: [
      "black_right_pointing_triangle_with_double_vertical_bar"
    ],
    u: "23ef-fe0f"
  },
  {
    n: [
      "black left-pointing triangle",
      "arrow_backward"
    ],
    u: "25c0-fe0f"
  },
  {
    n: [
      "black left-pointing double triangle",
      "rewind"
    ],
    u: "23ea"
  },
  {
    n: [
      "black_left_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ee-fe0f"
  },
  {
    n: [
      "up-pointing small red triangle",
      "arrow_up_small"
    ],
    u: "1f53c"
  },
  {
    n: [
      "black up-pointing double triangle",
      "arrow_double_up"
    ],
    u: "23eb"
  },
  {
    n: [
      "down-pointing small red triangle",
      "arrow_down_small"
    ],
    u: "1f53d"
  },
  {
    n: [
      "black down-pointing double triangle",
      "arrow_double_down"
    ],
    u: "23ec"
  },
  {
    n: [
      "double_vertical_bar"
    ],
    u: "23f8-fe0f"
  },
  {
    n: [
      "black_square_for_stop"
    ],
    u: "23f9-fe0f"
  },
  {
    n: [
      "black_circle_for_record"
    ],
    u: "23fa-fe0f"
  },
  {
    n: [
      "eject"
    ],
    u: "23cf-fe0f"
  },
  {
    n: [
      "cinema"
    ],
    u: "1f3a6"
  },
  {
    n: [
      "low brightness symbol",
      "low_brightness"
    ],
    u: "1f505"
  },
  {
    n: [
      "high brightness symbol",
      "high_brightness"
    ],
    u: "1f506"
  },
  {
    n: [
      "antenna with bars",
      "signal_strength"
    ],
    u: "1f4f6"
  },
  {
    n: [
      "vibration mode",
      "vibration_mode"
    ],
    u: "1f4f3"
  },
  {
    n: [
      "mobile phone off",
      "mobile_phone_off"
    ],
    u: "1f4f4"
  },
  {
    n: [
      "female_sign"
    ],
    u: "2640-fe0f"
  },
  {
    n: [
      "male_sign"
    ],
    u: "2642-fe0f"
  },
  {
    n: [
      "medical_symbol",
      "staff_of_aesculapius"
    ],
    u: "2695-fe0f"
  },
  {
    n: [
      "black universal recycling symbol",
      "recycle"
    ],
    u: "267b-fe0f"
  },
  {
    n: [
      "fleur_de_lis"
    ],
    u: "269c-fe0f"
  },
  {
    n: [
      "trident emblem",
      "trident"
    ],
    u: "1f531"
  },
  {
    n: [
      "name badge",
      "name_badge"
    ],
    u: "1f4db"
  },
  {
    n: [
      "japanese symbol for beginner",
      "beginner"
    ],
    u: "1f530"
  },
  {
    n: [
      "heavy large circle",
      "o"
    ],
    u: "2b55"
  },
  {
    n: [
      "white heavy check mark",
      "white_check_mark"
    ],
    u: "2705"
  },
  {
    n: [
      "ballot box with check",
      "ballot_box_with_check"
    ],
    u: "2611-fe0f"
  },
  {
    n: [
      "heavy check mark",
      "heavy_check_mark"
    ],
    u: "2714-fe0f"
  },
  {
    n: [
      "heavy multiplication x",
      "heavy_multiplication_x"
    ],
    u: "2716-fe0f"
  },
  {
    n: [
      "cross mark",
      "x"
    ],
    u: "274c"
  },
  {
    n: [
      "negative squared cross mark",
      "negative_squared_cross_mark"
    ],
    u: "274e"
  },
  {
    n: [
      "heavy plus sign",
      "heavy_plus_sign"
    ],
    u: "2795"
  },
  {
    n: [
      "heavy minus sign",
      "heavy_minus_sign"
    ],
    u: "2796"
  },
  {
    n: [
      "heavy division sign",
      "heavy_division_sign"
    ],
    u: "2797"
  },
  {
    n: [
      "curly loop",
      "curly_loop"
    ],
    u: "27b0"
  },
  {
    n: [
      "double curly loop",
      "loop"
    ],
    u: "27bf"
  },
  {
    n: [
      "part alternation mark",
      "part_alternation_mark"
    ],
    u: "303d-fe0f"
  },
  {
    n: [
      "eight spoked asterisk",
      "eight_spoked_asterisk"
    ],
    u: "2733-fe0f"
  },
  {
    n: [
      "eight pointed black star",
      "eight_pointed_black_star"
    ],
    u: "2734-fe0f"
  },
  {
    n: [
      "sparkle"
    ],
    u: "2747-fe0f"
  },
  {
    n: [
      "double exclamation mark",
      "bangbang"
    ],
    u: "203c-fe0f"
  },
  {
    n: [
      "exclamation question mark",
      "interrobang"
    ],
    u: "2049-fe0f"
  },
  {
    n: [
      "black question mark ornament",
      "question"
    ],
    u: "2753"
  },
  {
    n: [
      "white question mark ornament",
      "grey_question"
    ],
    u: "2754"
  },
  {
    n: [
      "white exclamation mark ornament",
      "grey_exclamation"
    ],
    u: "2755"
  },
  {
    n: [
      "heavy exclamation mark symbol",
      "exclamation",
      "heavy_exclamation_mark"
    ],
    u: "2757"
  },
  {
    n: [
      "wavy dash",
      "wavy_dash"
    ],
    u: "3030-fe0f"
  },
  {
    n: [
      "copyright sign",
      "copyright"
    ],
    u: "00a9-fe0f"
  },
  {
    n: [
      "registered sign",
      "registered"
    ],
    u: "00ae-fe0f"
  },
  {
    n: [
      "trade mark sign",
      "tm"
    ],
    u: "2122-fe0f"
  },
  {
    n: [
      "hash key",
      "hash"
    ],
    u: "0023-fe0f-20e3"
  },
  {
    n: [
      "keycap_star"
    ],
    u: "002a-fe0f-20e3"
  },
  {
    n: [
      "keycap 0",
      "zero"
    ],
    u: "0030-fe0f-20e3"
  },
  {
    n: [
      "keycap 1",
      "one"
    ],
    u: "0031-fe0f-20e3"
  },
  {
    n: [
      "keycap 2",
      "two"
    ],
    u: "0032-fe0f-20e3"
  },
  {
    n: [
      "keycap 3",
      "three"
    ],
    u: "0033-fe0f-20e3"
  },
  {
    n: [
      "keycap 4",
      "four"
    ],
    u: "0034-fe0f-20e3"
  },
  {
    n: [
      "keycap 5",
      "five"
    ],
    u: "0035-fe0f-20e3"
  },
  {
    n: [
      "keycap 6",
      "six"
    ],
    u: "0036-fe0f-20e3"
  },
  {
    n: [
      "keycap 7",
      "seven"
    ],
    u: "0037-fe0f-20e3"
  },
  {
    n: [
      "keycap 8",
      "eight"
    ],
    u: "0038-fe0f-20e3"
  },
  {
    n: [
      "keycap 9",
      "nine"
    ],
    u: "0039-fe0f-20e3"
  },
  {
    n: [
      "keycap ten",
      "keycap_ten"
    ],
    u: "1f51f"
  },
  {
    n: [
      "hundred points symbol",
      "100"
    ],
    u: "1f4af"
  },
  {
    n: [
      "input symbol for latin capital letters",
      "capital_abcd"
    ],
    u: "1f520"
  },
  {
    n: [
      "input symbol for latin small letters",
      "abcd"
    ],
    u: "1f521"
  },
  {
    n: [
      "input symbol for numbers",
      "1234"
    ],
    u: "1f522"
  },
  {
    n: [
      "input symbol for symbols",
      "symbols"
    ],
    u: "1f523"
  },
  {
    n: [
      "input symbol for latin letters",
      "abc"
    ],
    u: "1f524"
  },
  {
    n: [
      "negative squared latin capital letter a",
      "a"
    ],
    u: "1f170-fe0f"
  },
  {
    n: [
      "negative squared ab",
      "ab"
    ],
    u: "1f18e"
  },
  {
    n: [
      "negative squared latin capital letter b",
      "b"
    ],
    u: "1f171-fe0f"
  },
  {
    n: [
      "squared cl",
      "cl"
    ],
    u: "1f191"
  },
  {
    n: [
      "squared cool",
      "cool"
    ],
    u: "1f192"
  },
  {
    n: [
      "squared free",
      "free"
    ],
    u: "1f193"
  },
  {
    n: [
      "information source",
      "information_source"
    ],
    u: "2139-fe0f"
  },
  {
    n: [
      "squared id",
      "id"
    ],
    u: "1f194"
  },
  {
    n: [
      "circled latin capital letter m",
      "m"
    ],
    u: "24c2-fe0f"
  },
  {
    n: [
      "squared new",
      "new"
    ],
    u: "1f195"
  },
  {
    n: [
      "squared ng",
      "ng"
    ],
    u: "1f196"
  },
  {
    n: [
      "negative squared latin capital letter o",
      "o2"
    ],
    u: "1f17e-fe0f"
  },
  {
    n: [
      "squared ok",
      "ok"
    ],
    u: "1f197"
  },
  {
    n: [
      "negative squared latin capital letter p",
      "parking"
    ],
    u: "1f17f-fe0f"
  },
  {
    n: [
      "squared sos",
      "sos"
    ],
    u: "1f198"
  },
  {
    n: [
      "squared up with exclamation mark",
      "up"
    ],
    u: "1f199"
  },
  {
    n: [
      "squared vs",
      "vs"
    ],
    u: "1f19a"
  },
  {
    n: [
      "squared katakana koko",
      "koko"
    ],
    u: "1f201"
  },
  {
    n: [
      "squared katakana sa",
      "sa"
    ],
    u: "1f202-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6708",
      "u6708"
    ],
    u: "1f237-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6709",
      "u6709"
    ],
    u: "1f236"
  },
  {
    n: [
      "squared cjk unified ideograph-6307",
      "u6307"
    ],
    u: "1f22f"
  },
  {
    n: [
      "circled ideograph advantage",
      "ideograph_advantage"
    ],
    u: "1f250"
  },
  {
    n: [
      "squared cjk unified ideograph-5272",
      "u5272"
    ],
    u: "1f239"
  },
  {
    n: [
      "squared cjk unified ideograph-7121",
      "u7121"
    ],
    u: "1f21a"
  },
  {
    n: [
      "squared cjk unified ideograph-7981",
      "u7981"
    ],
    u: "1f232"
  },
  {
    n: [
      "circled ideograph accept",
      "accept"
    ],
    u: "1f251"
  },
  {
    n: [
      "squared cjk unified ideograph-7533",
      "u7533"
    ],
    u: "1f238"
  },
  {
    n: [
      "squared cjk unified ideograph-5408",
      "u5408"
    ],
    u: "1f234"
  },
  {
    n: [
      "squared cjk unified ideograph-7a7a",
      "u7a7a"
    ],
    u: "1f233"
  },
  {
    n: [
      "circled ideograph congratulation",
      "congratulations"
    ],
    u: "3297-fe0f"
  },
  {
    n: [
      "circled ideograph secret",
      "secret"
    ],
    u: "3299-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-55b6",
      "u55b6"
    ],
    u: "1f23a"
  },
  {
    n: [
      "squared cjk unified ideograph-6e80",
      "u6e80"
    ],
    u: "1f235"
  },
  {
    n: [
      "black small square",
      "black_small_square"
    ],
    u: "25aa-fe0f"
  },
  {
    n: [
      "white small square",
      "white_small_square"
    ],
    u: "25ab-fe0f"
  },
  {
    n: [
      "white medium square",
      "white_medium_square"
    ],
    u: "25fb-fe0f"
  },
  {
    n: [
      "black medium square",
      "black_medium_square"
    ],
    u: "25fc-fe0f"
  },
  {
    n: [
      "white medium small square",
      "white_medium_small_square"
    ],
    u: "25fd"
  },
  {
    n: [
      "black medium small square",
      "black_medium_small_square"
    ],
    u: "25fe"
  },
  {
    n: [
      "black large square",
      "black_large_square"
    ],
    u: "2b1b"
  },
  {
    n: [
      "white large square",
      "white_large_square"
    ],
    u: "2b1c"
  },
  {
    n: [
      "large orange diamond",
      "large_orange_diamond"
    ],
    u: "1f536"
  },
  {
    n: [
      "large blue diamond",
      "large_blue_diamond"
    ],
    u: "1f537"
  },
  {
    n: [
      "small orange diamond",
      "small_orange_diamond"
    ],
    u: "1f538"
  },
  {
    n: [
      "small blue diamond",
      "small_blue_diamond"
    ],
    u: "1f539"
  },
  {
    n: [
      "up-pointing red triangle",
      "small_red_triangle"
    ],
    u: "1f53a"
  },
  {
    n: [
      "down-pointing red triangle",
      "small_red_triangle_down"
    ],
    u: "1f53b"
  },
  {
    n: [
      "diamond shape with a dot inside",
      "diamond_shape_with_a_dot_inside"
    ],
    u: "1f4a0"
  },
  {
    n: [
      "radio button",
      "radio_button"
    ],
    u: "1f518"
  },
  {
    n: [
      "black square button",
      "black_square_button"
    ],
    u: "1f532"
  },
  {
    n: [
      "white square button",
      "white_square_button"
    ],
    u: "1f533"
  },
  {
    n: [
      "medium white circle",
      "white_circle"
    ],
    u: "26aa"
  },
  {
    n: [
      "medium black circle",
      "black_circle"
    ],
    u: "26ab"
  },
  {
    n: [
      "large red circle",
      "red_circle"
    ],
    u: "1f534"
  },
  {
    n: [
      "large blue circle",
      "large_blue_circle"
    ],
    u: "1f535"
  }
];
const flags$1 = [
  {
    n: [
      "chequered flag",
      "checkered_flag"
    ],
    u: "1f3c1"
  },
  {
    n: [
      "triangular flag on post",
      "triangular_flag_on_post"
    ],
    u: "1f6a9"
  },
  {
    n: [
      "crossed flags",
      "crossed_flags"
    ],
    u: "1f38c"
  },
  {
    n: [
      "waving black flag",
      "waving_black_flag"
    ],
    u: "1f3f4"
  },
  {
    n: [
      "waving_white_flag"
    ],
    u: "1f3f3-fe0f"
  },
  {
    n: [
      "rainbow-flag"
    ],
    u: "1f3f3-fe0f-200d-1f308"
  },
  {
    n: [
      "ascension island flag",
      "flag-ac"
    ],
    u: "1f1e6-1f1e8"
  },
  {
    n: [
      "andorra flag",
      "flag-ad"
    ],
    u: "1f1e6-1f1e9"
  },
  {
    n: [
      "united arab emirates flag",
      "flag-ae"
    ],
    u: "1f1e6-1f1ea"
  },
  {
    n: [
      "afghanistan flag",
      "flag-af"
    ],
    u: "1f1e6-1f1eb"
  },
  {
    n: [
      "antigua & barbuda flag",
      "flag-ag"
    ],
    u: "1f1e6-1f1ec"
  },
  {
    n: [
      "anguilla flag",
      "flag-ai"
    ],
    u: "1f1e6-1f1ee"
  },
  {
    n: [
      "albania flag",
      "flag-al"
    ],
    u: "1f1e6-1f1f1"
  },
  {
    n: [
      "armenia flag",
      "flag-am"
    ],
    u: "1f1e6-1f1f2"
  },
  {
    n: [
      "angola flag",
      "flag-ao"
    ],
    u: "1f1e6-1f1f4"
  },
  {
    n: [
      "antarctica flag",
      "flag-aq"
    ],
    u: "1f1e6-1f1f6"
  },
  {
    n: [
      "argentina flag",
      "flag-ar"
    ],
    u: "1f1e6-1f1f7"
  },
  {
    n: [
      "american samoa flag",
      "flag-as"
    ],
    u: "1f1e6-1f1f8"
  },
  {
    n: [
      "austria flag",
      "flag-at"
    ],
    u: "1f1e6-1f1f9"
  },
  {
    n: [
      "australia flag",
      "flag-au"
    ],
    u: "1f1e6-1f1fa"
  },
  {
    n: [
      "aruba flag",
      "flag-aw"
    ],
    u: "1f1e6-1f1fc"
  },
  {
    n: [
      "åland islands flag",
      "flag-ax"
    ],
    u: "1f1e6-1f1fd"
  },
  {
    n: [
      "azerbaijan flag",
      "flag-az"
    ],
    u: "1f1e6-1f1ff"
  },
  {
    n: [
      "bosnia & herzegovina flag",
      "flag-ba"
    ],
    u: "1f1e7-1f1e6"
  },
  {
    n: [
      "barbados flag",
      "flag-bb"
    ],
    u: "1f1e7-1f1e7"
  },
  {
    n: [
      "bangladesh flag",
      "flag-bd"
    ],
    u: "1f1e7-1f1e9"
  },
  {
    n: [
      "belgium flag",
      "flag-be"
    ],
    u: "1f1e7-1f1ea"
  },
  {
    n: [
      "burkina faso flag",
      "flag-bf"
    ],
    u: "1f1e7-1f1eb"
  },
  {
    n: [
      "bulgaria flag",
      "flag-bg"
    ],
    u: "1f1e7-1f1ec"
  },
  {
    n: [
      "bahrain flag",
      "flag-bh"
    ],
    u: "1f1e7-1f1ed"
  },
  {
    n: [
      "burundi flag",
      "flag-bi"
    ],
    u: "1f1e7-1f1ee"
  },
  {
    n: [
      "benin flag",
      "flag-bj"
    ],
    u: "1f1e7-1f1ef"
  },
  {
    n: [
      "st. barthélemy flag",
      "flag-bl"
    ],
    u: "1f1e7-1f1f1"
  },
  {
    n: [
      "bermuda flag",
      "flag-bm"
    ],
    u: "1f1e7-1f1f2"
  },
  {
    n: [
      "brunei flag",
      "flag-bn"
    ],
    u: "1f1e7-1f1f3"
  },
  {
    n: [
      "bolivia flag",
      "flag-bo"
    ],
    u: "1f1e7-1f1f4"
  },
  {
    n: [
      "caribbean netherlands flag",
      "flag-bq"
    ],
    u: "1f1e7-1f1f6"
  },
  {
    n: [
      "brazil flag",
      "flag-br"
    ],
    u: "1f1e7-1f1f7"
  },
  {
    n: [
      "bahamas flag",
      "flag-bs"
    ],
    u: "1f1e7-1f1f8"
  },
  {
    n: [
      "bhutan flag",
      "flag-bt"
    ],
    u: "1f1e7-1f1f9"
  },
  {
    n: [
      "bouvet island flag",
      "flag-bv"
    ],
    u: "1f1e7-1f1fb"
  },
  {
    n: [
      "botswana flag",
      "flag-bw"
    ],
    u: "1f1e7-1f1fc"
  },
  {
    n: [
      "belarus flag",
      "flag-by"
    ],
    u: "1f1e7-1f1fe"
  },
  {
    n: [
      "belize flag",
      "flag-bz"
    ],
    u: "1f1e7-1f1ff"
  },
  {
    n: [
      "canada flag",
      "flag-ca"
    ],
    u: "1f1e8-1f1e6"
  },
  {
    n: [
      "cocos (keeling) islands flag",
      "flag-cc"
    ],
    u: "1f1e8-1f1e8"
  },
  {
    n: [
      "congo - kinshasa flag",
      "flag-cd"
    ],
    u: "1f1e8-1f1e9"
  },
  {
    n: [
      "central african republic flag",
      "flag-cf"
    ],
    u: "1f1e8-1f1eb"
  },
  {
    n: [
      "congo - brazzaville flag",
      "flag-cg"
    ],
    u: "1f1e8-1f1ec"
  },
  {
    n: [
      "switzerland flag",
      "flag-ch"
    ],
    u: "1f1e8-1f1ed"
  },
  {
    n: [
      "côte d’ivoire flag",
      "flag-ci"
    ],
    u: "1f1e8-1f1ee"
  },
  {
    n: [
      "cook islands flag",
      "flag-ck"
    ],
    u: "1f1e8-1f1f0"
  },
  {
    n: [
      "chile flag",
      "flag-cl"
    ],
    u: "1f1e8-1f1f1"
  },
  {
    n: [
      "cameroon flag",
      "flag-cm"
    ],
    u: "1f1e8-1f1f2"
  },
  {
    n: [
      "china flag",
      "cn",
      "flag-cn"
    ],
    u: "1f1e8-1f1f3"
  },
  {
    n: [
      "colombia flag",
      "flag-co"
    ],
    u: "1f1e8-1f1f4"
  },
  {
    n: [
      "clipperton island flag",
      "flag-cp"
    ],
    u: "1f1e8-1f1f5"
  },
  {
    n: [
      "costa rica flag",
      "flag-cr"
    ],
    u: "1f1e8-1f1f7"
  },
  {
    n: [
      "cuba flag",
      "flag-cu"
    ],
    u: "1f1e8-1f1fa"
  },
  {
    n: [
      "cape verde flag",
      "flag-cv"
    ],
    u: "1f1e8-1f1fb"
  },
  {
    n: [
      "curaçao flag",
      "flag-cw"
    ],
    u: "1f1e8-1f1fc"
  },
  {
    n: [
      "christmas island flag",
      "flag-cx"
    ],
    u: "1f1e8-1f1fd"
  },
  {
    n: [
      "cyprus flag",
      "flag-cy"
    ],
    u: "1f1e8-1f1fe"
  },
  {
    n: [
      "czechia flag",
      "flag-cz"
    ],
    u: "1f1e8-1f1ff"
  },
  {
    n: [
      "germany flag",
      "de",
      "flag-de"
    ],
    u: "1f1e9-1f1ea"
  },
  {
    n: [
      "diego garcia flag",
      "flag-dg"
    ],
    u: "1f1e9-1f1ec"
  },
  {
    n: [
      "djibouti flag",
      "flag-dj"
    ],
    u: "1f1e9-1f1ef"
  },
  {
    n: [
      "denmark flag",
      "flag-dk"
    ],
    u: "1f1e9-1f1f0"
  },
  {
    n: [
      "dominica flag",
      "flag-dm"
    ],
    u: "1f1e9-1f1f2"
  },
  {
    n: [
      "dominican republic flag",
      "flag-do"
    ],
    u: "1f1e9-1f1f4"
  },
  {
    n: [
      "algeria flag",
      "flag-dz"
    ],
    u: "1f1e9-1f1ff"
  },
  {
    n: [
      "ceuta & melilla flag",
      "flag-ea"
    ],
    u: "1f1ea-1f1e6"
  },
  {
    n: [
      "ecuador flag",
      "flag-ec"
    ],
    u: "1f1ea-1f1e8"
  },
  {
    n: [
      "estonia flag",
      "flag-ee"
    ],
    u: "1f1ea-1f1ea"
  },
  {
    n: [
      "egypt flag",
      "flag-eg"
    ],
    u: "1f1ea-1f1ec"
  },
  {
    n: [
      "western sahara flag",
      "flag-eh"
    ],
    u: "1f1ea-1f1ed"
  },
  {
    n: [
      "eritrea flag",
      "flag-er"
    ],
    u: "1f1ea-1f1f7"
  },
  {
    n: [
      "spain flag",
      "es",
      "flag-es"
    ],
    u: "1f1ea-1f1f8"
  },
  {
    n: [
      "ethiopia flag",
      "flag-et"
    ],
    u: "1f1ea-1f1f9"
  },
  {
    n: [
      "european union flag",
      "flag-eu"
    ],
    u: "1f1ea-1f1fa"
  },
  {
    n: [
      "finland flag",
      "flag-fi"
    ],
    u: "1f1eb-1f1ee"
  },
  {
    n: [
      "fiji flag",
      "flag-fj"
    ],
    u: "1f1eb-1f1ef"
  },
  {
    n: [
      "falkland islands flag",
      "flag-fk"
    ],
    u: "1f1eb-1f1f0"
  },
  {
    n: [
      "micronesia flag",
      "flag-fm"
    ],
    u: "1f1eb-1f1f2"
  },
  {
    n: [
      "faroe islands flag",
      "flag-fo"
    ],
    u: "1f1eb-1f1f4"
  },
  {
    n: [
      "france flag",
      "fr",
      "flag-fr"
    ],
    u: "1f1eb-1f1f7"
  },
  {
    n: [
      "gabon flag",
      "flag-ga"
    ],
    u: "1f1ec-1f1e6"
  },
  {
    n: [
      "united kingdom flag",
      "gb",
      "uk",
      "flag-gb"
    ],
    u: "1f1ec-1f1e7"
  },
  {
    n: [
      "grenada flag",
      "flag-gd"
    ],
    u: "1f1ec-1f1e9"
  },
  {
    n: [
      "georgia flag",
      "flag-ge"
    ],
    u: "1f1ec-1f1ea"
  },
  {
    n: [
      "french guiana flag",
      "flag-gf"
    ],
    u: "1f1ec-1f1eb"
  },
  {
    n: [
      "guernsey flag",
      "flag-gg"
    ],
    u: "1f1ec-1f1ec"
  },
  {
    n: [
      "ghana flag",
      "flag-gh"
    ],
    u: "1f1ec-1f1ed"
  },
  {
    n: [
      "gibraltar flag",
      "flag-gi"
    ],
    u: "1f1ec-1f1ee"
  },
  {
    n: [
      "greenland flag",
      "flag-gl"
    ],
    u: "1f1ec-1f1f1"
  },
  {
    n: [
      "gambia flag",
      "flag-gm"
    ],
    u: "1f1ec-1f1f2"
  },
  {
    n: [
      "guinea flag",
      "flag-gn"
    ],
    u: "1f1ec-1f1f3"
  },
  {
    n: [
      "guadeloupe flag",
      "flag-gp"
    ],
    u: "1f1ec-1f1f5"
  },
  {
    n: [
      "equatorial guinea flag",
      "flag-gq"
    ],
    u: "1f1ec-1f1f6"
  },
  {
    n: [
      "greece flag",
      "flag-gr"
    ],
    u: "1f1ec-1f1f7"
  },
  {
    n: [
      "south georgia & south sandwich islands flag",
      "flag-gs"
    ],
    u: "1f1ec-1f1f8"
  },
  {
    n: [
      "guatemala flag",
      "flag-gt"
    ],
    u: "1f1ec-1f1f9"
  },
  {
    n: [
      "guam flag",
      "flag-gu"
    ],
    u: "1f1ec-1f1fa"
  },
  {
    n: [
      "guinea-bissau flag",
      "flag-gw"
    ],
    u: "1f1ec-1f1fc"
  },
  {
    n: [
      "guyana flag",
      "flag-gy"
    ],
    u: "1f1ec-1f1fe"
  },
  {
    n: [
      "hong kong sar china flag",
      "flag-hk"
    ],
    u: "1f1ed-1f1f0"
  },
  {
    n: [
      "heard & mcdonald islands flag",
      "flag-hm"
    ],
    u: "1f1ed-1f1f2"
  },
  {
    n: [
      "honduras flag",
      "flag-hn"
    ],
    u: "1f1ed-1f1f3"
  },
  {
    n: [
      "croatia flag",
      "flag-hr"
    ],
    u: "1f1ed-1f1f7"
  },
  {
    n: [
      "haiti flag",
      "flag-ht"
    ],
    u: "1f1ed-1f1f9"
  },
  {
    n: [
      "hungary flag",
      "flag-hu"
    ],
    u: "1f1ed-1f1fa"
  },
  {
    n: [
      "canary islands flag",
      "flag-ic"
    ],
    u: "1f1ee-1f1e8"
  },
  {
    n: [
      "indonesia flag",
      "flag-id"
    ],
    u: "1f1ee-1f1e9"
  },
  {
    n: [
      "ireland flag",
      "flag-ie"
    ],
    u: "1f1ee-1f1ea"
  },
  {
    n: [
      "israel flag",
      "flag-il"
    ],
    u: "1f1ee-1f1f1"
  },
  {
    n: [
      "isle of man flag",
      "flag-im"
    ],
    u: "1f1ee-1f1f2"
  },
  {
    n: [
      "india flag",
      "flag-in"
    ],
    u: "1f1ee-1f1f3"
  },
  {
    n: [
      "british indian ocean territory flag",
      "flag-io"
    ],
    u: "1f1ee-1f1f4"
  },
  {
    n: [
      "iraq flag",
      "flag-iq"
    ],
    u: "1f1ee-1f1f6"
  },
  {
    n: [
      "iran flag",
      "flag-ir"
    ],
    u: "1f1ee-1f1f7"
  },
  {
    n: [
      "iceland flag",
      "flag-is"
    ],
    u: "1f1ee-1f1f8"
  },
  {
    n: [
      "italy flag",
      "it",
      "flag-it"
    ],
    u: "1f1ee-1f1f9"
  },
  {
    n: [
      "jersey flag",
      "flag-je"
    ],
    u: "1f1ef-1f1ea"
  },
  {
    n: [
      "jamaica flag",
      "flag-jm"
    ],
    u: "1f1ef-1f1f2"
  },
  {
    n: [
      "jordan flag",
      "flag-jo"
    ],
    u: "1f1ef-1f1f4"
  },
  {
    n: [
      "japan flag",
      "jp",
      "flag-jp"
    ],
    u: "1f1ef-1f1f5"
  },
  {
    n: [
      "kenya flag",
      "flag-ke"
    ],
    u: "1f1f0-1f1ea"
  },
  {
    n: [
      "kyrgyzstan flag",
      "flag-kg"
    ],
    u: "1f1f0-1f1ec"
  },
  {
    n: [
      "cambodia flag",
      "flag-kh"
    ],
    u: "1f1f0-1f1ed"
  },
  {
    n: [
      "kiribati flag",
      "flag-ki"
    ],
    u: "1f1f0-1f1ee"
  },
  {
    n: [
      "comoros flag",
      "flag-km"
    ],
    u: "1f1f0-1f1f2"
  },
  {
    n: [
      "st. kitts & nevis flag",
      "flag-kn"
    ],
    u: "1f1f0-1f1f3"
  },
  {
    n: [
      "north korea flag",
      "flag-kp"
    ],
    u: "1f1f0-1f1f5"
  },
  {
    n: [
      "south korea flag",
      "kr",
      "flag-kr"
    ],
    u: "1f1f0-1f1f7"
  },
  {
    n: [
      "kuwait flag",
      "flag-kw"
    ],
    u: "1f1f0-1f1fc"
  },
  {
    n: [
      "cayman islands flag",
      "flag-ky"
    ],
    u: "1f1f0-1f1fe"
  },
  {
    n: [
      "kazakhstan flag",
      "flag-kz"
    ],
    u: "1f1f0-1f1ff"
  },
  {
    n: [
      "laos flag",
      "flag-la"
    ],
    u: "1f1f1-1f1e6"
  },
  {
    n: [
      "lebanon flag",
      "flag-lb"
    ],
    u: "1f1f1-1f1e7"
  },
  {
    n: [
      "st. lucia flag",
      "flag-lc"
    ],
    u: "1f1f1-1f1e8"
  },
  {
    n: [
      "liechtenstein flag",
      "flag-li"
    ],
    u: "1f1f1-1f1ee"
  },
  {
    n: [
      "sri lanka flag",
      "flag-lk"
    ],
    u: "1f1f1-1f1f0"
  },
  {
    n: [
      "liberia flag",
      "flag-lr"
    ],
    u: "1f1f1-1f1f7"
  },
  {
    n: [
      "lesotho flag",
      "flag-ls"
    ],
    u: "1f1f1-1f1f8"
  },
  {
    n: [
      "lithuania flag",
      "flag-lt"
    ],
    u: "1f1f1-1f1f9"
  },
  {
    n: [
      "luxembourg flag",
      "flag-lu"
    ],
    u: "1f1f1-1f1fa"
  },
  {
    n: [
      "latvia flag",
      "flag-lv"
    ],
    u: "1f1f1-1f1fb"
  },
  {
    n: [
      "libya flag",
      "flag-ly"
    ],
    u: "1f1f1-1f1fe"
  },
  {
    n: [
      "morocco flag",
      "flag-ma"
    ],
    u: "1f1f2-1f1e6"
  },
  {
    n: [
      "monaco flag",
      "flag-mc"
    ],
    u: "1f1f2-1f1e8"
  },
  {
    n: [
      "moldova flag",
      "flag-md"
    ],
    u: "1f1f2-1f1e9"
  },
  {
    n: [
      "montenegro flag",
      "flag-me"
    ],
    u: "1f1f2-1f1ea"
  },
  {
    n: [
      "st. martin flag",
      "flag-mf"
    ],
    u: "1f1f2-1f1eb"
  },
  {
    n: [
      "madagascar flag",
      "flag-mg"
    ],
    u: "1f1f2-1f1ec"
  },
  {
    n: [
      "marshall islands flag",
      "flag-mh"
    ],
    u: "1f1f2-1f1ed"
  },
  {
    n: [
      "macedonia flag",
      "flag-mk"
    ],
    u: "1f1f2-1f1f0"
  },
  {
    n: [
      "mali flag",
      "flag-ml"
    ],
    u: "1f1f2-1f1f1"
  },
  {
    n: [
      "myanmar (burma) flag",
      "flag-mm"
    ],
    u: "1f1f2-1f1f2"
  },
  {
    n: [
      "mongolia flag",
      "flag-mn"
    ],
    u: "1f1f2-1f1f3"
  },
  {
    n: [
      "macau sar china flag",
      "flag-mo"
    ],
    u: "1f1f2-1f1f4"
  },
  {
    n: [
      "northern mariana islands flag",
      "flag-mp"
    ],
    u: "1f1f2-1f1f5"
  },
  {
    n: [
      "martinique flag",
      "flag-mq"
    ],
    u: "1f1f2-1f1f6"
  },
  {
    n: [
      "mauritania flag",
      "flag-mr"
    ],
    u: "1f1f2-1f1f7"
  },
  {
    n: [
      "montserrat flag",
      "flag-ms"
    ],
    u: "1f1f2-1f1f8"
  },
  {
    n: [
      "malta flag",
      "flag-mt"
    ],
    u: "1f1f2-1f1f9"
  },
  {
    n: [
      "mauritius flag",
      "flag-mu"
    ],
    u: "1f1f2-1f1fa"
  },
  {
    n: [
      "maldives flag",
      "flag-mv"
    ],
    u: "1f1f2-1f1fb"
  },
  {
    n: [
      "malawi flag",
      "flag-mw"
    ],
    u: "1f1f2-1f1fc"
  },
  {
    n: [
      "mexico flag",
      "flag-mx"
    ],
    u: "1f1f2-1f1fd"
  },
  {
    n: [
      "malaysia flag",
      "flag-my"
    ],
    u: "1f1f2-1f1fe"
  },
  {
    n: [
      "mozambique flag",
      "flag-mz"
    ],
    u: "1f1f2-1f1ff"
  },
  {
    n: [
      "namibia flag",
      "flag-na"
    ],
    u: "1f1f3-1f1e6"
  },
  {
    n: [
      "new caledonia flag",
      "flag-nc"
    ],
    u: "1f1f3-1f1e8"
  },
  {
    n: [
      "niger flag",
      "flag-ne"
    ],
    u: "1f1f3-1f1ea"
  },
  {
    n: [
      "norfolk island flag",
      "flag-nf"
    ],
    u: "1f1f3-1f1eb"
  },
  {
    n: [
      "nigeria flag",
      "flag-ng"
    ],
    u: "1f1f3-1f1ec"
  },
  {
    n: [
      "nicaragua flag",
      "flag-ni"
    ],
    u: "1f1f3-1f1ee"
  },
  {
    n: [
      "netherlands flag",
      "flag-nl"
    ],
    u: "1f1f3-1f1f1"
  },
  {
    n: [
      "norway flag",
      "flag-no"
    ],
    u: "1f1f3-1f1f4"
  },
  {
    n: [
      "nepal flag",
      "flag-np"
    ],
    u: "1f1f3-1f1f5"
  },
  {
    n: [
      "nauru flag",
      "flag-nr"
    ],
    u: "1f1f3-1f1f7"
  },
  {
    n: [
      "niue flag",
      "flag-nu"
    ],
    u: "1f1f3-1f1fa"
  },
  {
    n: [
      "new zealand flag",
      "flag-nz"
    ],
    u: "1f1f3-1f1ff"
  },
  {
    n: [
      "oman flag",
      "flag-om"
    ],
    u: "1f1f4-1f1f2"
  },
  {
    n: [
      "panama flag",
      "flag-pa"
    ],
    u: "1f1f5-1f1e6"
  },
  {
    n: [
      "peru flag",
      "flag-pe"
    ],
    u: "1f1f5-1f1ea"
  },
  {
    n: [
      "french polynesia flag",
      "flag-pf"
    ],
    u: "1f1f5-1f1eb"
  },
  {
    n: [
      "papua new guinea flag",
      "flag-pg"
    ],
    u: "1f1f5-1f1ec"
  },
  {
    n: [
      "philippines flag",
      "flag-ph"
    ],
    u: "1f1f5-1f1ed"
  },
  {
    n: [
      "pakistan flag",
      "flag-pk"
    ],
    u: "1f1f5-1f1f0"
  },
  {
    n: [
      "poland flag",
      "flag-pl"
    ],
    u: "1f1f5-1f1f1"
  },
  {
    n: [
      "st. pierre & miquelon flag",
      "flag-pm"
    ],
    u: "1f1f5-1f1f2"
  },
  {
    n: [
      "pitcairn islands flag",
      "flag-pn"
    ],
    u: "1f1f5-1f1f3"
  },
  {
    n: [
      "puerto rico flag",
      "flag-pr"
    ],
    u: "1f1f5-1f1f7"
  },
  {
    n: [
      "palestinian territories flag",
      "flag-ps"
    ],
    u: "1f1f5-1f1f8"
  },
  {
    n: [
      "portugal flag",
      "flag-pt"
    ],
    u: "1f1f5-1f1f9"
  },
  {
    n: [
      "palau flag",
      "flag-pw"
    ],
    u: "1f1f5-1f1fc"
  },
  {
    n: [
      "paraguay flag",
      "flag-py"
    ],
    u: "1f1f5-1f1fe"
  },
  {
    n: [
      "qatar flag",
      "flag-qa"
    ],
    u: "1f1f6-1f1e6"
  },
  {
    n: [
      "réunion flag",
      "flag-re"
    ],
    u: "1f1f7-1f1ea"
  },
  {
    n: [
      "romania flag",
      "flag-ro"
    ],
    u: "1f1f7-1f1f4"
  },
  {
    n: [
      "serbia flag",
      "flag-rs"
    ],
    u: "1f1f7-1f1f8"
  },
  {
    n: [
      "russia flag",
      "ru",
      "flag-ru"
    ],
    u: "1f1f7-1f1fa"
  },
  {
    n: [
      "rwanda flag",
      "flag-rw"
    ],
    u: "1f1f7-1f1fc"
  },
  {
    n: [
      "saudi arabia flag",
      "flag-sa"
    ],
    u: "1f1f8-1f1e6"
  },
  {
    n: [
      "solomon islands flag",
      "flag-sb"
    ],
    u: "1f1f8-1f1e7"
  },
  {
    n: [
      "seychelles flag",
      "flag-sc"
    ],
    u: "1f1f8-1f1e8"
  },
  {
    n: [
      "sudan flag",
      "flag-sd"
    ],
    u: "1f1f8-1f1e9"
  },
  {
    n: [
      "sweden flag",
      "flag-se"
    ],
    u: "1f1f8-1f1ea"
  },
  {
    n: [
      "singapore flag",
      "flag-sg"
    ],
    u: "1f1f8-1f1ec"
  },
  {
    n: [
      "st. helena flag",
      "flag-sh"
    ],
    u: "1f1f8-1f1ed"
  },
  {
    n: [
      "slovenia flag",
      "flag-si"
    ],
    u: "1f1f8-1f1ee"
  },
  {
    n: [
      "svalbard & jan mayen flag",
      "flag-sj"
    ],
    u: "1f1f8-1f1ef"
  },
  {
    n: [
      "slovakia flag",
      "flag-sk"
    ],
    u: "1f1f8-1f1f0"
  },
  {
    n: [
      "sierra leone flag",
      "flag-sl"
    ],
    u: "1f1f8-1f1f1"
  },
  {
    n: [
      "san marino flag",
      "flag-sm"
    ],
    u: "1f1f8-1f1f2"
  },
  {
    n: [
      "senegal flag",
      "flag-sn"
    ],
    u: "1f1f8-1f1f3"
  },
  {
    n: [
      "somalia flag",
      "flag-so"
    ],
    u: "1f1f8-1f1f4"
  },
  {
    n: [
      "suriname flag",
      "flag-sr"
    ],
    u: "1f1f8-1f1f7"
  },
  {
    n: [
      "south sudan flag",
      "flag-ss"
    ],
    u: "1f1f8-1f1f8"
  },
  {
    n: [
      "são tomé & príncipe flag",
      "flag-st"
    ],
    u: "1f1f8-1f1f9"
  },
  {
    n: [
      "el salvador flag",
      "flag-sv"
    ],
    u: "1f1f8-1f1fb"
  },
  {
    n: [
      "sint maarten flag",
      "flag-sx"
    ],
    u: "1f1f8-1f1fd"
  },
  {
    n: [
      "syria flag",
      "flag-sy"
    ],
    u: "1f1f8-1f1fe"
  },
  {
    n: [
      "swaziland flag",
      "flag-sz"
    ],
    u: "1f1f8-1f1ff"
  },
  {
    n: [
      "tristan da cunha flag",
      "flag-ta"
    ],
    u: "1f1f9-1f1e6"
  },
  {
    n: [
      "turks & caicos islands flag",
      "flag-tc"
    ],
    u: "1f1f9-1f1e8"
  },
  {
    n: [
      "chad flag",
      "flag-td"
    ],
    u: "1f1f9-1f1e9"
  },
  {
    n: [
      "french southern territories flag",
      "flag-tf"
    ],
    u: "1f1f9-1f1eb"
  },
  {
    n: [
      "togo flag",
      "flag-tg"
    ],
    u: "1f1f9-1f1ec"
  },
  {
    n: [
      "thailand flag",
      "flag-th"
    ],
    u: "1f1f9-1f1ed"
  },
  {
    n: [
      "tajikistan flag",
      "flag-tj"
    ],
    u: "1f1f9-1f1ef"
  },
  {
    n: [
      "tokelau flag",
      "flag-tk"
    ],
    u: "1f1f9-1f1f0"
  },
  {
    n: [
      "timor-leste flag",
      "flag-tl"
    ],
    u: "1f1f9-1f1f1"
  },
  {
    n: [
      "turkmenistan flag",
      "flag-tm"
    ],
    u: "1f1f9-1f1f2"
  },
  {
    n: [
      "tunisia flag",
      "flag-tn"
    ],
    u: "1f1f9-1f1f3"
  },
  {
    n: [
      "tonga flag",
      "flag-to"
    ],
    u: "1f1f9-1f1f4"
  },
  {
    n: [
      "turkey flag",
      "flag-tr"
    ],
    u: "1f1f9-1f1f7"
  },
  {
    n: [
      "trinidad & tobago flag",
      "flag-tt"
    ],
    u: "1f1f9-1f1f9"
  },
  {
    n: [
      "tuvalu flag",
      "flag-tv"
    ],
    u: "1f1f9-1f1fb"
  },
  {
    n: [
      "taiwan flag",
      "flag-tw"
    ],
    u: "1f1f9-1f1fc"
  },
  {
    n: [
      "tanzania flag",
      "flag-tz"
    ],
    u: "1f1f9-1f1ff"
  },
  {
    n: [
      "ukraine flag",
      "flag-ua"
    ],
    u: "1f1fa-1f1e6"
  },
  {
    n: [
      "uganda flag",
      "flag-ug"
    ],
    u: "1f1fa-1f1ec"
  },
  {
    n: [
      "u.s. outlying islands flag",
      "flag-um"
    ],
    u: "1f1fa-1f1f2"
  },
  {
    n: [
      "united nations flag",
      "flag-un"
    ],
    u: "1f1fa-1f1f3"
  },
  {
    n: [
      "united states flag",
      "us",
      "flag-us"
    ],
    u: "1f1fa-1f1f8"
  },
  {
    n: [
      "uruguay flag",
      "flag-uy"
    ],
    u: "1f1fa-1f1fe"
  },
  {
    n: [
      "uzbekistan flag",
      "flag-uz"
    ],
    u: "1f1fa-1f1ff"
  },
  {
    n: [
      "vatican city flag",
      "flag-va"
    ],
    u: "1f1fb-1f1e6"
  },
  {
    n: [
      "st. vincent & grenadines flag",
      "flag-vc"
    ],
    u: "1f1fb-1f1e8"
  },
  {
    n: [
      "venezuela flag",
      "flag-ve"
    ],
    u: "1f1fb-1f1ea"
  },
  {
    n: [
      "british virgin islands flag",
      "flag-vg"
    ],
    u: "1f1fb-1f1ec"
  },
  {
    n: [
      "u.s. virgin islands flag",
      "flag-vi"
    ],
    u: "1f1fb-1f1ee"
  },
  {
    n: [
      "vietnam flag",
      "flag-vn"
    ],
    u: "1f1fb-1f1f3"
  },
  {
    n: [
      "vanuatu flag",
      "flag-vu"
    ],
    u: "1f1fb-1f1fa"
  },
  {
    n: [
      "wallis & futuna flag",
      "flag-wf"
    ],
    u: "1f1fc-1f1eb"
  },
  {
    n: [
      "samoa flag",
      "flag-ws"
    ],
    u: "1f1fc-1f1f8"
  },
  {
    n: [
      "kosovo flag",
      "flag-xk"
    ],
    u: "1f1fd-1f1f0"
  },
  {
    n: [
      "yemen flag",
      "flag-ye"
    ],
    u: "1f1fe-1f1ea"
  },
  {
    n: [
      "mayotte flag",
      "flag-yt"
    ],
    u: "1f1fe-1f1f9"
  },
  {
    n: [
      "south africa flag",
      "flag-za"
    ],
    u: "1f1ff-1f1e6"
  },
  {
    n: [
      "zambia flag",
      "flag-zm"
    ],
    u: "1f1ff-1f1f2"
  },
  {
    n: [
      "zimbabwe flag",
      "flag-zw"
    ],
    u: "1f1ff-1f1fc"
  },
  {
    n: [
      "england flag",
      "flag-england"
    ],
    u: "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f"
  },
  {
    n: [
      "scotland flag",
      "flag-scotland"
    ],
    u: "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f"
  },
  {
    n: [
      "wales flag",
      "flag-wales"
    ],
    u: "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f"
  }
];
var emojis = {
  smileys_people: smileys_people$1,
  animals_nature: animals_nature$1,
  food_drink: food_drink$1,
  activities: activities$1,
  travel_places: travel_places$1,
  objects: objects$1,
  symbols: symbols$1,
  flags: flags$1
};
var _groups = [
  {
    key: "recent",
    title: "Recently Used",
    u: "1f551"
  },
  {
    key: "smileys_people",
    title: "Smiles & People",
    u: "1f600"
  },
  {
    key: "animals_nature",
    title: "Animals & Nature",
    u: "1F431"
  },
  {
    key: "food_drink",
    title: "Food & Drink",
    u: "2615"
  },
  {
    key: "activities",
    title: "Activities",
    u: "26BD"
  },
  {
    key: "travel_places",
    title: "Travel & Places",
    u: "1F697"
  },
  {
    key: "objects",
    title: "Objects",
    u: "1F4A1"
  },
  {
    key: "symbols",
    title: "Symbols",
    u: "1f4af"
  },
  {
    key: "flags",
    title: "Flags",
    u: "1f3f3-fe0f"
  }
];
const instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve2, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve2(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve2, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve2();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(event.oldVersion, event.newVersion, event));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => __spreadProps(__spreadValues({}, oldTraps), {
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
const DB_KEY = "EMJ";
const STORE_KEY = "emojis";
const DB_VERSION = 3;
async function initialize() {
  const db = await openDB(DB_KEY, DB_VERSION, {
    upgrade(db2, oldVersion) {
      if (!db2.objectStoreNames.contains(STORE_KEY)) {
        const store = db2.createObjectStore(STORE_KEY, {
          keyPath: "id",
          autoIncrement: true
        });
        store.createIndex("id", "id", {
          unique: true
        });
      }
    }
  });
  db.close();
}
initialize();
const defaultOptions = {
  native: false,
  hideSearch: true,
  hideGroupIcons: false,
  hideGroupNames: false,
  staticTexts: {},
  disabledGroups: [],
  groupNames: {},
  displayRecent: false,
  additionalGroups: {},
  groupOrder: [],
  groupIcons: {}
};
async function getRecentEmojis() {
  const db = await openDB(DB_KEY, DB_VERSION);
  const store = db.transaction(STORE_KEY, "readonly").objectStore(STORE_KEY);
  return await store.getAll();
}
function Store() {
  const state = reactive({
    search: "",
    emoji: DEFAULT_EMOJI,
    activeGroup: "",
    skinTone: SKIN_TONE_NEUTRAL,
    options: defaultOptions,
    additionalGroups: {},
    recent: [],
    get emojis() {
      return __spreadValues(__spreadValues({
        recent: this.recent
      }, this.options.additionalGroups), emojis);
    },
    get disabled() {
      let disabled = Array.isArray(this.options.disabledGroups) ? this.options.disabledGroups : [];
      if (!this.options.displayRecent) {
        disabled = ["recent", ...disabled];
      }
      return disabled;
    },
    get groups() {
      return _groups.filter((group) => !this.disabled.includes(group.key));
    },
    get orderedGroupKeys() {
      const keys2 = [
        ...this.options.groupOrder,
        ...Object.keys(this.options.additionalGroups),
        ..._groups.map((group) => group.key)
      ];
      return [...new Set(keys2)].filter((key) => !this.disabled.includes(key));
    }
  });
  function initialize2() {
    if (state.options.displayRecent) {
      setInitialRecentEmojis();
    }
  }
  async function getRecent() {
    var _a;
    let recent2 = await getRecentEmojis();
    if (Array.isArray(recent2) && recent2.length) {
      recent2 = JSON.parse(((_a = recent2[0]) == null ? void 0 : _a.value) || "");
    } else {
      recent2 = [];
    }
    return recent2;
  }
  function setInitialRecentEmojis() {
    getRecent().then((recent2) => {
      state.recent = recent2;
      updateLocalStore();
    });
  }
  const updateSearch = (value) => {
    state.search = value;
  };
  const updateEmoji = (value) => {
    state.emoji = value;
  };
  const updateActiveGroup = (group) => {
    state.activeGroup = group;
  };
  const updateSkinTone = (tone = SKIN_TONE_NEUTRAL) => {
    state.skinTone = tone;
  };
  const updateOptions = (options) => {
    state.options = Object.assign({}, state.options, options);
    initialize2();
  };
  async function updateLocalStore() {
    const db = await openDB(DB_KEY, DB_VERSION);
    const store = db.transaction(STORE_KEY, "readwrite").objectStore(STORE_KEY);
    store.put({
      id: 0,
      value: JSON.stringify(state.recent)
    });
    return;
  }
  const updateSelect = (emoji) => {
    if (state.options.displayRecent !== true)
      return;
    const index2 = state.recent.findIndex((item) => item.u === emoji.u);
    if (index2 > 0)
      state.recent.splice(index2, 1);
    if (index2 === 0)
      return;
    const _emoji = { u: emoji.u, n: toRaw(emoji.n) };
    state.recent = [_emoji, ...state.recent];
    if (state.recent.length > 24)
      state.recent.length = 24;
    updateLocalStore();
  };
  return {
    state: readonly(state),
    updateSearch,
    updateEmoji,
    updateActiveGroup,
    updateSkinTone,
    updateOptions,
    updateSelect
  };
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style22, property) {
        style22[property] = "";
        return style22;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y2 = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body" && (canEscapeClipping ? getComputedStyle$1(clippingParent).position !== "static" : true);
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$12 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$12.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$12;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var smileys_people = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgOS4zODI4MTMgNCA0IDkuMzgyODEzIDQgMTYgQyA0IDIyLjYxNzE4OCA5LjM4MjgxMyAyOCAxNiAyOCBDIDIyLjYxNzE4OCAyOCAyOCAyMi42MTcxODggMjggMTYgQyAyOCA5LjM4MjgxMyAyMi42MTcxODggNCAxNiA0IFogTSAxNiA2IEMgMjEuNTM1MTU2IDYgMjYgMTAuNDY0ODQ0IDI2IDE2IEMgMjYgMjEuNTM1MTU2IDIxLjUzNTE1NiAyNiAxNiAyNiBDIDEwLjQ2NDg0NCAyNiA2IDIxLjUzNTE1NiA2IDE2IEMgNiAxMC40NjQ4NDQgMTAuNDY0ODQ0IDYgMTYgNiBaIE0gMTEuNSAxMiBDIDEwLjY3MTg3NSAxMiAxMCAxMi42NzE4NzUgMTAgMTMuNSBDIDEwIDE0LjMyODEyNSAxMC42NzE4NzUgMTUgMTEuNSAxNSBDIDEyLjMyODEyNSAxNSAxMyAxNC4zMjgxMjUgMTMgMTMuNSBDIDEzIDEyLjY3MTg3NSAxMi4zMjgxMjUgMTIgMTEuNSAxMiBaIE0gMjAuNSAxMiBDIDE5LjY3MTg3NSAxMiAxOSAxMi42NzE4NzUgMTkgMTMuNSBDIDE5IDE0LjMyODEyNSAxOS42NzE4NzUgMTUgMjAuNSAxNSBDIDIxLjMyODEyNSAxNSAyMiAxNC4zMjgxMjUgMjIgMTMuNSBDIDIyIDEyLjY3MTg3NSAyMS4zMjgxMjUgMTIgMjAuNSAxMiBaIE0gMTAuODEyNSAxOSBMIDkuMDkzNzUgMjAgQyAxMC40NzY1NjMgMjIuMzg2NzE5IDEzLjA0Njg3NSAyNCAxNiAyNCBDIDE4Ljk1MzEyNSAyNCAyMS41MjM0MzggMjIuMzg2NzE5IDIyLjkwNjI1IDIwIEwgMjEuMTg3NSAxOSBDIDIwLjE0ODQzOCAyMC43OTI5NjkgMTguMjI2NTYzIDIyIDE2IDIyIEMgMTMuNzczNDM4IDIyIDExLjg1MTU2MyAyMC43OTI5NjkgMTAuODEyNSAxOSBaIi8+PC9zdmc+";
function unicodeToEmoji(unicode) {
  return unicode.split("-").map((hex) => parseInt(hex, 16)).map((hex) => String.fromCodePoint(hex)).join("");
}
function filterEmojis(emojis2, keyword, skinTone, disabledGroups = []) {
  const _emojiData = {};
  Object.keys(emojis2).forEach((key) => {
    if (disabledGroups.includes(key)) {
      return;
    }
    const _emojis = [];
    emojis2[key].forEach((emoji) => {
      var _a;
      if (emoji[EMOJI_NAME_KEY][0].includes(keyword.toLocaleLowerCase())) {
        let result = emoji[EMOJI_UNICODE_KEY];
        if (skinTone !== SKIN_TONE_NEUTRAL && Array.isArray(emoji[EMOJI_VARIATIONS_KEY])) {
          const v_index = ((_a = emoji[EMOJI_VARIATIONS_KEY]) == null ? void 0 : _a.findIndex((v2) => v2.includes(skinTone))) || -1;
          if (v_index !== -1 && emoji[EMOJI_VARIATIONS_KEY]) {
            result = emoji[EMOJI_VARIATIONS_KEY][v_index];
          }
        }
        return _emojis.push(__spreadProps(__spreadValues({}, emoji), {
          [EMOJI_RESULT_KEY]: result
        }));
      }
    });
    if (_emojis.length) {
      _emojiData[key] = _emojis;
    }
  });
  return _emojiData;
}
function isMac() {
  var _a;
  let platform = ((_a = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : _a.platform) || (navigator == null ? void 0 : navigator.platform) || "unknown";
  return platform.toUpperCase().indexOf("MAC") !== -1;
}
function snakeToCapitalizedCase(string) {
  return string.replace(/^_*(.)|_+(.)/g, (s2, c2, d2) => c2 ? c2.toUpperCase() : " " + d2.toUpperCase());
}
var _export_sfc$1 = (sfc, props) => {
  for (const [key, val] of props) {
    sfc[key] = val;
  }
  return sfc;
};
const _sfc_main$4$1 = defineComponent({
  name: "Body",
  setup() {
    const { state, updateEmoji, updateSelect } = inject("store");
    const bodyInner = ref(null);
    const emojis2 = computed(() => {
      return filterEmojis(state.emojis, state.search, state.skinTone, state.options.disabledGroups);
    });
    const _this = getCurrentInstance();
    const hasGroupNames = computed(() => !state.options.hideGroupNames);
    const isSticky = computed(() => !state.options.disableStickyGroupNames);
    const groupNames = toRaw(state.options.groupNames);
    const orderedKeys = state.orderedGroupKeys;
    if (state.options.additionalGroups) {
      Object.keys(state.options.additionalGroups).map((k2) => {
        if (state.options.groupNames[k2]) {
          groupNames[k2] = state.options.groupNames[k2];
        } else {
          groupNames[k2] = snakeToCapitalizedCase(k2);
        }
      });
    }
    const platform = isMac() ? "is-mac" : "";
    function handleMouseEnter(emoji) {
      updateEmoji(emoji);
    }
    function handleClick(emoji) {
      updateSelect(emoji);
      _this == null ? void 0 : _this.emit("select", __spreadProps(__spreadValues({}, emoji), {
        t: state.skinTone,
        i: unicodeToEmoji(emoji.r)
      }));
    }
    function handleError2(event, unicode) {
      var _a;
      const button = (_a = event == null ? void 0 : event.target) == null ? void 0 : _a.closest("button");
      if (button) {
        button.innerHTML = `<span>${unicodeToEmoji(unicode)}</span>`;
      }
    }
    watch(() => state.activeGroup, () => {
      var _a;
      const target = (_a = bodyInner.value) == null ? void 0 : _a.querySelector("#" + state.activeGroup);
      if (target) {
        target.parentNode.scrollTop = target.offsetTop - target.parentNode.offsetTop;
      }
    });
    return {
      emojis: emojis2,
      bodyInner,
      EMOJI_REMOTE_SRC,
      GROUP_NAMES,
      handleClick,
      handleError: handleError2,
      handleMouseEnter,
      native: state.options.native,
      unicodeToEmoji,
      EMOJI_RESULT_KEY,
      EMOJI_NAME_KEY,
      hasGroupNames,
      isSticky,
      platform,
      groupNames,
      orderedKeys
    };
  }
});
const _hoisted_1$3$1 = { class: "v3-body" };
const _hoisted_2$3$1 = ["id"];
const _hoisted_3$3$1 = { class: "v3-emojis" };
const _hoisted_4$3$1 = ["onMouseenter", "onClick"];
const _hoisted_5$3$1 = { key: 0 };
const _hoisted_6$2$1 = ["src", "alt", "onError"];
const _hoisted_7$1$1 = {
  key: 1,
  class: "v3-no-result"
};
function _sfc_render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3$1, [
    createBaseVNode("div", {
      ref: "bodyInner",
      class: normalizeClass([_ctx.platform, "v3-body-inner"])
    }, [
      _ctx.orderedKeys.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.orderedKeys, (key) => {
        return openBlock(), createElementBlock("div", {
          id: key,
          key,
          class: "v3-group"
        }, [
          _ctx.hasGroupNames ? withDirectives((openBlock(), createElementBlock("h5", {
            key: 0,
            class: normalizeClass(_ctx.isSticky ? `v3-sticky` : ``)
          }, toDisplayString(_ctx.groupNames[key]), 3)), [
            [vShow, _ctx.emojis[key]]
          ]) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_3$3$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.emojis[key], (emoji) => {
              return openBlock(), createElementBlock("button", {
                key: emoji.r,
                type: "button",
                onMouseenter: ($event) => _ctx.handleMouseEnter(emoji),
                onClick: ($event) => _ctx.handleClick(emoji)
              }, [
                _ctx.native ? (openBlock(), createElementBlock("span", _hoisted_5$3$1, toDisplayString(_ctx.unicodeToEmoji(emoji.r)), 1)) : (openBlock(), createElementBlock("img", {
                  key: 1,
                  src: _ctx.EMOJI_REMOTE_SRC + `/${emoji.r}.png`,
                  alt: emoji.n[0],
                  onError: ($event) => _ctx.handleError($event, emoji.r)
                }, null, 40, _hoisted_6$2$1))
              ], 40, _hoisted_4$3$1);
            }), 128))
          ], 512), [
            [vShow, _ctx.emojis[key]]
          ])
        ], 8, _hoisted_2$3$1);
      }), 128)) : (openBlock(), createElementBlock("span", _hoisted_7$1$1, " No emoji has been found! "))
    ], 2)
  ]);
}
var Body = /* @__PURE__ */ _export_sfc$1(_sfc_main$4$1, [["render", _sfc_render$4$1]]);
var animals_nature = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMi41IDUgQyAxMS40Mjk2ODggNSAxMC41IDUuNjA5Mzc1IDkuOTA2MjUgNi40Mzc1IEMgOS4zMTI1IDcuMjY1NjI1IDkgOC4zMzk4NDQgOSA5LjUgQyA5IDEwLjY2MDE1NiA5LjMxMjUgMTEuNzM0Mzc1IDkuOTA2MjUgMTIuNTYyNSBDIDEwLjUgMTMuMzkwNjI1IDExLjQyOTY4OCAxNCAxMi41IDE0IEMgMTMuNTcwMzEzIDE0IDE0LjUgMTMuMzkwNjI1IDE1LjA5Mzc1IDEyLjU2MjUgQyAxNS42ODc1IDExLjczNDM3NSAxNiAxMC42NjAxNTYgMTYgOS41IEMgMTYgOC4zMzk4NDQgMTUuNjg3NSA3LjI2NTYyNSAxNS4wOTM3NSA2LjQzNzUgQyAxNC41IDUuNjA5Mzc1IDEzLjU3MDMxMyA1IDEyLjUgNSBaIE0gMTYgOS41IEMgMTYgMTAuNjYwMTU2IDE2LjMxMjUgMTEuNzM0Mzc1IDE2LjkwNjI1IDEyLjU2MjUgQyAxNy41IDEzLjM5MDYyNSAxOC40Mjk2ODggMTQgMTkuNSAxNCBDIDIwLjU3MDMxMyAxNCAyMS41IDEzLjM5MDYyNSAyMi4wOTM3NSAxMi41NjI1IEMgMjIuNjg3NSAxMS43MzQzNzUgMjMgMTAuNjYwMTU2IDIzIDkuNSBDIDIzIDguMzM5ODQ0IDIyLjY4NzUgNy4yNjU2MjUgMjIuMDkzNzUgNi40Mzc1IEMgMjEuNSA1LjYwOTM3NSAyMC41NzAzMTMgNSAxOS41IDUgQyAxOC40Mjk2ODggNSAxNy41IDUuNjA5Mzc1IDE2LjkwNjI1IDYuNDM3NSBDIDE2LjMxMjUgNy4yNjU2MjUgMTYgOC4zMzk4NDQgMTYgOS41IFogTSAxMi41IDcgQyAxMi44MTI1IDcgMTMuMTU2MjUgNy4xNTYyNSAxMy40Njg3NSA3LjU5Mzc1IEMgMTMuNzgxMjUgOC4wMzEyNSAxNCA4LjcyNjU2MyAxNCA5LjUgQyAxNCAxMC4yNzM0MzggMTMuNzgxMjUgMTAuOTY4NzUgMTMuNDY4NzUgMTEuNDA2MjUgQyAxMy4xNTYyNSAxMS44NDM3NSAxMi44MTI1IDEyIDEyLjUgMTIgQyAxMi4xODc1IDEyIDExLjg0Mzc1IDExLjg0Mzc1IDExLjUzMTI1IDExLjQwNjI1IEMgMTEuMjE4NzUgMTAuOTY4NzUgMTEgMTAuMjczNDM4IDExIDkuNSBDIDExIDguNzI2NTYzIDExLjIxODc1IDguMDMxMjUgMTEuNTMxMjUgNy41OTM3NSBDIDExLjg0Mzc1IDcuMTU2MjUgMTIuMTg3NSA3IDEyLjUgNyBaIE0gMTkuNSA3IEMgMTkuODEyNSA3IDIwLjE1NjI1IDcuMTU2MjUgMjAuNDY4NzUgNy41OTM3NSBDIDIwLjc4MTI1IDguMDMxMjUgMjEgOC43MjY1NjMgMjEgOS41IEMgMjEgMTAuMjczNDM4IDIwLjc4MTI1IDEwLjk2ODc1IDIwLjQ2ODc1IDExLjQwNjI1IEMgMjAuMTU2MjUgMTEuODQzNzUgMTkuODEyNSAxMiAxOS41IDEyIEMgMTkuMTg3NSAxMiAxOC44NDM3NSAxMS44NDM3NSAxOC41MzEyNSAxMS40MDYyNSBDIDE4LjIxODc1IDEwLjk2ODc1IDE4IDEwLjI3MzQzOCAxOCA5LjUgQyAxOCA4LjcyNjU2MyAxOC4yMTg3NSA4LjAzMTI1IDE4LjUzMTI1IDcuNTkzNzUgQyAxOC44NDM3NSA3LjE1NjI1IDE5LjE4NzUgNyAxOS41IDcgWiBNIDcuNSAxMiBDIDYuNDI5Njg4IDEyIDUuNSAxMi42MDkzNzUgNC45MDYyNSAxMy40Mzc1IEMgNC4zMTI1IDE0LjI2NTYyNSA0IDE1LjMzOTg0NCA0IDE2LjUgQyA0IDE3LjY2MDE1NiA0LjMxMjUgMTguNzM0Mzc1IDQuOTA2MjUgMTkuNTYyNSBDIDUuNSAyMC4zOTA2MjUgNi40Mjk2ODggMjEgNy41IDIxIEMgOC41NzAzMTMgMjEgOS41IDIwLjM5MDYyNSAxMC4wOTM3NSAxOS41NjI1IEMgMTAuNjg3NSAxOC43MzQzNzUgMTEgMTcuNjYwMTU2IDExIDE2LjUgQyAxMSAxNS4zMzk4NDQgMTAuNjg3NSAxNC4yNjU2MjUgMTAuMDkzNzUgMTMuNDM3NSBDIDkuNSAxMi42MDkzNzUgOC41NzAzMTMgMTIgNy41IDEyIFogTSAyNC41IDEyIEMgMjMuNDI5Njg4IDEyIDIyLjUgMTIuNjA5Mzc1IDIxLjkwNjI1IDEzLjQzNzUgQyAyMS4zMTI1IDE0LjI2NTYyNSAyMSAxNS4zMzk4NDQgMjEgMTYuNSBDIDIxIDE3LjY2MDE1NiAyMS4zMTI1IDE4LjczNDM3NSAyMS45MDYyNSAxOS41NjI1IEMgMjIuNSAyMC4zOTA2MjUgMjMuNDI5Njg4IDIxIDI0LjUgMjEgQyAyNS41NzAzMTMgMjEgMjYuNSAyMC4zOTA2MjUgMjcuMDkzNzUgMTkuNTYyNSBDIDI3LjY4NzUgMTguNzM0Mzc1IDI4IDE3LjY2MDE1NiAyOCAxNi41IEMgMjggMTUuMzM5ODQ0IDI3LjY4NzUgMTQuMjY1NjI1IDI3LjA5Mzc1IDEzLjQzNzUgQyAyNi41IDEyLjYwOTM3NSAyNS41NzAzMTMgMTIgMjQuNSAxMiBaIE0gNy41IDE0IEMgNy44MTI1IDE0IDguMTU2MjUgMTQuMTU2MjUgOC40Njg3NSAxNC41OTM3NSBDIDguNzgxMjUgMTUuMDMxMjUgOSAxNS43MjY1NjMgOSAxNi41IEMgOSAxNy4yNzM0MzggOC43ODEyNSAxNy45Njg3NSA4LjQ2ODc1IDE4LjQwNjI1IEMgOC4xNTYyNSAxOC44NDM3NSA3LjgxMjUgMTkgNy41IDE5IEMgNy4xODc1IDE5IDYuODQzNzUgMTguODQzNzUgNi41MzEyNSAxOC40MDYyNSBDIDYuMjE4NzUgMTcuOTY4NzUgNiAxNy4yNzM0MzggNiAxNi41IEMgNiAxNS43MjY1NjMgNi4yMTg3NSAxNS4wMzEyNSA2LjUzMTI1IDE0LjU5Mzc1IEMgNi44NDM3NSAxNC4xNTYyNSA3LjE4NzUgMTQgNy41IDE0IFogTSAyNC41IDE0IEMgMjQuODEyNSAxNCAyNS4xNTYyNSAxNC4xNTYyNSAyNS40Njg3NSAxNC41OTM3NSBDIDI1Ljc4MTI1IDE1LjAzMTI1IDI2IDE1LjcyNjU2MyAyNiAxNi41IEMgMjYgMTcuMjczNDM4IDI1Ljc4MTI1IDE3Ljk2ODc1IDI1LjQ2ODc1IDE4LjQwNjI1IEMgMjUuMTU2MjUgMTguODQzNzUgMjQuODEyNSAxOSAyNC41IDE5IEMgMjQuMTg3NSAxOSAyMy44NDM3NSAxOC44NDM3NSAyMy41MzEyNSAxOC40MDYyNSBDIDIzLjIxODc1IDE3Ljk2ODc1IDIzIDE3LjI3MzQzOCAyMyAxNi41IEMgMjMgMTUuNzI2NTYzIDIzLjIxODc1IDE1LjAzMTI1IDIzLjUzMTI1IDE0LjU5Mzc1IEMgMjMuODQzNzUgMTQuMTU2MjUgMjQuMTg3NSAxNCAyNC41IDE0IFogTSAxNiAxNiBDIDE0LjY2Nzk2OSAxNiAxMy43MzgyODEgMTYuODY3MTg4IDEzLjI4MTI1IDE3LjYyNSBDIDEyLjgyNDIxOSAxOC4zODI4MTMgMTIuNTQ2ODc1IDE5LjAxNTYyNSAxMi4yODEyNSAxOS4yODEyNSBDIDEyLjEyNSAxOS40Mzc1IDExLjE2MDE1NiAxOS44MDA3ODEgMTAuMTU2MjUgMjAuMzEyNSBDIDkuNjUyMzQ0IDIwLjU3MDMxMyA5LjE0NDUzMSAyMC45MTQwNjMgOC43MTg3NSAyMS40Mzc1IEMgOC4yOTI5NjkgMjEuOTYwOTM4IDggMjIuNjg3NSA4IDIzLjUgQyA4IDI1LjQyMTg3NSA5LjU3ODEyNSAyNyAxMS41IDI3IEMgMTIuMzY3MTg4IDI3IDEzLjI2OTUzMSAyNi43MjI2NTYgMTQuMTU2MjUgMjYuNDY4NzUgQyAxNS4wNDI5NjkgMjYuMjE0ODQ0IDE2IDI2IDE2IDI2IEMgMTYgMjYgMTYuOTU3MDMxIDI2LjIxNDg0NCAxNy44NDM3NSAyNi40Njg3NSBDIDE4LjczMDQ2OSAyNi43MjI2NTYgMTkuNjMyODEzIDI3IDIwLjUgMjcgQyAyMi40MjE4NzUgMjcgMjQgMjUuNDIxODc1IDI0IDIzLjUgQyAyNCAyMi43MDcwMzEgMjMuNzA3MDMxIDIxLjk4MDQ2OSAyMy4yODEyNSAyMS40Njg3NSBDIDIyLjg1NTQ2OSAyMC45NTcwMzEgMjIuMzQzNzUgMjAuNjQwNjI1IDIxLjg0Mzc1IDIwLjM3NSBDIDIwLjg0Mzc1IDE5Ljg0Mzc1IDE5Ljg1OTM3NSAxOS40MjE4NzUgMTkuNzE4NzUgMTkuMjgxMjUgQyAxOS40ODA0NjkgMTkuMDQyOTY5IDE5LjIxMDkzOCAxOC4zOTA2MjUgMTguNzUgMTcuNjI1IEMgMTguMjg5MDYzIDE2Ljg1OTM3NSAxNy4zMzk4NDQgMTYgMTYgMTYgWiBNIDE2IDE4IEMgMTYuNjYwMTU2IDE4IDE2LjczNDM3NSAxOC4xNjAxNTYgMTcuMDMxMjUgMTguNjU2MjUgQyAxNy4zMjgxMjUgMTkuMTUyMzQ0IDE3LjU1NDY4OCAxOS45OTIxODggMTguMjgxMjUgMjAuNzE4NzUgQyAxOS4xMDU0NjkgMjEuNTQyOTY5IDIwLjE0ODQzOCAyMS43MjI2NTYgMjAuOTA2MjUgMjIuMTI1IEMgMjEuMjg1MTU2IDIyLjMyODEyNSAyMS41NzgxMjUgMjIuNTQyOTY5IDIxLjc1IDIyLjc1IEMgMjEuOTIxODc1IDIyLjk1NzAzMSAyMiAyMy4xNDg0MzggMjIgMjMuNSBDIDIyIDI0LjMzOTg0NCAyMS4zMzk4NDQgMjUgMjAuNSAyNSBDIDIwLjIxMDkzOCAyNSAxOS4yNzczNDQgMjQuNzc3MzQ0IDE4LjQwNjI1IDI0LjUzMTI1IEMgMTcuNTM1MTU2IDI0LjI4NTE1NiAxNi44MTY0MDYgMjQgMTYgMjQgQyAxNS4xODM1OTQgMjQgMTQuNDY0ODQ0IDI0LjI4NTE1NiAxMy41OTM3NSAyNC41MzEyNSBDIDEyLjcyMjY1NiAyNC43NzczNDQgMTEuNzg5MDYzIDI1IDExLjUgMjUgQyAxMC42NjAxNTYgMjUgMTAgMjQuMzM5ODQ0IDEwIDIzLjUgQyAxMCAyMy4wOTc2NTYgMTAuMDgyMDMxIDIyLjg5MDYyNSAxMC4yNSAyMi42ODc1IEMgMTAuNDE3OTY5IDIyLjQ4NDM3NSAxMC43MjI2NTYgMjIuMjg1MTU2IDExLjA5Mzc1IDIyLjA5Mzc1IEMgMTEuODM5ODQ0IDIxLjcxNDg0NCAxMi44NzUgMjEuNTYyNSAxMy43MTg3NSAyMC43MTg3NSBDIDE0LjQ1MzEyNSAxOS45ODQzNzUgMTQuNjc1NzgxIDE5LjExNzE4OCAxNC45Njg3NSAxOC42MjUgQyAxNS4yNjE3MTkgMTguMTMyODEzIDE1LjMzMjAzMSAxOCAxNiAxOCBaIi8+PC9zdmc+";
var food_drink = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSAzIEwgMTEgNyBMIDEzIDcgTCAxMyAzIFogTSAxNSA0IEwgMTUgNyBMIDE3IDcgTCAxNyA0IFogTSA0Ljg3NSA4IEwgNSA5LjA5Mzc1IEwgNi44MTI1IDI2LjMxMjUgQyA2Ljk3MjY1NiAyNy44MzIwMzEgOC4yODUxNTYgMjkgOS44MTI1IDI5IEwgMTkuMTg3NSAyOSBDIDIwLjcxNDg0NCAyOSAyMi4wMjczNDQgMjcuODMyMDMxIDIyLjE4NzUgMjYuMzEyNSBMIDIyLjY1NjI1IDIyIEwgMjUgMjIgQyAyNi42NDQ1MzEgMjIgMjggMjAuNjQ0NTMxIDI4IDE5IEwgMjggMTYgQyAyOCAxNC4zNTU0NjkgMjYuNjQ0NTMxIDEzIDI1IDEzIEwgMjMuNTkzNzUgMTMgTCAyNCA5LjA5Mzc1IEwgMjQuMTI1IDggWiBNIDcuMTI1IDEwIEwgMjEuODc1IDEwIEwgMjAuMTg3NSAyNi4wOTM3NSBDIDIwLjEzMjgxMyAyNi42MTMyODEgMTkuNzA3MDMxIDI3IDE5LjE4NzUgMjcgTCA5LjgxMjUgMjcgQyA5LjI5Mjk2OSAyNyA4Ljg2NzE4OCAyNi42MTMyODEgOC44MTI1IDI2LjA5Mzc1IFogTSAyMy4zNzUgMTUgTCAyNSAxNSBDIDI1LjU2NjQwNiAxNSAyNiAxNS40MzM1OTQgMjYgMTYgTCAyNiAxOSBDIDI2IDE5LjU2NjQwNiAyNS41NjY0MDYgMjAgMjUgMjAgTCAyMi44NDM3NSAyMCBaIi8+PC9zdmc+";
var activities = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiAzIEMgOC44MzIwMzEgMyAzIDguODMyMDMxIDMgMTYgQyAzIDIzLjE2Nzk2OSA4LjgzMjAzMSAyOSAxNiAyOSBDIDIzLjE2Nzk2OSAyOSAyOSAyMy4xNjc5NjkgMjkgMTYgQyAyOSA4LjgzMjAzMSAyMy4xNjc5NjkgMyAxNiAzIFogTSAxNiA1IEMgMTYuNjAxNTYzIDUgMTcuMTc1NzgxIDUuMDYyNSAxNy43NSA1LjE1NjI1IEwgMTYgNi40MDYyNSBMIDE0LjI1IDUuMTU2MjUgQyAxNC44MjAzMTMgNS4wNjY0MDYgMTUuNDAyMzQ0IDUgMTYgNSBaIE0gMTEuODEyNSA1Ljg0Mzc1IEwgMTUuNDA2MjUgOC40Njg3NSBMIDE2IDguOTA2MjUgTCAxNi41OTM3NSA4LjQ2ODc1IEwgMjAuMTg3NSA1Ljg0Mzc1IEMgMjEuNzg1MTU2IDYuNTA3ODEzIDIzLjE5NTMxMyA3LjUyMzQzOCAyNC4zMTI1IDguODEyNSBMIDIyLjkzNzUgMTMuMDkzNzUgTCAyMi43MTg3NSAxMy43ODEyNSBMIDIzLjMxMjUgMTQuMTg3NSBMIDI2LjkzNzUgMTYuODQzNzUgQyAyNi44MDQ2ODggMTguNjA1NDY5IDI2LjI2NTYyNSAyMC4yNTc4MTMgMjUuNDA2MjUgMjEuNjg3NSBMIDIwLjEyNSAyMS42ODc1IEwgMTkuOTA2MjUgMjIuMzc1IEwgMTguNSAyNi43MTg3NSBDIDE3LjY5OTIxOSAyNi45MDYyNSAxNi44NTkzNzUgMjcgMTYgMjcgQyAxNS4xMDU0NjkgMjcgMTQuMjM4MjgxIDI2Ljg4NjcxOSAxMy40MDYyNSAyNi42ODc1IEwgMTIuMDMxMjUgMjIuNDA2MjUgTCAxMS44MTI1IDIxLjcxODc1IEwgNi41OTM3NSAyMS43MTg3NSBDIDUuNzE4NzUgMjAuMjgxMjUgNS4xOTkyMTkgMTguNjIxMDk0IDUuMDYyNSAxNi44NDM3NSBMIDguNjU2MjUgMTQuMjE4NzUgTCA5LjI1IDEzLjgxMjUgTCA5LjAzMTI1IDEzLjEyNSBMIDcuNjI1IDguODc1IEMgOC43NSA3LjU1NDY4OCAxMC4xODM1OTQgNi41MTU2MjUgMTEuODEyNSA1Ljg0Mzc1IFogTSAxNiAxMC4wOTM3NSBMIDE1LjQwNjI1IDEwLjUzMTI1IEwgMTAuODQzNzUgMTMuODQzNzUgTCAxMC4yODEyNSAxNC4yODEyNSBMIDEwLjUgMTQuOTY4NzUgTCAxMi4yNSAyMC4zMTI1IEwgMTIuNDY4NzUgMjEgTCAxOS41MzEyNSAyMSBMIDE5Ljc1IDIwLjMxMjUgTCAyMS41IDE0Ljk2ODc1IEwgMjEuNzE4NzUgMTQuMjgxMjUgTCAyMS4xNTYyNSAxMy44NDM3NSBMIDE2LjU5Mzc1IDEwLjUzMTI1IFogTSAyNS43NSAxMC45MDYyNSBDIDI2LjI5Njg3NSAxMS45NTMxMjUgMjYuNjU2MjUgMTMuMTAxNTYzIDI2Ljg0Mzc1IDE0LjMxMjUgTCAyNS4wNjI1IDEzLjAzMTI1IFogTSA2LjIxODc1IDEwLjk2ODc1IEwgNi45MDYyNSAxMy4wMzEyNSBMIDUuMTU2MjUgMTQuMzEyNSBDIDUuMzM5ODQ0IDEzLjEyNSA1LjY4NzUgMTIgNi4yMTg3NSAxMC45Njg3NSBaIE0gMTYgMTIuNTkzNzUgTCAxOS4zNzUgMTUuMDMxMjUgTCAxOC4wOTM3NSAxOSBMIDEzLjkwNjI1IDE5IEwgMTIuNjI1IDE1LjAzMTI1IFogTSAyMS41OTM3NSAyMy42ODc1IEwgMjMuODQzNzUgMjMuNjg3NSBDIDIyLjk5MjE4OCAyNC41NjY0MDYgMjIuMDExNzE5IDI1LjI5Mjk2OSAyMC45MDYyNSAyNS44NDM3NSBaIE0gOC4xNTYyNSAyMy43MTg3NSBMIDEwLjM0Mzc1IDIzLjcxODc1IEwgMTEuMDMxMjUgMjUuODEyNSBDIDkuOTYwOTM4IDI1LjI2OTUzMSA4Ljk4ODI4MSAyNC41NjI1IDguMTU2MjUgMjMuNzE4NzUgWiIvPjwvc3ZnPg==";
var travel_places = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5LjUgNiBDIDguMTc5Njg4IDYgNy4wMDM5MDYgNi44NTkzNzUgNi42MjUgOC4xMjUgTCA1LjI1IDEyLjcxODc1IEwgMy4zMTI1IDEyLjA2MjUgTCAyLjY4NzUgMTMuOTM3NSBMIDQuNjU2MjUgMTQuNTkzNzUgTCA0LjAzMTI1IDE2LjcxODc1IEMgNC4wMDc4MTMgMTYuODA4NTk0IDMuOTk2MDk0IDE2LjkwNjI1IDQgMTcgTCA0IDI0IEMgNCAyNC4wMzEyNSA0IDI0LjA2MjUgNCAyNC4wOTM3NSBMIDQgMjUgQyA0IDI1LjU1MDc4MSA0LjQ0OTIxOSAyNiA1IDI2IEwgOCAyNiBMIDguMzQzNzUgMjUgTCAyMy42NTYyNSAyNSBMIDI0IDI2IEwgMjcgMjYgQyAyNy41NTA3ODEgMjYgMjggMjUuNTUwNzgxIDI4IDI1IEwgMjggMjQuMTU2MjUgQyAyOC4wMDM5MDYgMjQuMTA1NDY5IDI4LjAwMzkwNiAyNC4wNTA3ODEgMjggMjQgTCAyOCAxNyBDIDI4LjAwMzkwNiAxNi45MDYyNSAyNy45OTIxODggMTYuODA4NTk0IDI3Ljk2ODc1IDE2LjcxODc1IEwgMjcuMzQzNzUgMTQuNTkzNzUgTCAyOS4zMTI1IDEzLjkzNzUgTCAyOC42ODc1IDEyLjA2MjUgTCAyNi43NSAxMi43MTg3NSBMIDI1LjM3NSA4LjEyNSBDIDI0Ljk5NjA5NCA2Ljg1OTM3NSAyMy44MjAzMTMgNiAyMi41IDYgWiBNIDkuNSA4IEwgMjIuNSA4IEMgMjIuOTQ1MzEzIDggMjMuMzM5ODQ0IDguMjkyOTY5IDIzLjQ2ODc1IDguNzE4NzUgTCAyNC43NSAxMyBMIDcuMjUgMTMgTCA4LjUzMTI1IDguNzE4NzUgQyA4LjY2MDE1NiA4LjI4OTA2MyA5LjA1NDY4OCA4IDkuNSA4IFogTSA2LjY1NjI1IDE1IEwgMjUuMzQzNzUgMTUgTCAyNiAxNy4xODc1IEwgMjYgMjMgTCA2IDIzIEwgNiAxNy4xODc1IFogTSA4LjUgMTYgQyA3LjY3MTg3NSAxNiA3IDE2LjY3MTg3NSA3IDE3LjUgQyA3IDE4LjMyODEyNSA3LjY3MTg3NSAxOSA4LjUgMTkgQyA5LjMyODEyNSAxOSAxMCAxOC4zMjgxMjUgMTAgMTcuNSBDIDEwIDE2LjY3MTg3NSA5LjMyODEyNSAxNiA4LjUgMTYgWiBNIDIzLjUgMTYgQyAyMi42NzE4NzUgMTYgMjIgMTYuNjcxODc1IDIyIDE3LjUgQyAyMiAxOC4zMjgxMjUgMjIuNjcxODc1IDE5IDIzLjUgMTkgQyAyNC4zMjgxMjUgMTkgMjUgMTguMzI4MTI1IDI1IDE3LjUgQyAyNSAxNi42NzE4NzUgMjQuMzI4MTI1IDE2IDIzLjUgMTYgWiBNIDEyIDE5IEwgMTAuNzUgMjIgTCAxMi45MDYyNSAyMiBMIDEzLjM0Mzc1IDIxIEwgMTguNjU2MjUgMjEgTCAxOS4wOTM3NSAyMiBMIDIxLjI1IDIyIEwgMjAgMTkgWiIvPjwvc3ZnPg==";
var objects = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuMDQyOTY5IDQgNyA4LjA0Mjk2OSA3IDEzIEMgNyAxNC45MTc5NjkgNy44NDM3NSAxNi45MDYyNSA5IDE4LjY4NzUgQyA5Ljg1OTM3NSAyMC4wMTE3MTkgMTAuODg2NzE5IDIxLjIzMDQ2OSAxMiAyMi4xNTYyNSBMIDEyIDI1IEMgMTIgMjYuMDkzNzUgMTIuOTA2MjUgMjcgMTQgMjcgTCAxNSAyOCBMIDE3IDI4IEwgMTggMjcgQyAxOS4wOTM3NSAyNyAyMCAyNi4wOTM3NSAyMCAyNSBMIDIwIDIyLjE1NjI1IEMgMjEuMTEzMjgxIDIxLjIzMDQ2OSAyMi4xNDA2MjUgMjAuMDExNzE5IDIzIDE4LjY4NzUgQyAyNC4xNTYyNSAxNi45MDYyNSAyNSAxNC45MTc5NjkgMjUgMTMgQyAyNSA4LjA0Mjk2OSAyMC45NTcwMzEgNCAxNiA0IFogTSAxNiA2IEMgMTkuODc4OTA2IDYgMjMgOS4xMjEwOTQgMjMgMTMgQyAyMyAxNC4zMDg1OTQgMjIuMzU1NDY5IDE2LjAzNTE1NiAyMS4zNDM3NSAxNy41OTM3NSBDIDIwLjQ0MTQwNiAxOC45ODQzNzUgMTkuMjUzOTA2IDIwLjIyMjY1NiAxOC4xNTYyNSAyMSBMIDEzLjg0Mzc1IDIxIEMgMTIuNzQ2MDk0IDIwLjIyMjY1NiAxMS41NTg1OTQgMTguOTg0Mzc1IDEwLjY1NjI1IDE3LjU5Mzc1IEMgOS42NDQ1MzEgMTYuMDM1MTU2IDkgMTQuMzA4NTk0IDkgMTMgQyA5IDkuMTIxMDk0IDEyLjEyMTA5NCA2IDE2IDYgWiBNIDE0LjI1IDIzIEwgMTcuNzUgMjMgQyAxNy44MjgxMjUgMjMuMDU0Njg4IDE3LjkxMDE1NiAyMy4wOTM3NSAxOCAyMy4xMjUgTCAxOCAyNSBMIDE0IDI1IEwgMTQgMjMuMTI1IEMgMTQuMDg5ODQ0IDIzLjA5Mzc1IDE0LjE3MTg3NSAyMy4wNTQ2ODggMTQuMjUgMjMgWiIvPjwvc3ZnPg==";
var symbols = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSA1IEwgMTEgMTEgTCA1IDExIEwgNSAxMyBMIDExIDEzIEwgMTEgMTkgTCA1IDE5IEwgNSAyMSBMIDExIDIxIEwgMTEgMjcgTCAxMyAyNyBMIDEzIDIxIEwgMTkgMjEgTCAxOSAyNyBMIDIxIDI3IEwgMjEgMjEgTCAyNyAyMSBMIDI3IDE5IEwgMjEgMTkgTCAyMSAxMyBMIDI3IDEzIEwgMjcgMTEgTCAyMSAxMSBMIDIxIDUgTCAxOSA1IEwgMTkgMTEgTCAxMyAxMSBMIDEzIDUgWiBNIDEzIDEzIEwgMTkgMTMgTCAxOSAxOSBMIDEzIDE5IFoiLz48L3N2Zz4=";
var flags = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5IDQgQyA3LjM0NiA0IDYgNS4zNDYgNiA3IEMgNiA4LjMwMTYwOTQgNi44Mzg3NDg2IDkuNDAyMTM5MSA4IDkuODE2NDA2MiBMIDggMTEuMzA0Njg4IEwgOCAyMy4yMDcwMzEgTCA4IDI3LjAyMzQzOCBDIDggMjcuNTYzNDM4IDguNDM2NTYyNSAyOCA4Ljk3NjU2MjUgMjggTCA5LjAyMzQzNzUgMjggQyA5LjU2MzQzNzUgMjggMTAgMjcuNTYzNDM3IDEwIDI3LjAyMzQzOCBMIDEwIDIyLjIyODUxNiBDIDEwLjMzNDcwNyAyMS44Mzk3NTYgMTEuMTM4NDIzIDIxLjA0Njg3NSAxMy40NDUzMTIgMjEuMDQ2ODc1IEMgMTQuNjY5MzEzIDIxLjA0Njg3NSAxNS42NzA0MjIgMjEuNDczNzgxIDE2LjczMjQyMiAyMS45MjU3ODEgQyAxNy43Njk0MjIgMjIuMzY3NzgxIDE4Ljg0MTg5MSAyMi44MjQyMTkgMjAuMDg3ODkxIDIyLjgyNDIxOSBDIDIyLjQ0Njg5MSAyMi44MjQyMTkgMjQuMDQ5Mzc1IDIxLjU4NDY4OCAyNC43MzQzNzUgMjEuMDU0Njg4IEwgMjQuODg2NzE5IDIwLjkzOTQ1MyBDIDI1LjQzNzcxOSAyMC41NDA0NTMgMjYgMTkuOTk2IDI2IDE5IEwgMjYgMTAuNjc1NzgxIEMgMjYgOS43Njc3ODEyIDI1LjIyMTgyOCA5IDI0LjI5ODgyOCA5IEMgMjMuODAzODI4IDkgMjMuNDQwNDA2IDkuMjg2NTkzNyAyMi45NDE0MDYgOS42ODM1OTM4IEMgMjIuMjc5NDA2IDEwLjIwNzU5NCAyMS4yODA4OTEgMTEgMjAuMDg3ODkxIDExIEMgMTkuMjcyODkxIDExIDE4LjQ3NzY4OCAxMC42MTk3MzQgMTcuNTU0Njg4IDEwLjE3NzczNCBDIDE2LjQwMzY4NyA5LjYyNTczNDQgMTUuMDk4MzU5IDkgMTMuNDQzMzU5IDkgQyAxMi4zMDgyNTcgOSAxMS40MjE2ODcgOS4xODgzMzkzIDEwLjcxMjg5MSA5LjQ1NzAzMTIgQyAxMS40ODkwNzEgOC45MTQxODI0IDEyIDguMDE2NzgwMiAxMiA3IEMgMTIgNS4zNDYgMTAuNjU0IDQgOSA0IHogTSA5IDYgQyA5LjU1MiA2IDEwIDYuNDQ5IDEwIDcgQyAxMCA3LjU1MSA5LjU1MiA4IDkgOCBDIDguNDQ4IDggOCA3LjU1MSA4IDcgQyA4IDYuNDQ5IDguNDQ4IDYgOSA2IHogTSAxMy40NDMzNTkgMTEgQyAxNC42NDUzNTkgMTEgMTUuNjM4NDA2IDExLjQ3NjQ2OSAxNi42OTE0MDYgMTEuOTgwNDY5IEMgMTcuNzM2NDA2IDEyLjQ4MjQ2OSAxOC44MTc4OTEgMTMgMjAuMDg3ODkxIDEzIEMgMjEuODQyODkxIDEzIDIzLjE1ODA0NyAxMi4wNTQ0ODQgMjMuOTk4MDQ3IDExLjM5NjQ4NCBMIDIzLjk5ODA0NyAxOS4wNjY0MDYgQyAyMy45OTcwNDcgMTkuMDcwNDA2IDIzLjk1Mjk4NCAxOS4xNDUyNjYgMjMuNzA4OTg0IDE5LjMyMjI2NiBMIDIzLjUwOTc2NiAxOS40NzQ2MDkgQyAyMi45NDI3NjYgMTkuOTEyNjA5IDIxLjc2Mjg5MSAyMC44MjQyMTkgMjAuMDg3ODkxIDIwLjgyNDIxOSBDIDE5LjI0OTg5MSAyMC44MjQyMTkgMTguNDQ2NjI1IDIwLjQ4MjkzNyAxNy41MTU2MjUgMjAuMDg1OTM4IEMgMTYuMzcyNjI1IDE5LjU5NzkzOCAxNS4wNzYzNTkgMTkuMDQ0OTIyIDEzLjQ0MzM1OSAxOS4wNDQ5MjIgQyAxMS44OTEzNTkgMTkuMDQ0OTIyIDEwLjc4NiAxOS4zNTggMTAgMTkuNzUgTCAxMCAxMi4zNjEzMjggQyAxMC4zNDUgMTEuOTA1MzI4IDExLjEzMjM1OSAxMSAxMy40NDMzNTkgMTEgeiIvPjwvc3ZnPg==";
var recent = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuODMyMDMxIDQgOC4xNTIzNDQgNi4xMTMyODEgNiA5LjM0Mzc1IEwgNiA2IEwgNCA2IEwgNCAxMyBMIDExIDEzIEwgMTEgMTEgTCA3LjM3NSAxMSBDIDkuMTAxNTYzIDguMDE5NTMxIDEyLjI5Njg3NSA2IDE2IDYgQyAyMS41MzUxNTYgNiAyNiAxMC40NjQ4NDQgMjYgMTYgQyAyNiAyMS41MzUxNTYgMjEuNTM1MTU2IDI2IDE2IDI2IEMgMTAuNDY0ODQ0IDI2IDYgMjEuNTM1MTU2IDYgMTYgTCA0IDE2IEMgNCAyMi42MTcxODggOS4zODI4MTMgMjggMTYgMjggQyAyMi42MTcxODggMjggMjggMjIuNjE3MTg4IDI4IDE2IEMgMjggOS4zODI4MTMgMjIuNjE3MTg4IDQgMTYgNCBaIE0gMTUgOCBMIDE1IDE3IEwgMjIgMTcgTCAyMiAxNSBMIDE3IDE1IEwgMTcgOCBaIi8+PC9zdmc+Cg==";
const _sfc_main$3$1 = defineComponent({
  name: "Header",
  setup(props) {
    const { state, updateSearch, updateActiveGroup } = inject("store");
    const hasSearch = computed(() => !state.options.hideSearch);
    const hasGroupIcons = computed(() => !state.options.hideGroupIcons);
    const orderedKeys = JSON.parse(JSON.stringify(state.orderedGroupKeys));
    const placeholder = computed(() => state.options.staticTexts.placeholder || "");
    const searchValue = computed({
      get: () => state.search,
      set: (value) => updateSearch(value)
    });
    const groups = [
      ...state.groups,
      ...Object.keys(state.options.additionalGroups).map((g2) => ({
        key: g2,
        title: state.options.groupNames[g2] ? state.options.groupNames[g2] : snakeToCapitalizedCase(g2)
      }))
    ];
    const orderedGroups = [];
    orderedKeys.forEach((key) => {
      const index2 = groups.findIndex((group) => group.key === key);
      if (index2 === -1)
        return;
      orderedGroups.push(groups[index2]);
      groups.splice(index2, 1);
    });
    return {
      orderedGroups,
      orderedKeys,
      searchValue,
      updateActiveGroup,
      hasSearch,
      hasGroupIcons,
      placeholder,
      icons: __spreadProps(__spreadValues({
        smileys_people,
        animals_nature,
        food_drink,
        activities,
        travel_places,
        objects,
        symbols,
        flags
      }, state.options.groupIcons), {
        recent
      })
    };
  }
});
const _hoisted_1$2$1 = {
  key: 0,
  class: "v3-header"
};
const _hoisted_2$2$1 = {
  key: 0,
  class: "v3-groups"
};
const _hoisted_3$2$1 = ["onClick"];
const _hoisted_4$2$1 = ["title"];
const _hoisted_5$2$1 = ["src"];
const _hoisted_6$1$1 = {
  key: 1,
  class: "v3-spacing"
};
const _hoisted_7$a = {
  key: 2,
  class: "v3-search"
};
const _hoisted_8$a = ["placeholder"];
function _sfc_render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hasGroupIcons || _ctx.hasSearch ? (openBlock(), createElementBlock("div", _hoisted_1$2$1, [
    _ctx.hasGroupIcons ? (openBlock(), createElementBlock("div", _hoisted_2$2$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orderedGroups, (group) => {
        return openBlock(), createElementBlock("button", {
          key: group.key,
          type: "button",
          class: normalizeClass(["v3-group", {
            "v3-is-hidden": !_ctx.icons[group.key]
          }]),
          onClick: ($event) => _ctx.updateActiveGroup(group.key)
        }, [
          createBaseVNode("span", {
            title: group.title,
            class: "v3-icon"
          }, [
            createBaseVNode("img", {
              src: _ctx.icons[group.key],
              alt: ""
            }, null, 8, _hoisted_5$2$1)
          ], 8, _hoisted_4$2$1)
        ], 10, _hoisted_3$2$1);
      }), 128))
    ])) : createCommentVNode("", true),
    _ctx.hasGroupIcons && _ctx.hasSearch ? (openBlock(), createElementBlock("div", _hoisted_6$1$1)) : createCommentVNode("", true),
    _ctx.hasSearch ? (openBlock(), createElementBlock("div", _hoisted_7$a, [
      withDirectives(createBaseVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchValue = $event),
        type: "text",
        placeholder: _ctx.placeholder
      }, null, 8, _hoisted_8$a), [
        [vModelText, _ctx.searchValue]
      ])
    ])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$3$1, [["render", _sfc_render$3$1]]);
const _sfc_main$2$1 = defineComponent({
  name: "Header",
  setup() {
    const { state, updateSkinTone } = inject("store");
    const skinTone = ref(false);
    const hasError = ref(false);
    const stateSkinTone = computed(() => state.skinTone);
    const skinToneText = computed(() => state.options.staticTexts.skinTone || "Skin tone");
    const hasSkinTones = computed(() => !state.options.disableSkinTones);
    const platform = isMac() ? "is-mac" : "";
    const emoji = computed(() => {
      return __spreadProps(__spreadValues({}, state.emoji), {
        src: EMOJI_REMOTE_SRC + "/" + state.emoji[EMOJI_RESULT_KEY] + ".png"
      });
    });
    function updateSkinToneState(open = true) {
      skinTone.value = open;
    }
    function toggleSkinToneState() {
      skinTone.value = !skinTone.value;
    }
    function selectSkinTone(tone) {
      updateSkinTone(tone);
      updateSkinToneState(false);
    }
    watch(() => state.emoji, () => {
      hasError.value = false;
    });
    return {
      emoji,
      SKIN_TONES,
      updateSkinToneState,
      skinTone,
      stateSkinTone,
      selectSkinTone,
      toggleSkinToneState,
      EMOJI_RESULT_KEY,
      EMOJI_NAME_KEY,
      skinToneText,
      hasSkinTones,
      native: state.options.native,
      unicodeToEmoji,
      platform,
      hasError
    };
  }
});
const _hoisted_1$1$1 = { class: "v3-foot-left" };
const _hoisted_2$1$1 = { key: 0 };
const _hoisted_3$1$1 = ["alt", "src"];
const _hoisted_4$1$1 = { class: "v3-text" };
const _hoisted_5$1$1 = { class: "v3-text" };
const _hoisted_6$a = ["onClick"];
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "v3-footer",
    onMouseleave: _cache[2] || (_cache[2] = ($event) => _ctx.updateSkinToneState(false))
  }, [
    createBaseVNode("div", _hoisted_1$1$1, [
      createBaseVNode("span", {
        class: normalizeClass([_ctx.platform, "v3-icon"])
      }, [
        _ctx.native || _ctx.hasError ? (openBlock(), createElementBlock("span", _hoisted_2$1$1, toDisplayString(_ctx.unicodeToEmoji(_ctx.emoji.r)), 1)) : (openBlock(), createElementBlock("img", {
          key: 1,
          alt: _ctx.unicodeToEmoji(_ctx.emoji.r),
          src: _ctx.emoji.src,
          onError: _cache[0] || (_cache[0] = ($event) => _ctx.hasError = true)
        }, null, 40, _hoisted_3$1$1))
      ], 2),
      createBaseVNode("span", _hoisted_4$1$1, " :" + toDisplayString(_ctx.emoji[_ctx.EMOJI_NAME_KEY][1] || _ctx.emoji[_ctx.EMOJI_NAME_KEY][0]) + ": ", 1)
    ]),
    _ctx.hasSkinTones ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createBaseVNode("button", {
        type: "button",
        class: "v3-tone",
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggleSkinToneState && _ctx.toggleSkinToneState(...args))
      }, [
        createBaseVNode("span", _hoisted_5$1$1, toDisplayString(_ctx.skinToneText), 1),
        createBaseVNode("span", {
          class: normalizeClass(`v3-icon v3-tone-${_ctx.stateSkinTone}`)
        }, null, 2)
      ]),
      createBaseVNode("div", {
        class: normalizeClass([_ctx.skinTone ? "v3-is-open" : "", "v3-skin-tones"])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.SKIN_TONES, (tone) => {
          return openBlock(), createElementBlock("button", {
            key: tone,
            type: "button",
            class: normalizeClass(["v3-skin-tone-" + tone, "v3-skin-tone"]),
            onClick: ($event) => _ctx.selectSkinTone(tone)
          }, null, 10, _hoisted_6$a);
        }), 128))
      ], 2)
    ], 64)) : createCommentVNode("", true)
  ], 32);
}
var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$2$1, [["render", _sfc_render$2$1]]);
const _sfc_main$1$1 = defineComponent({
  name: "PickerRoot",
  components: {
    Header,
    Body,
    Footer
  },
  props: {
    type: {
      type: String,
      default: ""
    },
    text: {
      type: String,
      default: ""
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    groupNames: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:text", "select"],
  setup(props, { emit: emit2 }) {
    const elem = ref();
    const button = ref();
    const picker = ref();
    const open = ref(false);
    const input = ref(props.text);
    const isInputType = props.type === "input" || props.type === "textarea";
    let cursor = -1;
    const { state } = inject("store");
    const colorTheme = computed(() => state.options.colorTheme);
    function onSelect(emoji) {
      if (isInputType) {
        const mode = state.options.mode;
        if (mode === "prepend") {
          input.value = emoji.i + input.value;
        } else if (mode === "insert" && cursor !== -1) {
          input.value = `${input.value.slice(0, cursor)}${emoji.i}${input.value.slice(cursor)}`;
          cursor += emoji.i.length;
        } else {
          input.value += emoji.i;
        }
        emit2("update:text", input.value);
      }
      emit2("select", emoji);
    }
    function updateCursor() {
      var _a;
      if (elem.value) {
        cursor = ((_a = elem.value) == null ? void 0 : _a.selectionEnd) || -1;
      }
    }
    function clickListener(event) {
      var _a;
      const isOutside = !((_a = event.target) == null ? void 0 : _a.closest(".v3-input-picker-wrap"));
      if (isOutside && open.value) {
        open.value = false;
      }
    }
    function setupPopper() {
      if (button.value && picker.value && isInputType) {
        let offset2 = state.options.offset;
        if (typeof offset2 !== "number") {
          offset2 = 6;
        }
        createPopper(button.value, picker.value, {
          placement: "bottom-end",
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, offset2]
              }
            }
          ]
        });
        document.body.addEventListener("click", clickListener);
      }
    }
    function onChangeText(event) {
      input.value = event.target.value || "";
      emit2("update:text", input.value);
    }
    onMounted(() => {
      setupPopper();
    });
    onBeforeUnmount(() => {
      document.body.removeEventListener("click", clickListener);
    });
    return {
      face: smileys_people,
      open,
      onSelect,
      input,
      elem,
      updateCursor,
      button,
      picker,
      isInputType,
      onChangeText,
      colorTheme
    };
  }
});
const _hoisted_1$a = {
  key: 0,
  class: "v3-input-emoji-picker"
};
const _hoisted_2$a = { class: "v3-input-picker-root" };
const _hoisted_3$a = ["value"];
const _hoisted_4$a = ["value"];
const _hoisted_5$a = ["src"];
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Header = resolveComponent("Header");
  const _component_Body = resolveComponent("Body");
  const _component_Footer = resolveComponent("Footer");
  return _ctx.isInputType ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
    createBaseVNode("div", _hoisted_2$a, [
      _ctx.type === "input" ? (openBlock(), createElementBlock("input", {
        key: 0,
        ref: "elem",
        value: _ctx.input,
        type: "text",
        class: "v3-emoji-picker-input",
        onInput: _cache[0] || (_cache[0] = (...args) => _ctx.onChangeText && _ctx.onChangeText(...args)),
        onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.updateCursor && _ctx.updateCursor(...args))
      }, null, 40, _hoisted_3$a)) : (openBlock(), createElementBlock("textarea", {
        key: 1,
        ref: "elem",
        value: _ctx.input,
        class: "v3-emoji-picker-textarea",
        onInput: _cache[2] || (_cache[2] = (...args) => _ctx.onChangeText && _ctx.onChangeText(...args)),
        onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.updateCursor && _ctx.updateCursor(...args))
      }, null, 40, _hoisted_4$a)),
      createBaseVNode("div", {
        class: normalizeClass(["v3-input-picker-wrap", _ctx.open ? "v3-picker-is-open" : ""])
      }, [
        createBaseVNode("button", {
          ref: "button",
          type: "button",
          class: "v3-input-picker-icon",
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.open = !_ctx.open)
        }, [
          createBaseVNode("img", {
            src: _ctx.face,
            alt: ""
          }, null, 8, _hoisted_5$a)
        ], 512),
        createBaseVNode("div", {
          ref: "picker",
          class: normalizeClass(["v3-emoji-picker", "v3-color-theme-" + _ctx.colorTheme])
        }, [
          createVNode(_component_Header),
          createVNode(_component_Body, { onSelect: _ctx.onSelect }, null, 8, ["onSelect"]),
          createVNode(_component_Footer)
        ], 2)
      ], 2)
    ])
  ])) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["v3-emoji-picker", "v3-color-theme-" + _ctx.colorTheme])
  }, [
    createVNode(_component_Header),
    createVNode(_component_Body, { onSelect: _ctx.onSelect }, null, 8, ["onSelect"]),
    createVNode(_component_Footer)
  ], 2));
}
var PickerRoot = /* @__PURE__ */ _export_sfc$1(_sfc_main$1$1, [["render", _sfc_render$1$1]]);
const _sfc_main$a = defineComponent({
  name: "Picker",
  components: {
    PickerRoot
  },
  props: {
    native: {
      type: Boolean,
      default: false
    },
    hideSearch: {
      type: Boolean,
      default: false
    },
    hideGroupIcons: {
      type: Boolean,
      default: false
    },
    hideGroupNames: {
      type: Boolean,
      default: false
    },
    staticTexts: {
      type: Object,
      default: () => ({})
    },
    disableStickyGroupNames: {
      type: Boolean,
      default: false
    },
    disabledGroups: {
      type: Array,
      default: () => []
    },
    groupNames: {
      type: Object,
      default: () => ({})
    },
    disableSkinTones: {
      type: Boolean,
      default: false
    },
    text: {
      type: String,
      default: ""
    },
    mode: {
      type: String,
      default: "insert"
    },
    offset: {
      type: Number,
      default: 6
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    pickerType: {
      type: String,
      default: ""
    },
    displayRecent: {
      type: Boolean,
      default: false
    },
    theme: {
      type: String,
      default: "light"
    }
  },
  emits: ["update:text", "select"],
  setup(props, { emit: emit2 }) {
    const input = ref(props.text);
    function onChangeText(text) {
      input.value = text || "";
      emit2("update:text", input.value);
    }
    const store = Store();
    store.updateOptions({
      native: props.native,
      hideSearch: props.hideSearch,
      hideGroupIcons: props.hideGroupIcons,
      hideGroupNames: props.hideGroupNames,
      staticTexts: __spreadValues(__spreadValues({}, STATIC_TEXTS), props.staticTexts),
      disableStickyGroupNames: props.disableStickyGroupNames,
      disabledGroups: props.disabledGroups,
      groupNames: __spreadValues(__spreadValues({}, GROUP_NAMES), props.groupNames),
      disableSkinTones: props.disableSkinTones,
      displayRecent: props.displayRecent,
      additionalGroups: props.additionalGroups,
      mode: props.mode,
      offset: props.offset,
      groupOrder: props.groupOrder,
      groupIcons: props.groupIcons,
      colorTheme: COLOR_THEMES.includes(props.theme) ? props.theme : "light"
    });
    provide("store", store);
    return {
      type: props.pickerType,
      input,
      onChangeText
    };
  }
});
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_picker_root = resolveComponent("picker-root");
  return openBlock(), createBlock(_component_picker_root, {
    type: _ctx.type,
    text: _ctx.input,
    onSelect: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("select", $event)),
    "onUpdate:text": _ctx.onChangeText
  }, null, 8, ["type", "text", "onUpdate:text"]);
}
var Picker = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$a]]);
var wildemitter = WildEmitter$1;
function WildEmitter$1() {
}
WildEmitter$1.mixin = function(constructor) {
  var prototype = constructor.prototype || constructor;
  prototype.isWildEmitter = true;
  prototype.on = function(event, groupName, fn2) {
    this.callbacks = this.callbacks || {};
    var hasGroup = arguments.length === 3, group = hasGroup ? arguments[1] : void 0, func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
  };
  prototype.once = function(event, groupName, fn2) {
    var self2 = this, hasGroup = arguments.length === 3, group = hasGroup ? arguments[1] : void 0, func = hasGroup ? arguments[2] : arguments[1];
    function on() {
      self2.off(event, on);
      func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
  };
  prototype.releaseGroup = function(groupName) {
    this.callbacks = this.callbacks || {};
    var item, i2, len, handlers;
    for (item in this.callbacks) {
      handlers = this.callbacks[item];
      for (i2 = 0, len = handlers.length; i2 < len; i2++) {
        if (handlers[i2]._groupName === groupName) {
          handlers.splice(i2, 1);
          i2--;
          len--;
        }
      }
    }
    return this;
  };
  prototype.off = function(event, fn2) {
    this.callbacks = this.callbacks || {};
    var callbacks = this.callbacks[event], i2;
    if (!callbacks)
      return this;
    if (arguments.length === 1) {
      delete this.callbacks[event];
      return this;
    }
    i2 = callbacks.indexOf(fn2);
    if (i2 !== -1) {
      callbacks.splice(i2, 1);
      if (callbacks.length === 0) {
        delete this.callbacks[event];
      }
    }
    return this;
  };
  prototype.emit = function(event) {
    this.callbacks = this.callbacks || {};
    var args = [].slice.call(arguments, 1), callbacks = this.callbacks[event], specialCallbacks = this.getWildcardCallbacks(event), i2, len, listeners;
    if (callbacks) {
      listeners = callbacks.slice();
      for (i2 = 0, len = listeners.length; i2 < len; ++i2) {
        if (!listeners[i2]) {
          break;
        }
        listeners[i2].apply(this, args);
      }
    }
    if (specialCallbacks) {
      len = specialCallbacks.length;
      listeners = specialCallbacks.slice();
      for (i2 = 0, len = listeners.length; i2 < len; ++i2) {
        if (!listeners[i2]) {
          break;
        }
        listeners[i2].apply(this, [event].concat(args));
      }
    }
    return this;
  };
  prototype.getWildcardCallbacks = function(eventName) {
    this.callbacks = this.callbacks || {};
    var item, split, result = [];
    for (item in this.callbacks) {
      split = item.split("*");
      if (item === "*" || split.length === 2 && eventName.slice(0, split[0].length) === split[0]) {
        result = result.concat(this.callbacks[item]);
      }
    }
    return result;
  };
};
WildEmitter$1.mixin(WildEmitter$1);
var WildEmitter = wildemitter;
function getMaxVolume(analyser, fftBins) {
  var maxVolume = -Infinity;
  analyser.getFloatFrequencyData(fftBins);
  for (var i2 = 4, ii = fftBins.length; i2 < ii; i2++) {
    if (fftBins[i2] > maxVolume && fftBins[i2] < 0) {
      maxVolume = fftBins[i2];
    }
  }
  return maxVolume;
}
var audioContextType;
if (typeof window !== "undefined") {
  audioContextType = window.AudioContext || window.webkitAudioContext;
}
var audioContext = null;
var hark = function(stream, options) {
  var harker = new WildEmitter();
  if (!audioContextType)
    return harker;
  var options = options || {}, smoothing = options.smoothing || 0.1, interval = options.interval || 50, threshold = options.threshold, play = options.play, history2 = options.history || 10, running = true;
  audioContext = options.audioContext || audioContext || new audioContextType();
  var sourceNode, fftBins, analyser;
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 512;
  analyser.smoothingTimeConstant = smoothing;
  fftBins = new Float32Array(analyser.frequencyBinCount);
  if (stream.jquery)
    stream = stream[0];
  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {
    sourceNode = audioContext.createMediaElementSource(stream);
    if (typeof play === "undefined")
      play = true;
    threshold = threshold || -50;
  } else {
    sourceNode = audioContext.createMediaStreamSource(stream);
    threshold = threshold || -50;
  }
  sourceNode.connect(analyser);
  if (play)
    analyser.connect(audioContext.destination);
  harker.speaking = false;
  harker.suspend = function() {
    return audioContext.suspend();
  };
  harker.resume = function() {
    return audioContext.resume();
  };
  Object.defineProperty(harker, "state", { get: function() {
    return audioContext.state;
  } });
  audioContext.onstatechange = function() {
    harker.emit("state_change", audioContext.state);
  };
  harker.setThreshold = function(t) {
    threshold = t;
  };
  harker.setInterval = function(i3) {
    interval = i3;
  };
  harker.stop = function() {
    running = false;
    harker.emit("volume_change", -100, threshold);
    if (harker.speaking) {
      harker.speaking = false;
      harker.emit("stopped_speaking");
    }
    analyser.disconnect();
    sourceNode.disconnect();
  };
  harker.speakingHistory = [];
  for (var i2 = 0; i2 < history2; i2++) {
    harker.speakingHistory.push(0);
  }
  var looper = function() {
    setTimeout(function() {
      if (!running) {
        return;
      }
      var currentVolume = getMaxVolume(analyser, fftBins);
      harker.emit("volume_change", currentVolume, threshold);
      var history3 = 0;
      if (currentVolume > threshold && !harker.speaking) {
        for (var i3 = harker.speakingHistory.length - 3; i3 < harker.speakingHistory.length; i3++) {
          history3 += harker.speakingHistory[i3];
        }
        if (history3 >= 2) {
          harker.speaking = true;
          harker.emit("speaking");
        }
      } else if (currentVolume < threshold && harker.speaking) {
        for (var i3 = 0; i3 < harker.speakingHistory.length; i3++) {
          history3 += harker.speakingHistory[i3];
        }
        if (history3 == 0) {
          harker.speaking = false;
          harker.emit("stopped_speaking");
        }
      }
      harker.speakingHistory.shift();
      harker.speakingHistory.push(0 + (currentVolume > threshold));
      looper();
    }, interval);
  };
  looper();
  return harker;
};
const hark$1 = /* @__PURE__ */ getDefaultExportFromCjs(hark);
const AlertModal_vue_vue_type_style_index_0_scoped_776897ce_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$9 = {
  props: {
    visible: Boolean,
    isConfirm: Boolean,
    title: String,
    icon: String,
    message: String
  },
  data() {
    return {
      username: ""
    };
  },
  mounted() {
    window.addEventListener("keyup", (e) => {
      if (!this.visible)
        return;
      if (e.key === "Enter") {
        return this.callback();
      }
      if (e.key == "Escape") {
        return this.close();
      }
    });
  },
  methods: {
    callback() {
      this.$emit("close");
      this.$emit("callback");
    },
    close() {
      this.$emit("close");
    }
  }
};
const _withScopeId$1 = (n2) => (pushScopeId("data-v-776897ce"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$9 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1));
const _hoisted_2$9 = { class: "modal-content" };
const _hoisted_3$9 = { class: "card" };
const _hoisted_4$9 = { class: "card-header has-background-info" };
const _hoisted_5$9 = { class: "card-header-title" };
const _hoisted_6$9 = { class: "card-content" };
const _hoisted_7$9 = { class: "literal mb-4" };
const _hoisted_8$9 = { class: "columns is-centered is-mobile" };
const _hoisted_9$9 = { class: "column is-narrow" };
const _hoisted_10$9 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("button", {
  type: "submit",
  class: "button is-success px-5"
}, " OK ", -1));
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["modal", { "is-active": $props.visible }])
  }, [
    _hoisted_1$9,
    createBaseVNode("div", _hoisted_2$9, [
      createBaseVNode("div", _hoisted_3$9, [
        createBaseVNode("header", _hoisted_4$9, [
          createBaseVNode("p", _hoisted_5$9, [
            $props.icon ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass([$props.icon, "mr-2"])
            }, null, 2)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString($props.title), 1)
          ]),
          createBaseVNode("button", {
            class: "delete mr-3 mt-3",
            "aria-label": "close",
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.close && $options.close(...args), ["prevent"]))
          })
        ]),
        createBaseVNode("div", _hoisted_6$9, [
          createBaseVNode("form", {
            onSubmit: _cache[2] || (_cache[2] = withModifiers(($event) => $options.callback(), ["prevent"]))
          }, [
            createBaseVNode("p", _hoisted_7$9, toDisplayString($props.message), 1),
            createBaseVNode("div", _hoisted_8$9, [
              createBaseVNode("div", _hoisted_9$9, [
                _hoisted_10$9,
                $props.isConfirm ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  class: "button is-link ml-3 px-5",
                  onClick: _cache[1] || (_cache[1] = (...args) => $options.close && $options.close(...args))
                }, " Cancel ")) : createCommentVNode("", true)
              ])
            ])
          ], 32)
        ])
      ])
    ])
  ], 2);
}
const AlertModal = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-776897ce"]]);
const _sfc_main$8 = {
  props: {
    visible: Boolean
  },
  data() {
    return {
      username: ""
    };
  },
  methods: {
    signIn() {
      this.$emit("signIn", this.username);
    }
  }
};
const _hoisted_1$8 = /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1);
const _hoisted_2$8 = { class: "modal-content" };
const _hoisted_3$8 = { class: "card" };
const _hoisted_4$8 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-info" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "Sign In")
], -1);
const _hoisted_5$8 = { class: "card-content" };
const _hoisted_6$8 = {
  key: 0,
  class: "content"
};
const _hoisted_7$8 = ["innerHTML"];
const _hoisted_8$8 = /* @__PURE__ */ createBaseVNode("p", null, " This dialog box is added as an experiment to see whether it helps iOS devices (iPads and iPhones) to log in to the chat more reliably, by having you interact with the page before it connects to the server. Let us know in chat if your iPhone or iPad is able to log in this way! ", -1);
const _hoisted_9$8 = { class: "field" };
const _hoisted_10$8 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Username", -1);
const _hoisted_11$7 = ["disabled"];
const _hoisted_12$7 = /* @__PURE__ */ createBaseVNode("div", { class: "field" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "control" }, [
    /* @__PURE__ */ createBaseVNode("button", { class: "button is-link" }, "Enter Chat")
  ])
], -1);
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["modal", { "is-active": $props.visible }])
  }, [
    _hoisted_1$8,
    createBaseVNode("div", _hoisted_2$8, [
      createBaseVNode("div", _hoisted_3$8, [
        _hoisted_4$8,
        createBaseVNode("div", _hoisted_5$8, [
          createBaseVNode("form", {
            onSubmit: _cache[1] || (_cache[1] = withModifiers(($event) => $options.signIn(), ["prevent"]))
          }, [
            _ctx.autoLogin ? (openBlock(), createElementBlock("div", _hoisted_6$8, [
              createBaseVNode("p", null, [
                createTextVNode(" Welcome to "),
                createBaseVNode("span", {
                  innerHTML: _ctx.config.branding
                }, null, 8, _hoisted_7$8),
                createTextVNode('! Please just click on the "Enter Chat" button below to log on. Your username has been pre-filled from the website that sent you here. ')
              ]),
              _hoisted_8$8
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_9$8, [
              _hoisted_10$8,
              withDirectives(createBaseVNode("input", {
                class: "input",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.username = $event),
                placeholder: "Username",
                autocomplete: "off",
                autofocus: "",
                disabled: _ctx.autoLogin,
                required: ""
              }, null, 8, _hoisted_11$7), [
                [vModelText, $data.username]
              ])
            ]),
            _hoisted_12$7
          ], 32)
        ])
      ])
    ])
  ], 2);
}
const LoginModal = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const _sfc_main$7 = {
  props: {
    visible: Boolean,
    user: Object
  },
  data() {
    return {
      dontShowAgain: false
    };
  },
  methods: {
    accept() {
      if (this.dontShowAgain) {
        this.$emit("dont-show-again");
      }
      this.$emit("accept");
    },
    cancel() {
      this.$emit("cancel");
    }
  }
};
const _hoisted_1$7 = /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1);
const _hoisted_2$7 = { class: "modal-content" };
const _hoisted_3$7 = { class: "card" };
const _hoisted_4$7 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-info" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "This camera may contain Explicit content")
], -1);
const _hoisted_5$7 = { class: "card-content" };
const _hoisted_6$7 = /* @__PURE__ */ createStaticVNode('<p class="block"> This camera has been marked as &quot;Explicit/<abbr title="Not Safe For Work">NSFW</abbr>&quot; and may contain displays of sexuality. If you do not want to see this, look for cameras with a <span class="button is-small is-info is-outlined px-1"><i class="fa fa-video"></i></span> blue icon rather than the <span class="button is-small is-danger is-outlined px-1"><i class="fa fa-video"></i></span> red ones. </p>', 1);
const _hoisted_7$7 = { class: "field" };
const _hoisted_8$7 = { class: "checkbox" };
const _hoisted_9$7 = { class: "field" };
const _hoisted_10$7 = { class: "control has-text-centered" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["modal", { "is-active": $props.visible }])
  }, [
    _hoisted_1$7,
    createBaseVNode("div", _hoisted_2$7, [
      createBaseVNode("div", _hoisted_3$7, [
        _hoisted_4$7,
        createBaseVNode("div", _hoisted_5$7, [
          _hoisted_6$7,
          createBaseVNode("div", _hoisted_7$7, [
            createBaseVNode("label", _hoisted_8$7, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.dontShowAgain = $event)
              }, null, 512), [
                [vModelCheckbox, $data.dontShowAgain]
              ]),
              createTextVNode(" Don't show this message again ")
            ])
          ]),
          createBaseVNode("div", _hoisted_9$7, [
            createBaseVNode("div", _hoisted_10$7, [
              createBaseVNode("button", {
                type: "button",
                class: "button is-link mr-4",
                onClick: _cache[1] || (_cache[1] = ($event) => $options.accept())
              }, " Open webcam "),
              createBaseVNode("button", {
                type: "button",
                class: "button",
                onClick: _cache[2] || (_cache[2] = ($event) => $options.cancel())
              }, " Cancel ")
            ])
          ])
        ])
      ])
    ])
  ], 2);
}
const ExplicitOpenModal = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const keys = {
  "fontSizeClass": String,
  // Text magnification
  "videoScale": String,
  // Video magnification (CSS classnames)
  "messageStyle": String,
  // Message display style (cards, compact, etc.)
  "imageDisplaySetting": String,
  // Show/hide/expand image preference
  "scrollback": Number,
  // Scrollback buffer (int)
  "preferredDeviceNames": Object,
  // Webcam/mic device names (object, keys video,audio)
  "whoSort": String,
  // user's preferred sort order for the Who List
  "theme": String,
  // light, dark, or auto theme
  // Webcam settings (booleans)
  "videoMutual": Boolean,
  "videoMutualOpen": Boolean,
  "videoAutoMute": Boolean,
  "videoVipOnly": Boolean,
  "videoExplicit": Boolean,
  // whether the user turns explicit on by default
  "videoNonExplicit": Boolean,
  // user prefers not to see explicit
  "rememberExpresslyClosed": Boolean,
  "autoMuteWebcams": Boolean,
  // automatically mute other peoples' webcam audio feeds
  "videoAutoShare": Boolean,
  // automatically share your webcam on page load
  // Booleans
  "usePolling": Boolean,
  // use the polling API instead of WebSocket
  "joinMessages": Boolean,
  "exitMessages": Boolean,
  "watchNotif": Boolean,
  "muteSounds": Boolean,
  "closeDMs": Boolean,
  // close unsolicited DMs
  "debug": Boolean,
  // Debug views enabled (admin only)
  // Don't Show Again on NSFW modals.
  "skip-nsfw-modal": Boolean
};
class UserSettings {
  constructor() {
    for (let key of Object.keys(keys)) {
      if (localStorage[key] != void 0) {
        try {
          this[key] = JSON.parse(localStorage[key]);
        } catch (e) {
          console.error(`LocalStorage: parsing key ${key}: ${e}`);
          delete this[key];
        }
      }
    }
    console.log("LocalStorage: Loaded settings", this);
  }
  // Return all of the current settings where the user had actually
  // left a preference on them (was in localStorage).
  getSettings() {
    let result = {};
    for (let key of Object.keys(keys)) {
      if (this[key] != void 0) {
        result[key] = this[key];
      }
    }
    return result;
  }
  // Get a value from localStorage, if set.
  get(key) {
    return this[key];
  }
  // Generic setter.
  set(key, value) {
    if (keys[key] == void 0) {
      throw `${key}: not a supported localStorage setting`;
    }
    localStorage[key] = JSON.stringify(value);
    this[key] = value;
  }
}
const LocalStorage = new UserSettings();
const _sfc_main$6 = {
  props: {
    username: String,
    message: String
  },
  data() {
    return {};
  },
  computed: {
    // Message sans HTML tags, so we don't false positive on base64-encoded image data.
    filteredMessage() {
      return this.message.replace(/<(.|\n)+?>/g, "");
    },
    // Scam/spam detection and warning.
    maybeWhatsAppScam() {
      return this.filteredMessage.match(/whats\s*app/i);
    },
    maybePhoneNumberScam() {
      return this.filteredMessage.match(/\b(phone number|phone|digits|cell number|your number|ur number|text me)\b/i);
    },
    maybeOffPlatformScam() {
      return this.filteredMessage.match(/\b(telegram|signal|kik)\b/i);
    }
  },
  methods: {}
};
const _hoisted_1$6 = {
  key: 0,
  class: "notification is-danger is-light px-3 py-2 my-2"
};
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("strong", { class: "has-text-danger" }, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-exclamation-triangle mr-1" }),
  /* @__PURE__ */ createTextVNode(" Be careful about possible scams! ")
], -1);
const _hoisted_3$6 = /* @__PURE__ */ createBaseVNode("i", { class: "fab fa-whatsapp" }, null, -1);
const _hoisted_4$6 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_5$6 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_6$6 = /* @__PURE__ */ createBaseVNode("strong", null, [
  /* @__PURE__ */ createTextVNode("Be especially skeptical of "),
  /* @__PURE__ */ createBaseVNode("i", { class: "fab fa-whatsapp" }),
  /* @__PURE__ */ createTextVNode(" WhatsApp")
], -1);
const _hoisted_7$6 = /* @__PURE__ */ createBaseVNode("strong", null, "a lot", -1);
const _hoisted_8$6 = {
  key: 1,
  class: "notification is-danger is-light px-3 py-2 my-2"
};
const _hoisted_9$6 = /* @__PURE__ */ createBaseVNode("strong", { class: "has-text-danger" }, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-exclamation-triangle mr-1" }),
  /* @__PURE__ */ createTextVNode(" Be careful about possible scams! ")
], -1);
const _hoisted_10$6 = {
  key: 2,
  class: "notification is-danger is-light px-3 py-2 my-2"
};
const _hoisted_11$6 = /* @__PURE__ */ createBaseVNode("strong", { class: "has-text-danger" }, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-exclamation-triangle mr-1" }),
  /* @__PURE__ */ createTextVNode(" Be careful about possible scams! ")
], -1);
const _hoisted_12$6 = /* @__PURE__ */ createBaseVNode("strong", null, "a lot", -1);
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.maybeWhatsAppScam ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
    _hoisted_2$6,
    createTextVNode(" It sounds like @" + toDisplayString($props.username) + " is talking about moving this conversation to ", 1),
    _hoisted_3$6,
    createTextVNode(" WhatsApp. If this happened within the first couple of messages, be wary! It is a well-known tactic for con artists to move your conversation away to another platform as soon as possible, in order to evade detection from the website. "),
    _hoisted_4$6,
    _hoisted_5$6,
    _hoisted_6$6,
    createTextVNode(" or trading phone numbers. Scammers can do "),
    _hoisted_7$6,
    createTextVNode(" of harm with just your phone number, e.g. by plugging it into a people search website and bringing up lots of personal information about you. ")
  ])) : $options.maybeOffPlatformScam ? (openBlock(), createElementBlock("div", _hoisted_8$6, [
    _hoisted_9$6,
    createTextVNode(" It sounds like @" + toDisplayString($props.username) + " is talking about moving this conversation to another messenger platform. If this happened within the first couple of messages, be wary! It is a well-known tactic for con artists to move your conversation away to another platform as soon as possible, in order to evade detection from the website. ", 1)
  ])) : $options.maybePhoneNumberScam ? (openBlock(), createElementBlock("div", _hoisted_10$6, [
    _hoisted_11$6,
    createTextVNode(" It sounds like @" + toDisplayString($props.username) + " may want to get your phone number. If this happened within the first couple of messages, be wary! Scammers can do ", 1),
    _hoisted_12$6,
    createTextVNode(" of harm with just your phone number, e.g. by plugging it into a people search website and bringing up lots of personal information about you. ")
  ])) : createCommentVNode("", true);
}
const ScamDetection = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const style = "";
const _imports_0 = "/static/img/shy.png";
const _imports_1 = "/static/img/server.png";
const _imports_2 = "/static/img/client.png";
const _sfc_main$5 = {
  props: {
    message: Object,
    // chat Message object
    action: String,
    // presence, notification, or (default) normal chat message
    appearance: String,
    // message style appearance (cards, compact, etc.)
    user: Object,
    // User object of the Message author
    isOffline: Boolean,
    // user is not currently online
    username: String,
    // current username logged in
    websiteUrl: String,
    // Base URL to website (for profile/avatar URLs)
    isDnd: Boolean,
    // user is not accepting DMs
    isMuted: Boolean,
    // user is muted by current user
    reactions: Object,
    // emoji reactions on the message
    reportEnabled: Boolean,
    // Report Message webhook is available
    position: Number,
    // position of the message (0 to n), for the emoji menu to know which side to pop
    isDm: Boolean,
    // is in a DM thread (hide DM buttons)
    isOp: Boolean,
    // current user is Operator (always show takeback button)
    noButtons: Boolean
    // hide all message buttons (e.g. for Report Modal)
  },
  components: {
    EmojiPicker: Picker,
    ScamDetection
  },
  data() {
    return {
      // Emoji picker visible
      showEmojiPicker: false,
      // Message menu (compact displays)
      menuVisible: false,
      // Favorite emojis
      customEmojiGroups: {
        frequently_used: [
          { n: ["heart"], u: "2764-fe0f" },
          { n: ["+1", "thumbs_up"], u: "1f44d" },
          { n: ["-1", "thumbs_down"], u: "1f44e" },
          { n: ["rolling_on_the_floor_laughing"], u: "1f923" },
          { n: ["wink"], u: "1f609" },
          { n: ["cry"], u: "1f622" },
          { n: ["angry"], u: "1f620" },
          { n: ["heart_eyes"], u: "1f60d" },
          { n: ["kissing_heart"], u: "1f618" },
          { n: ["wave"], u: "1f44b" },
          { n: ["fire"], u: "1f525" },
          { n: ["smiling_imp"], u: "1f608" },
          { n: ["peach"], u: "1f351" },
          { n: ["eggplant", "aubergine"], u: "1f346" },
          { n: ["splash", "sweat_drops"], u: "1f4a6" },
          { n: ["banana"], u: "1f34c" }
        ]
      },
      // Emoji reactions are toggled fully spelled out (for mobile)
      showReactions: false
    };
  },
  computed: {
    profileURL() {
      if (this.user.profileURL) {
        return this.urlFor(this.user.profileURL);
      }
      return null;
    },
    avatarURL() {
      if (this.user.avatar) {
        return this.urlFor(this.user.avatar);
      }
      return null;
    },
    nickname() {
      if (this.user.nickname) {
        return this.user.nickname;
      }
      return this.user.username;
    },
    hasReactions() {
      return this.reactions != void 0 && Object.keys(this.reactions).length > 0;
    },
    // Compactify a message (remove paragraph breaks added by Markdown renderer)
    compactMessage() {
      return this.message.message.replace(/<\/p>\s*<p>/g, "<br><br>").replace(/<\/?p>/g, "");
    },
    emojiPickerTheme() {
      let theme = LocalStorage.get("theme");
      if (theme === "light" || theme === "dark") {
        return theme;
      }
      return "auto";
    }
  },
  methods: {
    openProfile() {
      this.$emit("open-profile", this.message.username);
    },
    openDMs() {
      this.$emit("send-dm", {
        username: this.message.username
      });
    },
    muteUser() {
      this.$emit("mute-user", this.message.username);
    },
    takeback() {
      this.$emit("takeback", this.message);
    },
    removeMessage() {
      this.$emit("remove", this.message);
    },
    reportMessage() {
      this.$emit("report", this.message);
    },
    sendReact(emoji) {
      this.$emit("react", this.message, emoji);
    },
    // Vue3-emoji-picker callback
    onSelectEmoji(emoji) {
      this.sendReact(emoji.i);
      this.hideEmojiPicker();
    },
    // Hide the emoji menu (after sending an emoji or clicking the react button again)
    hideEmojiPicker() {
      if (!this.showEmojiPicker)
        return;
      window.requestAnimationFrame(() => {
        this.showEmojiPicker = false;
      });
    },
    urlFor(url) {
      if (url.match(/^https?:/i)) {
        return url;
      }
      return this.websiteUrl.replace(/\/+$/, "") + url;
    },
    // Current user has reacted to the message.
    iReacted(emoji) {
      if (!this.hasReactions)
        return false;
      if (this.reactions[emoji] != void 0) {
        for (let reactor of this.reactions[emoji]) {
          if (reactor === this.username) {
            return true;
          }
        }
      }
      return false;
    },
    // Google Translate link.
    translate() {
      var _a;
      let message = (_a = this.message) == null ? void 0 : _a.message.replace(/<(.|\n)+?>/g, "");
      let url = `https://translate.google.com/?sl=auto&tl=en&text=${encodeURIComponent(message)}&op=translate`;
      window.open(url);
    },
    // TODO: DRY
    prettyDate(date) {
      if (date == void 0)
        return "";
      let hours = date.getHours(), minutes = String(date.getMinutes()).padStart(2, "0"), ampm = hours >= 12 ? "pm" : "am";
      let hour = hours % 12 || 12;
      return `${hour}:${minutes} ${ampm}`;
    },
    prettyDateCompact(date) {
      if (date == void 0)
        return "";
      let hour = date.getHours(), minutes = String(date.getMinutes()).padStart(2, "0");
      return `${hour}:${minutes}`;
    }
  }
};
const _hoisted_1$5 = {
  key: 0,
  class: "notification is-success is-light py-1 px-3 mb-2"
};
const _hoisted_2$5 = { class: "columns is-mobile" };
const _hoisted_3$5 = { class: "column is-narrow pr-0 pt-4" };
const _hoisted_4$5 = ["href"];
const _hoisted_5$5 = { class: "image is-16x16" };
const _hoisted_6$5 = ["src"];
const _hoisted_7$5 = {
  key: 1,
  src: _imports_0
};
const _hoisted_8$5 = { class: "column" };
const _hoisted_9$5 = ["title"];
const _hoisted_10$5 = {
  key: 0,
  class: "ml-1"
};
const _hoisted_11$5 = {
  key: 1,
  class: "ml-1"
};
const _hoisted_12$5 = {
  key: 1,
  class: "notification is-warning is-light mb-2"
};
const _hoisted_13$5 = ["innerHTML"];
const _hoisted_14$5 = {
  key: 2,
  class: "box mb-2 px-4 pt-3 pb-1 position-relative"
};
const _hoisted_15$5 = { class: "media mb-0" };
const _hoisted_16$5 = { class: "media-left" };
const _hoisted_17$4 = ["href"];
const _hoisted_18$4 = { class: "image is-48x48" };
const _hoisted_19$3 = {
  key: 0,
  src: _imports_1
};
const _hoisted_20$3 = {
  key: 1,
  src: _imports_2
};
const _hoisted_21$2 = ["src"];
const _hoisted_22$2 = {
  key: 3,
  src: _imports_0
};
const _hoisted_23$2 = { class: "media-content" };
const _hoisted_24$2 = { class: "columns is-mobile pb-0" };
const _hoisted_25$2 = { class: "column is-narrow pb-0" };
const _hoisted_26$2 = { key: 0 };
const _hoisted_27$2 = { class: "column has-text-right pb-0" };
const _hoisted_28$2 = ["title"];
const _hoisted_29$2 = {
  key: 0,
  class: "columns is-mobile pt-0"
};
const _hoisted_30$2 = { class: "column is-narrow pt-0" };
const _hoisted_31$2 = { key: 0 };
const _hoisted_32$2 = ["href"];
const _hoisted_33$2 = {
  key: 1,
  class: "has-text-grey"
};
const _hoisted_34$2 = {
  key: 1,
  class: "has-text-grey"
};
const _hoisted_35$2 = {
  key: 1,
  class: "columns is-mobile pt-0"
};
const _hoisted_36$2 = { class: "column is-narrow pt-0" };
const _hoisted_37$2 = { key: 0 };
const _hoisted_38$2 = ["href"];
const _hoisted_39$2 = {
  key: 1,
  class: "has-text-grey"
};
const _hoisted_40$2 = {
  key: 0,
  class: "column is-narrow pl-1 pt-0"
};
const _hoisted_41$2 = ["title", "disabled"];
const _hoisted_42$2 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-comment" }, null, -1);
const _hoisted_43$2 = [
  _hoisted_42$2
];
const _hoisted_44$2 = ["data-msgid"];
const _hoisted_45$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-rotate-left has-text-danger" }, null, -1);
const _hoisted_46$1 = [
  _hoisted_45$1
];
const _hoisted_47$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-trash" }, null, -1);
const _hoisted_48$1 = [
  _hoisted_47$1
];
const _hoisted_49$1 = {
  key: 0,
  class: "emoji-button columns is-mobile is-gapless mb-0"
};
const _hoisted_50$1 = { class: "column" };
const _hoisted_51$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fab fa-google has-text-success" }, null, -1);
const _hoisted_52$1 = [
  _hoisted_51$1
];
const _hoisted_53$1 = {
  key: 0,
  class: "column"
};
const _hoisted_54$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-flag" }, null, -1);
const _hoisted_55$1 = {
  key: 0,
  class: "fa fa-check ml-1"
};
const _hoisted_56$1 = { class: "dropdown-trigger" };
const _hoisted_57$1 = ["aria-controls"];
const _hoisted_58$1 = /* @__PURE__ */ createBaseVNode("span", null, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-heart has-text-grey" }),
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-plus has-text-grey pl-1" })
], -1);
const _hoisted_59$1 = [
  _hoisted_58$1
];
const _hoisted_60$1 = ["id"];
const _hoisted_61$1 = { class: "dropdown-content p-0" };
const _hoisted_62$1 = { class: "content pl-5 pb-3 pt-1 mb-5" };
const _hoisted_63$1 = { key: 0 };
const _hoisted_64$1 = ["innerHTML"];
const _hoisted_65$1 = {
  key: 3,
  class: "mt-1"
};
const _hoisted_66$1 = ["title", "onClick"];
const _hoisted_67$1 = {
  key: 0,
  class: "ml-1"
};
const _hoisted_68$1 = {
  key: 1,
  class: "ml-1"
};
const _hoisted_69$1 = {
  key: 3,
  class: "columns is-mobile"
};
const _hoisted_70$1 = { class: "column is-narrow pr-0" };
const _hoisted_71$1 = ["title"];
const _hoisted_72$1 = { class: "column is-narrow px-1" };
const _hoisted_73$1 = ["href"];
const _hoisted_74$1 = ["src"];
const _hoisted_75$1 = {
  key: 1,
  src: _imports_0,
  width: "16",
  height: "16"
};
const _hoisted_76$1 = { class: "column px-1" };
const _hoisted_77$1 = { class: "content mb-2" };
const _hoisted_78$1 = ["href"];
const _hoisted_79$1 = ["innerHTML"];
const _hoisted_80$1 = {
  key: 0,
  class: "mb-2"
};
const _hoisted_81$1 = ["title", "onClick"];
const _hoisted_82$1 = {
  key: 0,
  class: "ml-1"
};
const _hoisted_83$1 = {
  key: 1,
  class: "ml-1"
};
const _hoisted_84$1 = {
  key: 0,
  class: "column is-narrow pl-1"
};
const _hoisted_85$1 = { class: "columns is-mobile is-gapless mb-0" };
const _hoisted_86$1 = { class: "dropdown-trigger" };
const _hoisted_87$1 = ["aria-controls"];
const _hoisted_88$1 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-ellipsis-vertical" })
], -1);
const _hoisted_89$1 = [
  _hoisted_88$1
];
const _hoisted_90$1 = ["id"];
const _hoisted_91$1 = { class: "dropdown-content" };
const _hoisted_92$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-comment mr-1" }, null, -1);
const _hoisted_93$1 = { key: 0 };
const _hoisted_94$1 = { key: 1 };
const _hoisted_95$1 = ["data-msgid"];
const _hoisted_96$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-rotate-left has-text-danger mr-1" }, null, -1);
const _hoisted_97$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-trash mr-1" }, null, -1);
const _hoisted_98$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fab fa-google has-text-success mr-1" }, null, -1);
const _hoisted_99$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-external-link ml-1" }, null, -1);
const _hoisted_100$1 = { key: 0 };
const _hoisted_101$1 = { key: 1 };
const _hoisted_102$1 = { class: "dropdown-trigger" };
const _hoisted_103$1 = ["aria-controls"];
const _hoisted_104$1 = /* @__PURE__ */ createBaseVNode("small", null, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-heart has-text-grey" })
], -1);
const _hoisted_105$1 = [
  _hoisted_104$1
];
const _hoisted_106$1 = ["id"];
const _hoisted_107$1 = { class: "dropdown-content p-0" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_EmojiPicker = resolveComponent("EmojiPicker");
  const _component_ScamDetection = resolveComponent("ScamDetection");
  return $props.action === "presence" ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
    createBaseVNode("div", _hoisted_2$5, [
      createBaseVNode("div", _hoisted_3$5, [
        createBaseVNode("a", {
          href: $options.profileURL,
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
          class: normalizeClass({ "cursor-default": !$options.profileURL })
        }, [
          createBaseVNode("figure", _hoisted_5$5, [
            $options.avatarURL ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: $options.avatarURL
            }, null, 8, _hoisted_6$5)) : (openBlock(), createElementBlock("img", _hoisted_7$5))
          ])
        ], 10, _hoisted_4$5)
      ]),
      createBaseVNode("div", _hoisted_8$5, [
        createBaseVNode("span", {
          class: "float-right is-size-7",
          title: $props.message.at
        }, toDisplayString($options.prettyDate($props.message.at)), 9, _hoisted_9$5),
        createBaseVNode("span", {
          onClick: _cache[1] || (_cache[1] = ($event) => $options.openProfile()),
          class: "cursor-pointer"
        }, [
          createBaseVNode("strong", null, toDisplayString($options.nickname), 1),
          $props.isOffline ? (openBlock(), createElementBlock("span", _hoisted_10$5, "(offline)")) : (openBlock(), createElementBlock("small", _hoisted_11$5, "(@" + toDisplayString($props.message.username) + ")", 1))
        ]),
        createTextVNode(" " + toDisplayString($props.message.message), 1)
      ])
    ])
  ])) : $props.action === "notification" ? (openBlock(), createElementBlock("div", _hoisted_12$5, [
    createBaseVNode("span", {
      innerHTML: $props.message.message
    }, null, 8, _hoisted_13$5)
  ])) : $props.appearance === "cards" || !$props.appearance ? (openBlock(), createElementBlock("div", _hoisted_14$5, [
    createBaseVNode("div", _hoisted_15$5, [
      createBaseVNode("div", _hoisted_16$5, [
        createBaseVNode("a", {
          href: $options.profileURL,
          onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $options.openProfile(), ["prevent"]))
        }, [
          createBaseVNode("figure", _hoisted_18$4, [
            $props.message.isChatServer ? (openBlock(), createElementBlock("img", _hoisted_19$3)) : $props.message.isChatClient ? (openBlock(), createElementBlock("img", _hoisted_20$3)) : $options.avatarURL ? (openBlock(), createElementBlock("img", {
              key: 2,
              src: $options.avatarURL
            }, null, 8, _hoisted_21$2)) : (openBlock(), createElementBlock("img", _hoisted_22$2))
          ])
        ], 8, _hoisted_17$4)
      ]),
      createBaseVNode("div", _hoisted_23$2, [
        createBaseVNode("div", _hoisted_24$2, [
          createBaseVNode("div", _hoisted_25$2, [
            createBaseVNode("strong", {
              class: normalizeClass({
                "has-text-success is-dark": $props.message.isChatServer,
                "has-text-warning is-dark": $props.message.isAdmin,
                "has-text-danger": $props.message.isChatClient
              })
            }, [
              createTextVNode(toDisplayString($options.nickname) + " ", 1),
              $props.isOffline ? (openBlock(), createElementBlock("span", _hoisted_26$2, "(offline)")) : createCommentVNode("", true)
            ], 2)
          ]),
          createBaseVNode("div", _hoisted_27$2, [
            createBaseVNode("small", {
              class: "has-text-grey is-size-7",
              title: $props.message.at
            }, toDisplayString($options.prettyDate($props.message.at)), 9, _hoisted_28$2)
          ])
        ]),
        $props.message.isChatClient || $props.message.isChatServer ? (openBlock(), createElementBlock("div", _hoisted_29$2, [
          createBaseVNode("div", _hoisted_30$2, [
            !($props.message.isChatClient || $props.message.isChatServer) ? (openBlock(), createElementBlock("small", _hoisted_31$2, [
              $options.profileURL ? (openBlock(), createElementBlock("a", {
                key: 0,
                href: $options.profileURL,
                target: "_blank",
                onClick: _cache[3] || (_cache[3] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
                class: "has-text-grey"
              }, " @" + toDisplayString($props.message.username), 9, _hoisted_32$2)) : (openBlock(), createElementBlock("span", _hoisted_33$2, "@" + toDisplayString($props.message.username), 1))
            ])) : (openBlock(), createElementBlock("small", _hoisted_34$2, "internal"))
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_35$2, [
          createBaseVNode("div", _hoisted_36$2, [
            !($props.message.isChatClient || $props.message.isChatServer) ? (openBlock(), createElementBlock("small", _hoisted_37$2, [
              createBaseVNode("a", {
                href: $options.profileURL || "#",
                target: "_blank",
                onClick: _cache[4] || (_cache[4] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
                class: "has-text-grey"
              }, " @" + toDisplayString($props.message.username), 9, _hoisted_38$2)
            ])) : (openBlock(), createElementBlock("small", _hoisted_39$2, "internal"))
          ]),
          !$props.noButtons ? (openBlock(), createElementBlock("div", _hoisted_40$2, [
            !($props.message.username === $props.username || $props.isDm) ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              class: "button is-small px-2",
              onClick: _cache[5] || (_cache[5] = ($event) => $options.openDMs()),
              title: $props.isDnd ? "This person is not accepting new DMs" : "Open a Direct Message (DM) thread",
              disabled: $props.isDnd
            }, _hoisted_43$2, 8, _hoisted_41$2)) : createCommentVNode("", true),
            !($props.message.username === $props.username) ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "button is-small px-2 ml-1",
              onClick: _cache[6] || (_cache[6] = ($event) => $options.muteUser()),
              title: "Mute user"
            }, [
              createBaseVNode("i", {
                class: normalizeClass(["fa fa-comment-slash", {
                  "has-text-success": $props.isMuted,
                  "has-text-danger": !$props.isMuted
                }])
              }, null, 2)
            ])) : createCommentVNode("", true),
            $props.message.username === $props.username || $props.isOp ? (openBlock(), createElementBlock("button", {
              key: 2,
              type: "button",
              class: "button is-small px-2 ml-1",
              title: "Take back this message (delete it for everybody)",
              onClick: _cache[7] || (_cache[7] = ($event) => $options.takeback()),
              "data-msgid": $props.message.msgID
            }, _hoisted_46$1, 8, _hoisted_44$2)) : createCommentVNode("", true),
            $props.message.username !== $props.username ? (openBlock(), createElementBlock("button", {
              key: 3,
              type: "button",
              class: "button is-small px-2 ml-1",
              title: "Hide this message (delete it only for your view)",
              onClick: _cache[8] || (_cache[8] = ($event) => $options.removeMessage())
            }, _hoisted_48$1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]))
      ])
    ]),
    $props.message.msgID && !$props.noButtons ? (openBlock(), createElementBlock("div", _hoisted_49$1, [
      createBaseVNode("div", _hoisted_50$1, [
        createBaseVNode("button", {
          class: "button is-small mr-1 py-2 has-text-success",
          title: "Translate this message using Google Translate",
          onClick: _cache[9] || (_cache[9] = withModifiers(($event) => $options.translate(), ["prevent"]))
        }, _hoisted_52$1)
      ]),
      $props.reportEnabled && $props.message.username !== $props.username ? (openBlock(), createElementBlock("div", _hoisted_53$1, [
        createBaseVNode("button", {
          class: normalizeClass(["button is-small is-outlined mr-1 py-2", {
            "is-danger": !$props.message.reported,
            "has-text-grey": $props.message.reported
          }]),
          title: "Report this message",
          onClick: _cache[10] || (_cache[10] = withModifiers(($event) => $options.reportMessage(), ["prevent"]))
        }, [
          _hoisted_54$1,
          $props.message.reported ? (openBlock(), createElementBlock("i", _hoisted_55$1)) : createCommentVNode("", true)
        ], 2)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(["column dropdown is-right", { "is-up": $props.position >= 2, "is-active": $data.showEmojiPicker }]),
        onClick: _cache[12] || (_cache[12] = ($event) => $data.showEmojiPicker = true)
      }, [
        createBaseVNode("div", _hoisted_56$1, [
          createBaseVNode("button", {
            type: "button",
            class: "button is-small px-2",
            "aria-haspopup": "true",
            "aria-controls": `react-menu-${$props.message.msgID}`,
            onClick: _cache[11] || (_cache[11] = withModifiers(($event) => $options.hideEmojiPicker(), ["prevent"]))
          }, _hoisted_59$1, 8, _hoisted_57$1)
        ]),
        createBaseVNode("div", {
          class: "dropdown-menu",
          id: `react-menu-${$props.message.msgID}`,
          role: "menu"
        }, [
          createBaseVNode("div", _hoisted_61$1, [
            $data.showEmojiPicker ? (openBlock(), createBlock(_component_EmojiPicker, {
              key: 0,
              native: true,
              "display-recent": true,
              "disable-skin-tones": true,
              "additional-groups": $data.customEmojiGroups,
              "group-names": { frequently_used: "Frequently Used" },
              theme: $options.emojiPickerTheme,
              onSelect: $options.onSelectEmoji
            }, null, 8, ["additional-groups", "theme", "onSelect"])) : createCommentVNode("", true)
          ])
        ], 8, _hoisted_60$1)
      ], 2)
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_62$1, [
      $props.message.action === "presence" ? (openBlock(), createElementBlock("em", _hoisted_63$1, toDisplayString($props.message.message), 1)) : (openBlock(), createElementBlock("div", {
        key: 1,
        innerHTML: $props.message.message
      }, null, 8, _hoisted_64$1)),
      $props.message.username !== $props.username ? (openBlock(), createBlock(_component_ScamDetection, {
        key: 2,
        username: $props.message.username,
        message: $props.message.message
      }, null, 8, ["username", "message"])) : createCommentVNode("", true),
      $options.hasReactions ? (openBlock(), createElementBlock("div", _hoisted_65$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.reactions, (users, emoji) => {
          return openBlock(), createElementBlock("span", {
            key: emoji,
            class: normalizeClass(["tag mr-1 cursor-pointer", { "has-text-weight-bold": $options.iReacted(emoji), "is-secondary": !$options.iReacted(emoji) }]),
            title: emoji + " by: " + users.join(", "),
            onClick: ($event) => $options.sendReact(emoji)
          }, [
            createTextVNode(toDisplayString(emoji) + " ", 1),
            $data.showReactions ? (openBlock(), createElementBlock("small", _hoisted_67$1, toDisplayString(users.join(", ")), 1)) : (openBlock(), createElementBlock("small", _hoisted_68$1, toDisplayString(users.length), 1))
          ], 10, _hoisted_66$1);
        }), 128)),
        createBaseVNode("a", {
          href: "#",
          class: "tag is-secondary cursor-pointer",
          onClick: _cache[13] || (_cache[13] = withModifiers(($event) => $data.showReactions = !$data.showReactions, ["prevent"]))
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["fa mr-1", {
              "fa-angles-left": $data.showReactions,
              "fa-angles-right": !$data.showReactions
            }])
          }, null, 2),
          createTextVNode(" " + toDisplayString($data.showReactions ? "Less" : "More"), 1)
        ])
      ])) : createCommentVNode("", true)
    ])
  ])) : $props.appearance.indexOf("compact") === 0 ? (openBlock(), createElementBlock("div", _hoisted_69$1, [
    createBaseVNode("div", _hoisted_70$1, [
      createBaseVNode("small", {
        class: "has-text-grey is-size-7",
        title: $props.message.at
      }, toDisplayString($options.prettyDateCompact($props.message.at)), 9, _hoisted_71$1)
    ]),
    createBaseVNode("div", _hoisted_72$1, [
      createBaseVNode("a", {
        href: $options.profileURL,
        onClick: _cache[14] || (_cache[14] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
        class: "p-0"
      }, [
        $options.avatarURL ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: $options.avatarURL,
          width: "16",
          height: "16",
          alt: ""
        }, null, 8, _hoisted_74$1)) : (openBlock(), createElementBlock("img", _hoisted_75$1))
      ], 8, _hoisted_73$1)
    ]),
    createBaseVNode("div", _hoisted_76$1, [
      createBaseVNode("div", _hoisted_77$1, [
        createBaseVNode("strong", {
          class: normalizeClass({
            "has-text-success is-dark": $props.message.isChatServer,
            "has-text-warning is-dark": $props.message.isAdmin,
            "has-text-danger": $props.message.isChatClient
          })
        }, [
          createTextVNode(" ["),
          createBaseVNode("a", {
            href: $options.profileURL,
            onClick: _cache[15] || (_cache[15] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
            class: normalizeClass(["has-text-dark", { "cursor-default": !$options.profileURL }])
          }, [
            $props.message.isChatServer || $props.message.isChatClient || $props.message.isAdmin || $props.appearance === "compact" && $options.nickname !== $props.message.username ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass({
                "has-text-success is-dark": $props.message.isChatServer,
                "has-text-warning is-dark": $props.message.isAdmin,
                "has-text-danger": $props.message.isChatClient
              })
            }, toDisplayString($options.nickname), 3)) : createCommentVNode("", true),
            !($props.message.isChatServer || $props.message.isChatClient || $props.message.isAdmin) ? (openBlock(), createElementBlock("small", {
              key: 1,
              class: normalizeClass(["has-text-grey", { "ml-1": $props.appearance === "compact" && $options.nickname !== $props.message.username }])
            }, "@" + toDisplayString($props.message.username), 3)) : createCommentVNode("", true)
          ], 10, _hoisted_78$1),
          createTextVNode("] ")
        ], 2),
        createBaseVNode("span", { innerHTML: $options.compactMessage }, null, 8, _hoisted_79$1),
        $props.message.username !== $props.username ? (openBlock(), createBlock(_component_ScamDetection, {
          key: 0,
          username: $props.message.username,
          message: $props.message.message
        }, null, 8, ["username", "message"])) : createCommentVNode("", true)
      ]),
      $options.hasReactions ? (openBlock(), createElementBlock("div", _hoisted_80$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.reactions, (users, emoji) => {
          return openBlock(), createElementBlock("span", {
            key: emoji,
            class: normalizeClass(["tag mr-1 cursor-pointer", { "has-text-weight-bold": $options.iReacted(emoji), "is-secondary": !$options.iReacted(emoji) }]),
            title: emoji + " by: " + users.join(", "),
            onClick: ($event) => $options.sendReact(emoji)
          }, [
            createTextVNode(toDisplayString(emoji) + " ", 1),
            $data.showReactions ? (openBlock(), createElementBlock("small", _hoisted_82$1, toDisplayString(users.join(", ")), 1)) : (openBlock(), createElementBlock("small", _hoisted_83$1, toDisplayString(users.length), 1))
          ], 10, _hoisted_81$1);
        }), 128)),
        createBaseVNode("a", {
          href: "#",
          class: "tag is-secondary cursor-pointer",
          onClick: _cache[16] || (_cache[16] = withModifiers(($event) => $data.showReactions = !$data.showReactions, ["prevent"]))
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["fa mr-1", {
              "fa-angles-left": $data.showReactions,
              "fa-angles-right": !$data.showReactions
            }])
          }, null, 2),
          createTextVNode(" " + toDisplayString($data.showReactions ? "Less" : "More"), 1)
        ])
      ])) : createCommentVNode("", true)
    ]),
    $props.message.msgID && !$props.noButtons ? (openBlock(), createElementBlock("div", _hoisted_84$1, [
      createBaseVNode("div", _hoisted_85$1, [
        createBaseVNode("div", {
          class: normalizeClass(["column dropdown is-right", { "is-up": $props.position >= 2, "is-active": $data.menuVisible }]),
          onClick: _cache[23] || (_cache[23] = ($event) => $data.menuVisible = !$data.menuVisible)
        }, [
          createBaseVNode("div", _hoisted_86$1, [
            createBaseVNode("button", {
              type: "button",
              class: "button is-small px-2 mr-1",
              "aria-haspopup": "true",
              "aria-controls": `msg-menu-${$props.message.msgID}`
            }, _hoisted_89$1, 8, _hoisted_87$1)
          ]),
          createBaseVNode("div", {
            class: "dropdown-menu",
            id: `msg-menu-${$props.message.msgID}`,
            role: "menu"
          }, [
            createBaseVNode("div", _hoisted_91$1, [
              $props.message.username !== $props.username ? (openBlock(), createElementBlock("a", {
                key: 0,
                href: "#",
                class: "dropdown-item",
                onClick: _cache[17] || (_cache[17] = withModifiers(($event) => $options.openDMs(), ["prevent"]))
              }, [
                _hoisted_92$1,
                createTextVNode(" Direct Message ")
              ])) : createCommentVNode("", true),
              !($props.message.username === $props.username) ? (openBlock(), createElementBlock("a", {
                key: 1,
                href: "#",
                class: "dropdown-item",
                onClick: _cache[18] || (_cache[18] = withModifiers(($event) => $options.muteUser(), ["prevent"]))
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(["fa fa-comment-slash mr-1", {
                    "has-text-success": $props.isMuted,
                    "has-text-danger": !$props.isMuted
                  }])
                }, null, 2),
                $props.isMuted ? (openBlock(), createElementBlock("span", _hoisted_93$1, "Unmute user")) : (openBlock(), createElementBlock("span", _hoisted_94$1, "Mute user"))
              ])) : createCommentVNode("", true),
              $props.message.username === $props.username || $props.isOp ? (openBlock(), createElementBlock("a", {
                key: 2,
                href: "#",
                class: "dropdown-item",
                onClick: _cache[19] || (_cache[19] = withModifiers(($event) => $options.takeback(), ["prevent"])),
                "data-msgid": $props.message.msgID
              }, [
                _hoisted_96$1,
                createTextVNode(" Take back ")
              ], 8, _hoisted_95$1)) : createCommentVNode("", true),
              $props.message.username !== $props.username ? (openBlock(), createElementBlock("a", {
                key: 3,
                href: "#",
                class: "dropdown-item",
                onClick: _cache[20] || (_cache[20] = withModifiers(($event) => $options.removeMessage(), ["prevent"]))
              }, [
                _hoisted_97$1,
                createTextVNode(" Hide message ")
              ])) : createCommentVNode("", true),
              createBaseVNode("a", {
                href: "#",
                class: "dropdown-item",
                onClick: _cache[21] || (_cache[21] = withModifiers(($event) => $options.translate(), ["prevent"]))
              }, [
                _hoisted_98$1,
                createTextVNode(" Google Translate "),
                _hoisted_99$1
              ]),
              $props.reportEnabled && $props.message.username !== $props.username ? (openBlock(), createElementBlock("a", {
                key: 4,
                href: "#",
                class: "dropdown-item",
                onClick: _cache[22] || (_cache[22] = withModifiers(($event) => $options.reportMessage(), ["prevent"]))
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(["fa fa-flag mr-1", { "has-text-danger": !$props.message.reported }])
                }, null, 2),
                $props.message.reported ? (openBlock(), createElementBlock("span", _hoisted_100$1, "Reported")) : (openBlock(), createElementBlock("span", _hoisted_101$1, "Report"))
              ])) : createCommentVNode("", true)
            ])
          ], 8, _hoisted_90$1)
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(["column dropdown is-right", { "is-up": $props.position >= 2, "is-active": $data.showEmojiPicker }]),
          onClick: _cache[25] || (_cache[25] = ($event) => $data.showEmojiPicker = true)
        }, [
          createBaseVNode("div", _hoisted_102$1, [
            createBaseVNode("button", {
              type: "button",
              class: "button is-small px-2",
              "aria-haspopup": "true",
              "aria-controls": `react-menu-${$props.message.msgID}`,
              onClick: _cache[24] || (_cache[24] = ($event) => $options.hideEmojiPicker())
            }, _hoisted_105$1, 8, _hoisted_103$1)
          ]),
          createBaseVNode("div", {
            class: "dropdown-menu",
            id: `react-menu-${$props.message.msgID}`,
            role: "menu"
          }, [
            createBaseVNode("div", _hoisted_107$1, [
              $data.showEmojiPicker ? (openBlock(), createBlock(_component_EmojiPicker, {
                key: 0,
                native: true,
                "display-recent": true,
                "disable-skin-tones": true,
                "additional-groups": $data.customEmojiGroups,
                "group-names": { frequently_used: "Frequently Used" },
                theme: "auto",
                onSelect: $options.onSelectEmoji
              }, null, 8, ["additional-groups", "onSelect"])) : createCommentVNode("", true)
            ])
          ], 8, _hoisted_106$1)
        ], 2)
      ])
    ])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
const MessageBox = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const _sfc_main$4 = {
  props: {
    visible: Boolean,
    busy: Boolean,
    user: Object,
    message: Object
  },
  components: {
    MessageBox
  },
  data() {
    return {
      // Configuration
      reportClassifications: [
        "It's spam",
        "It's abusive (racist, homophobic, etc.)",
        "It's malicious (e.g. link to a malware website, phishing)",
        "It's illegal (e.g. controlled substances, violence)",
        "It's child abuse (CP, CSAM, pedophilia, etc.)",
        "Other (please describe)"
      ],
      // Our settings.
      classification: "It's spam",
      comment: ""
    };
  },
  methods: {
    reset() {
      this.classification = this.reportClassifications[0];
      this.comment = "";
    },
    accept() {
      this.$emit("accept", {
        classification: this.classification,
        comment: this.comment
      });
      this.reset();
    },
    cancel() {
      this.$emit("cancel");
      this.reset();
    }
  }
};
const _hoisted_1$4 = /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1);
const _hoisted_2$4 = { class: "modal-content" };
const _hoisted_3$4 = { class: "card" };
const _hoisted_4$4 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-warning" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title has-text-dark" }, "Report a message")
], -1);
const _hoisted_5$4 = { class: "card-content" };
const _hoisted_6$4 = { class: "field mb-1" };
const _hoisted_7$4 = /* @__PURE__ */ createBaseVNode("label", {
  class: "label",
  for: "classification"
}, "Report classification:", -1);
const _hoisted_8$4 = { class: "select is-fullwidth" };
const _hoisted_9$4 = ["disabled"];
const _hoisted_10$4 = ["value"];
const _hoisted_11$4 = { class: "field" };
const _hoisted_12$4 = /* @__PURE__ */ createBaseVNode("label", {
  class: "label",
  for: "reportComment"
}, "Comment:", -1);
const _hoisted_13$4 = ["disabled"];
const _hoisted_14$4 = { class: "field" };
const _hoisted_15$4 = { class: "control has-text-centered" };
const _hoisted_16$4 = ["disabled"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MessageBox = resolveComponent("MessageBox");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["modal", { "is-active": $props.visible }])
  }, [
    _hoisted_1$4,
    createBaseVNode("div", _hoisted_2$4, [
      createBaseVNode("div", _hoisted_3$4, [
        _hoisted_4$4,
        createBaseVNode("div", _hoisted_5$4, [
          createVNode(_component_MessageBox, {
            message: $props.message,
            user: $props.user,
            "no-buttons": true
          }, null, 8, ["message", "user"]),
          createBaseVNode("div", _hoisted_6$4, [
            _hoisted_7$4,
            createBaseVNode("div", _hoisted_8$4, [
              withDirectives(createBaseVNode("select", {
                id: "classification",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.classification = $event),
                disabled: $props.busy
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.reportClassifications, (i2) => {
                  return openBlock(), createElementBlock("option", {
                    key: i2,
                    value: i2
                  }, toDisplayString(i2), 9, _hoisted_10$4);
                }), 128))
              ], 8, _hoisted_9$4), [
                [vModelSelect, $data.classification]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$4, [
            _hoisted_12$4,
            withDirectives(createBaseVNode("textarea", {
              class: "textarea",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.comment = $event),
              disabled: $props.busy,
              cols: "80",
              rows: "2",
              placeholder: "Optional: describe the issue"
            }, null, 8, _hoisted_13$4), [
              [vModelText, $data.comment]
            ])
          ]),
          createBaseVNode("div", _hoisted_14$4, [
            createBaseVNode("div", _hoisted_15$4, [
              createBaseVNode("button", {
                type: "button",
                class: "button is-link mr-4",
                disabled: $props.busy,
                onClick: _cache[2] || (_cache[2] = ($event) => $options.accept())
              }, "Submit report", 8, _hoisted_16$4),
              createBaseVNode("button", {
                type: "button",
                class: "button",
                onClick: _cache[3] || (_cache[3] = ($event) => $options.cancel())
              }, "Cancel")
            ])
          ])
        ])
      ])
    ])
  ], 2);
}
const ReportModal = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const VideoFlag = {
  Active: 1 << 0,
  NSFW: 1 << 1,
  Muted: 1 << 2,
  NonExplicit: 1 << 3,
  MutualRequired: 1 << 4,
  MutualOpen: 1 << 5,
  VipOnly: 1 << 6
};
const _sfc_main$3 = {
  props: {
    user: Object,
    // User object of the Message author
    username: String,
    // current username logged in
    websiteUrl: String,
    // Base URL to website (for profile/avatar URLs)
    isDnd: Boolean,
    // user is not accepting DMs
    isMuted: Boolean,
    // user is muted by current user
    isBlocked: Boolean,
    // user is blocked on your main website (can't be unmuted)
    isBooted: Boolean,
    // user is booted by current user
    vipConfig: Object,
    // VIP config settings for BareRTC
    isOp: Boolean,
    // current user is operator (can always DM)
    isVideoNotAllowed: Boolean,
    // whether opening this camera is not allowed
    videoIconClass: String,
    // CSS class for the open video icon
    isWatchingTab: Boolean,
    // is the "Watching" tab (replace video button w/ boot)
    statusMessage: Object
    // StatusMessage controller
  },
  data() {
    return {
      VideoFlag
    };
  },
  computed: {
    profileURL() {
      if (this.user.profileURL) {
        return this.urlFor(this.user.profileURL);
      }
      return null;
    },
    profileButtonClass() {
      let result = "";
      if (this.user.vip) {
        result = "has-background-vip ";
      }
      let gender = (this.user.gender || "").toLowerCase();
      if (gender.indexOf("m") === 0) {
        return result + "has-text-gender-male";
      } else if (gender.indexOf("f") === 0) {
        return result + "has-text-gender-female";
      } else if (gender.length > 0) {
        return result + "has-text-gender-other";
      }
      return "";
    },
    videoButtonClass() {
      let result = "";
      if (this.user.video & VideoFlag.Active && this.user.video & VideoFlag.VipOnly) {
        result = "has-background-vip ";
      }
      if (this.user.video & VideoFlag.Active && this.user.video & VideoFlag.NSFW) {
        result += "is-danger is-outlined";
      } else if (this.user.video & VideoFlag.Active && !(this.user.video & VideoFlag.NSFW)) {
        result += "is-link is-outlined";
      } else if (this.isVideoNotAllowed) {
        result += "cursor-notallowed";
      }
      return result;
    },
    videoButtonTitle() {
      let parts = ["Open video stream"];
      if (this.user.video & VideoFlag.MutualRequired) {
        parts.push("mutual video sharing required");
      }
      if (this.user.video & VideoFlag.MutualOpen) {
        parts.push("will auto-open your video");
      }
      if (this.user.video & VideoFlag.VipOnly) {
        parts.push(`${this.vipConfig.Name} only`);
      }
      if (this.user.video & VideoFlag.NonExplicit) {
        parts.push("prefers non-explicit video");
      }
      return parts.join("; ");
    },
    avatarURL() {
      if (this.user.avatar) {
        return this.urlFor(this.user.avatar);
      }
      return null;
    },
    nickname() {
      if (this.user.nickname) {
        return this.user.nickname;
      }
      return this.user.username;
    },
    hasReactions() {
      return this.reactions != void 0 && Object.keys(this.reactions).length > 0;
    },
    // Status icons
    hasStatusIcon() {
      return this.user.status !== "online" && this.statusMessage != void 0;
    },
    statusIconClass() {
      let status = this.statusMessage.getStatus(this.user.status);
      return status.icon;
    },
    statusLabel() {
      let status = this.statusMessage.getStatus(this.user.status);
      return `${status.emoji} ${status.label}`;
    }
  },
  methods: {
    openProfile() {
      this.$emit("open-profile", this.user.username);
    },
    // Directly open the profile page.
    openProfilePage() {
      if (this.profileURL) {
        window.open(this.profileURL);
      } else {
        this.openProfile();
      }
    },
    openDMs() {
      this.$emit("send-dm", {
        username: this.user.username
      });
    },
    openVideo() {
      this.$emit("open-video", this.user);
    },
    muteUser() {
      this.$emit("mute-user", this.user.username);
    },
    // Boot user off your cam (for isWatchingTab)
    bootUser() {
      this.$emit("boot-user", this.user.username);
    },
    urlFor(url) {
      if (url.match(/^https?:/i)) {
        return url;
      }
      return this.websiteUrl.replace(/\/+$/, "") + url;
    }
  }
};
const _hoisted_1$3 = { class: "columns is-mobile" };
const _hoisted_2$3 = {
  class: "column is-narrow pr-0",
  style: { "position": "relative" }
};
const _hoisted_3$3 = ["href"];
const _hoisted_4$3 = ["src"];
const _hoisted_5$3 = {
  key: 1,
  src: _imports_0,
  width: "24",
  height: "24"
};
const _hoisted_6$3 = {
  key: 2,
  class: "status-away-icon"
};
const _hoisted_7$3 = ["title"];
const _hoisted_8$3 = {
  key: 0,
  class: "fa fa-peace has-text-warning is-size-7 ml-1",
  title: "Operator"
};
const _hoisted_9$3 = ["title"];
const _hoisted_10$3 = { class: "column is-narrow pl-0" };
const _hoisted_11$3 = ["title"];
const _hoisted_12$3 = ["title"];
const _hoisted_13$3 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-user" }, null, -1);
const _hoisted_14$3 = [
  _hoisted_13$3
];
const _hoisted_15$3 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-comment-slash has-text-danger" }, null, -1);
const _hoisted_16$3 = [
  _hoisted_15$3
];
const _hoisted_17$3 = ["disabled", "title"];
const _hoisted_18$3 = ["disabled", "title"];
const _hoisted_19$2 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-user-xmark has-text-danger" }, null, -1);
const _hoisted_20$2 = [
  _hoisted_19$2
];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2$3, [
      createBaseVNode("a", {
        href: $options.profileURL,
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
        class: "p-0"
      }, [
        $options.avatarURL ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: $options.avatarURL,
          width: "24",
          height: "24",
          alt: ""
        }, null, 8, _hoisted_4$3)) : (openBlock(), createElementBlock("img", _hoisted_5$3)),
        $options.hasStatusIcon ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
          createBaseVNode("i", {
            class: normalizeClass([$options.statusIconClass, "has-text-light"]),
            title: "Status: " + $options.statusLabel
          }, null, 10, _hoisted_7$3)
        ])) : createCommentVNode("", true)
      ], 8, _hoisted_3$3)
    ]),
    createBaseVNode("div", {
      class: normalizeClass(["column pr-0 is-clipped", { "pl-1": $options.avatarURL }])
    }, [
      createBaseVNode("strong", {
        class: "truncate-text-line is-size-7 cursor-pointer",
        onClick: _cache[1] || (_cache[1] = ($event) => $options.openProfile())
      }, toDisplayString($props.user.username), 1),
      $props.user.op ? (openBlock(), createElementBlock("sup", _hoisted_8$3)) : $props.user.vip ? (openBlock(), createElementBlock("sup", {
        key: 1,
        class: normalizeClass(["is-size-7 ml-1", $props.vipConfig.Icon]),
        title: $props.vipConfig.Name
      }, null, 10, _hoisted_9$3)) : createCommentVNode("", true)
    ], 2),
    createBaseVNode("div", _hoisted_10$3, [
      $props.user.emoji && !$props.isWatchingTab ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: "pr-1 cursor-default",
        title: $props.user.emoji
      }, toDisplayString($props.user.emoji.split(" ")[0]), 9, _hoisted_11$3)) : createCommentVNode("", true),
      createBaseVNode("button", {
        type: "button",
        class: normalizeClass(["button is-small px-2 py-1", $options.profileButtonClass]),
        onClick: _cache[2] || (_cache[2] = ($event) => $options.openProfilePage()),
        title: "Open profile page" + ($props.user.gender ? ` (gender: ${$props.user.gender})` : "") + ($props.user.vip ? ` (${$props.vipConfig.Name})` : "")
      }, _hoisted_14$3, 10, _hoisted_12$3),
      $props.isMuted && !$props.isBlocked ? (openBlock(), createElementBlock("button", {
        key: 1,
        type: "button",
        class: "button is-small px-2 py-1",
        onClick: _cache[3] || (_cache[3] = ($event) => $options.muteUser()),
        title: "This user is muted. Click to unmute them."
      }, _hoisted_16$3)) : (openBlock(), createElementBlock("button", {
        key: 2,
        type: "button",
        class: "button is-small px-2 py-1",
        onClick: _cache[4] || (_cache[4] = ($event) => $options.openDMs(_ctx.u)),
        disabled: $props.user.username === $props.username || $props.user.dnd && !$props.isOp || $props.isBlocked && !$props.isOp,
        title: $props.user.dnd || $props.isBlocked ? "This person is not accepting new DMs" : "Send a Direct Message"
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["fa", { "fa-comment": !($props.user.dnd || $props.isBlocked), "fa-comment-slash": $props.user.dnd || $props.isBlocked }])
        }, null, 2)
      ], 8, _hoisted_17$3)),
      createBaseVNode("button", {
        type: "button",
        class: normalizeClass(["button is-small px-2 py-1", $options.videoButtonClass]),
        disabled: !($props.user.video & $data.VideoFlag.Active),
        title: $options.videoButtonTitle,
        onClick: _cache[5] || (_cache[5] = ($event) => $options.openVideo())
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["fa", $props.videoIconClass])
        }, null, 2)
      ], 10, _hoisted_18$3),
      $props.isWatchingTab ? (openBlock(), createElementBlock("button", {
        key: 3,
        type: "button",
        class: "button is-small px-2 py-1",
        onClick: _cache[6] || (_cache[6] = ($event) => $options.bootUser()),
        title: "Kick this person off your cam"
      }, _hoisted_20$2)) : createCommentVNode("", true)
    ])
  ]);
}
const WhoListRow = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var vue3Slider_common = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
(function(module) {
  module.exports = /******/
  function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) {
        return installedModules[moduleId].exports;
      }
      var module2 = installedModules[moduleId] = {
        /******/
        i: moduleId,
        /******/
        l: false,
        /******/
        exports: {}
        /******/
      };
      modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
      module2.l = true;
      return module2.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
      if (!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, { enumerable: true, get: getter });
      }
    };
    __webpack_require__.r = function(exports) {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(exports, "__esModule", { value: true });
    };
    __webpack_require__.t = function(value, mode) {
      if (mode & 1)
        value = __webpack_require__(value);
      if (mode & 8)
        return value;
      if (mode & 4 && typeof value === "object" && value && value.__esModule)
        return value;
      var ns = /* @__PURE__ */ Object.create(null);
      __webpack_require__.r(ns);
      Object.defineProperty(ns, "default", { enumerable: true, value });
      if (mode & 2 && typeof value != "string")
        for (var key in value)
          __webpack_require__.d(ns, key, (function(key2) {
            return value[key2];
          }).bind(null, key));
      return ns;
    };
    __webpack_require__.n = function(module2) {
      var getter = module2 && module2.__esModule ? (
        /******/
        function getDefault() {
          return module2["default"];
        }
      ) : (
        /******/
        function getModuleExports() {
          return module2;
        }
      );
      __webpack_require__.d(getter, "a", getter);
      return getter;
    };
    __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = "fb15");
  }({
    /***/
    "24fb": (
      /***/
      function(module2, exports, __webpack_require__) {
        module2.exports = function(useSourceMap) {
          var list = [];
          list.toString = function toString() {
            return this.map(function(item) {
              var content = cssWithMappingToString(item, useSourceMap);
              if (item[2]) {
                return "@media ".concat(item[2], " {").concat(content, "}");
              }
              return content;
            }).join("");
          };
          list.i = function(modules, mediaQuery, dedupe) {
            if (typeof modules === "string") {
              modules = [[null, modules, ""]];
            }
            var alreadyImportedModules = {};
            if (dedupe) {
              for (var i2 = 0; i2 < this.length; i2++) {
                var id = this[i2][0];
                if (id != null) {
                  alreadyImportedModules[id] = true;
                }
              }
            }
            for (var _i = 0; _i < modules.length; _i++) {
              var item = [].concat(modules[_i]);
              if (dedupe && alreadyImportedModules[item[0]]) {
                continue;
              }
              if (mediaQuery) {
                if (!item[2]) {
                  item[2] = mediaQuery;
                } else {
                  item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
                }
              }
              list.push(item);
            }
          };
          return list;
        };
        function cssWithMappingToString(item, useSourceMap) {
          var content = item[1] || "";
          var cssMapping = item[3];
          if (!cssMapping) {
            return content;
          }
          if (useSourceMap && typeof btoa === "function") {
            var sourceMapping = toComment(cssMapping);
            var sourceURLs = cssMapping.sources.map(function(source) {
              return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
            });
            return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
          }
          return [content].join("\n");
        }
        function toComment(sourceMap) {
          var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
          var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
          return "/*# ".concat(data, " */");
        }
      }
    ),
    /***/
    "499e": (
      /***/
      function(module2, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "default", function() {
          return (
            /* binding */
            addStylesClient
          );
        });
        function listToStyles(parentId, list) {
          var styles = [];
          var newStyles = {};
          for (var i2 = 0; i2 < list.length; i2++) {
            var item = list[i2];
            var id = item[0];
            var css = item[1];
            var media = item[2];
            var sourceMap = item[3];
            var part = {
              id: parentId + ":" + i2,
              css,
              media,
              sourceMap
            };
            if (!newStyles[id]) {
              styles.push(newStyles[id] = { id, parts: [part] });
            } else {
              newStyles[id].parts.push(part);
            }
          }
          return styles;
        }
        var hasDocument = typeof document !== "undefined";
        if (typeof DEBUG !== "undefined" && DEBUG) {
          if (!hasDocument) {
            throw new Error(
              "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
            );
          }
        }
        var stylesInDom = {
          /*
            [id: number]: {
              id: number,
              refs: number,
              parts: Array<(obj?: StyleObjectPart) => void>
            }
          */
        };
        var head = hasDocument && (document.head || document.getElementsByTagName("head")[0]);
        var singletonElement = null;
        var singletonCounter = 0;
        var isProduction = false;
        var noop = function() {
        };
        var options = null;
        var ssrIdKey = "data-vue-ssr-id";
        var isOldIE = typeof navigator !== "undefined" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
        function addStylesClient(parentId, list, _isProduction, _options) {
          isProduction = _isProduction;
          options = _options || {};
          var styles = listToStyles(parentId, list);
          addStylesToDom(styles);
          return function update(newList) {
            var mayRemove = [];
            for (var i2 = 0; i2 < styles.length; i2++) {
              var item = styles[i2];
              var domStyle = stylesInDom[item.id];
              domStyle.refs--;
              mayRemove.push(domStyle);
            }
            if (newList) {
              styles = listToStyles(parentId, newList);
              addStylesToDom(styles);
            } else {
              styles = [];
            }
            for (var i2 = 0; i2 < mayRemove.length; i2++) {
              var domStyle = mayRemove[i2];
              if (domStyle.refs === 0) {
                for (var j = 0; j < domStyle.parts.length; j++) {
                  domStyle.parts[j]();
                }
                delete stylesInDom[domStyle.id];
              }
            }
          };
        }
        function addStylesToDom(styles) {
          for (var i2 = 0; i2 < styles.length; i2++) {
            var item = styles[i2];
            var domStyle = stylesInDom[item.id];
            if (domStyle) {
              domStyle.refs++;
              for (var j = 0; j < domStyle.parts.length; j++) {
                domStyle.parts[j](item.parts[j]);
              }
              for (; j < item.parts.length; j++) {
                domStyle.parts.push(addStyle(item.parts[j]));
              }
              if (domStyle.parts.length > item.parts.length) {
                domStyle.parts.length = item.parts.length;
              }
            } else {
              var parts = [];
              for (var j = 0; j < item.parts.length; j++) {
                parts.push(addStyle(item.parts[j]));
              }
              stylesInDom[item.id] = { id: item.id, refs: 1, parts };
            }
          }
        }
        function createStyleElement() {
          var styleElement = document.createElement("style");
          styleElement.type = "text/css";
          head.appendChild(styleElement);
          return styleElement;
        }
        function addStyle(obj) {
          var update, remove2;
          var styleElement = document.querySelector("style[" + ssrIdKey + '~="' + obj.id + '"]');
          if (styleElement) {
            if (isProduction) {
              return noop;
            } else {
              styleElement.parentNode.removeChild(styleElement);
            }
          }
          if (isOldIE) {
            var styleIndex = singletonCounter++;
            styleElement = singletonElement || (singletonElement = createStyleElement());
            update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
            remove2 = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
          } else {
            styleElement = createStyleElement();
            update = applyToTag.bind(null, styleElement);
            remove2 = function() {
              styleElement.parentNode.removeChild(styleElement);
            };
          }
          update(obj);
          return function updateStyle(newObj) {
            if (newObj) {
              if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                return;
              }
              update(obj = newObj);
            } else {
              remove2();
            }
          };
        }
        var replaceText = function() {
          var textStore = [];
          return function(index, replacement) {
            textStore[index] = replacement;
            return textStore.filter(Boolean).join("\n");
          };
        }();
        function applyToSingletonTag(styleElement, index, remove2, obj) {
          var css = remove2 ? "" : obj.css;
          if (styleElement.styleSheet) {
            styleElement.styleSheet.cssText = replaceText(index, css);
          } else {
            var cssNode = document.createTextNode(css);
            var childNodes = styleElement.childNodes;
            if (childNodes[index])
              styleElement.removeChild(childNodes[index]);
            if (childNodes.length) {
              styleElement.insertBefore(cssNode, childNodes[index]);
            } else {
              styleElement.appendChild(cssNode);
            }
          }
        }
        function applyToTag(styleElement, obj) {
          var css = obj.css;
          var media = obj.media;
          var sourceMap = obj.sourceMap;
          if (media) {
            styleElement.setAttribute("media", media);
          }
          if (options.ssrId) {
            styleElement.setAttribute(ssrIdKey, obj.id);
          }
          if (sourceMap) {
            css += "\n/*# sourceURL=" + sourceMap.sources[0] + " */";
            css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
          }
          if (styleElement.styleSheet) {
            styleElement.styleSheet.cssText = css;
          } else {
            while (styleElement.firstChild) {
              styleElement.removeChild(styleElement.firstChild);
            }
            styleElement.appendChild(document.createTextNode(css));
          }
        }
      }
    ),
    /***/
    "6ac3": (
      /***/
      function(module2, __webpack_exports__, __webpack_require__) {
        __webpack_require__("ff3a");
      }
    ),
    /***/
    "8875": (
      /***/
      function(module2, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        (function(root, factory) {
          {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        })(typeof self !== "undefined" ? self : this, function() {
          function getCurrentScript() {
            var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
            if (!descriptor && "currentScript" in document && document.currentScript) {
              return document.currentScript;
            }
            if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
              if (scriptLocation === currentLocation) {
                pageSource = document.documentElement.outerHTML;
                inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
              }
              for (var i2 = 0; i2 < scripts.length; i2++) {
                if (scripts[i2].readyState === "interactive") {
                  return scripts[i2];
                }
                if (scripts[i2].src === scriptLocation) {
                  return scripts[i2];
                }
                if (scriptLocation === currentLocation && scripts[i2].innerHTML && scripts[i2].innerHTML.trim() === inlineScriptSource) {
                  return scripts[i2];
                }
              }
              return null;
            }
          }
          return getCurrentScript;
        });
      }
    ),
    /***/
    "8bbf": (
      /***/
      function(module2, exports) {
        module2.exports = require$$0;
      }
    ),
    /***/
    "f855": (
      /***/
      function(module2, exports, __webpack_require__) {
        var ___CSS_LOADER_API_IMPORT___ = __webpack_require__("24fb");
        exports = ___CSS_LOADER_API_IMPORT___(false);
        exports.push([module2.i, ".fade-enter-active,.fade-leave-active{transition:opacity .2s}.fade-enter,.fade-leave-to{opacity:0}.vue3-slider{box-sizing:border-box;width:var(--width,100%);height:var(--height,6px);position:relative;margin:3px 0;cursor:pointer;font-family:inherit}.vue3-slider[disabled]{cursor:unset}.vue3-slider.vertical{width:var(--height,6px);height:var(--width,100%)}.vue3-slider.vertical .track-filled{width:100%;bottom:0;top:auto}.vue3-slider.vertical .handle{top:unset;bottom:0;left:0}.vue3-slider.vertical .tooltip{bottom:0;top:auto}.vue3-slider.circular{height:var(--width,100%);margin:0}.vue3-slider.circular .round-end{position:absolute;margin:0 auto;width:var(--height,6px);height:var(--height,6px);transform:scale(1);left:0;right:0;top:calc(var(--height, 6px)*-0.5)}.vue3-slider.circular .handle-container{-webkit-user-select:none;-ms-user-select:none;user-select:none;width:100%;height:100%;position:absolute;top:0;left:0;transform-origin:center;display:flex;justify-content:center;align-items:center}.vue3-slider.circular .handle-container .handle{top:calc(var(--height, 6px)*-0.5);width:var(--height,6px);height:var(--height,6px);transform:scale(1)}.vue3-slider.circular .handle-container .handle.hover{transform:scale(var(--handle-scale,1.35))}.vue3-slider.circular .handle-container .tooltip{position:absolute;bottom:auto;left:unset}.vue3-slider *{-webkit-user-drag:none;-webkit-app-region:no-drag}.vue3-slider .tooltip{position:absolute;left:0;height:25px;background-color:var(--tooltip-color);color:var(--tooltip-text-color);font-family:inherit;padding:3px 7px;border-radius:4px;font-weight:700;display:flex;align-items:center;transition:bottom .3s ease,left .3s ease,top .3s ease,right .3s ease}.vue3-slider .track,.vue3-slider .track-filled{background-color:var(--track-color,rgba(241,246,248,.156863));width:100%;height:100%;border-radius:calc(var(--height, 6px)/2)}.vue3-slider .track-filled{left:0;width:auto;opacity:1}.vue3-slider .handle,.vue3-slider .track-filled{position:absolute;top:0;background-color:var(--color,#fb2727)}.vue3-slider .handle{width:var(--height,6px);height:var(--height,6px);border-radius:calc(var(--height, 6px)/2);transform:scale(0);transition:transform .2s ease;-webkit-user-select:none;-ms-user-select:none;user-select:none}.vue3-slider .handle.hover{transform:scale(var(--handle-scale,1.35))}", ""]);
        module2.exports = exports;
      }
    ),
    /***/
    "fb15": (
      /***/
      function(module2, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        var entry_esm_namespaceObject = {};
        __webpack_require__.r(entry_esm_namespaceObject);
        __webpack_require__.d(entry_esm_namespaceObject, "default", function() {
          return entry_esm;
        });
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          {
            var getCurrentScript = __webpack_require__("8875");
            currentScript = getCurrentScript();
            if (!("currentScript" in document)) {
              Object.defineProperty(document, "currentScript", { get: getCurrentScript });
            }
          }
          var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (src) {
            __webpack_require__.p = src[1];
          }
        }
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        function ownKeys2(object, enumerableOnly) {
          var keys2 = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols2 = Object.getOwnPropertySymbols(object);
            if (enumerableOnly) {
              symbols2 = symbols2.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            }
            keys2.push.apply(keys2, symbols2);
          }
          return keys2;
        }
        function _objectSpread(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2] != null ? arguments[i2] : {};
            if (i2 % 2) {
              ownKeys2(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys2(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var _hoisted_1100 = ["tabindex", "disabled"];
        var _hoisted_227 = /* @__PURE__ */ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
          class: "track"
        }, null, -1);
        var _hoisted_359 = ["tabindex", "disabled"];
        var _hoisted_410 = /* @__PURE__ */ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
          class: "track"
        }, null, -1);
        var _hoisted_510 = ["tabindex", "disabled"];
        var _hoisted_610 = {
          width: "100%",
          height: "100%",
          viewBox: "0 0 100 100",
          style: {
            "overflow": "visible"
          }
        };
        var _hoisted_710 = ["stroke-dasharray", "stroke-dashoffset"];
        var _hoisted_810 = ["stroke-dasharray", "stroke-dashoffset"];
        var _hoisted_910 = /* @__PURE__ */ Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
          class: "handle round-end"
        }, null, -1);
        var _hoisted_1010 = [_hoisted_910];
        function render2(_ctx, _cache, $props, $setup, $data, $options) {
          return _ctx.orientation == "horizontal" ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
            key: "horizontal",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])(_objectSpread({}, _ctx.vars)),
            class: "vue3-slider",
            ref: "slider",
            tabindex: _ctx.disabled ? void 0 : 0,
            onTouchstart: _cache[0] || (_cache[0] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMousedown: _cache[1] || (_cache[1] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMouseenter: _cache[2] || (_cache[2] = function($event) {
              return !_ctx.disabled ? _ctx.hovering = true : null;
            }),
            onMouseleave: _cache[3] || (_cache[3] = function($event) {
              return _ctx.hovering = false;
            }),
            onKeydown: _cache[4] || (_cache[4] = function($event) {
              return !_ctx.disabled ? _ctx.handleKeydown($event) : null;
            }),
            disabled: _ctx.disabled ? "" : void 0
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
            name: "fade"
          }, {
            default: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withCtx"])(function() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
                class: "tooltip",
                ref: "tooltip",
                style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                  transform: _ctx.flip ? "translate(".concat(-_ctx.tooltipOffset, "px)") : "translate(".concat(_ctx.tooltipOffset, "px)"),
                  right: _ctx.flip ? "0px" : void 0,
                  left: _ctx.flip ? "auto" : void 0,
                  "--tooltip-margin": "max(calc(var(--height, 6px) + 12px), calc(var(--height, 6px) * ".concat(_ctx.applyHandleHoverClass ? "var(--handle-scale, 1.35)" : "1.35", "))"),
                  bottom: _ctx.flipTooltip ? "unset" : "var(--tooltip-margin)",
                  top: _ctx.flipTooltip ? "var(--tooltip-margin)" : "unset"
                })
              }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])(_ctx.tooltipText), 5), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], _ctx.showTooltip && !_ctx.disabled && (_ctx.hovering || _ctx.holding) || _ctx.alwaysShowTooltip]])];
            }),
            _: 1
          }), _hoisted_227, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "track-filled",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
              width: _ctx.filledWidth + "px",
              right: _ctx.flip ? "0px" : void 0,
              left: _ctx.flip ? "auto" : void 0
            })
          }, null, 4), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["handle", {
              hover: _ctx.applyHandleHoverClass && !_ctx.disabled
            }]),
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])(_defineProperty({}, _ctx.flip ? "right" : "left", _ctx.filledWidth - _ctx.height * 1.35 / 2 + "px"))
          }, null, 6)], 44, _hoisted_1100)) : _ctx.orientation == "vertical" ? (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
            key: "vertical",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])(_objectSpread({}, _ctx.vars)),
            class: "vue3-slider vertical",
            ref: "slider",
            tabindex: _ctx.disabled ? void 0 : 0,
            onTouchstart: _cache[5] || (_cache[5] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMousedown: _cache[6] || (_cache[6] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMouseenter: _cache[7] || (_cache[7] = function($event) {
              return !_ctx.disabled ? _ctx.hovering = true : null;
            }),
            onMouseleave: _cache[8] || (_cache[8] = function($event) {
              return _ctx.hovering = false;
            }),
            onKeydown: _cache[9] || (_cache[9] = function($event) {
              return !_ctx.disabled ? _ctx.handleKeydown($event) : null;
            }),
            disabled: _ctx.disabled ? "" : void 0
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
            name: "fade"
          }, {
            default: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withCtx"])(function() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
                class: "tooltip",
                ref: "tooltip",
                style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                  transform: _ctx.flip ? "translateY(".concat(_ctx.tooltipOffset, "px)") : "translateY(".concat(-_ctx.tooltipOffset, "px)"),
                  top: _ctx.flip ? "0px" : void 0,
                  bottom: _ctx.flip ? "auto" : void 0,
                  "--tooltip-margin": "max(calc(var(--height, 6px) + 14px), calc(var(--height, 6px) * ".concat(_ctx.applyHandleHoverClass ? "var(--handle-scale, 1.35)" : "1.35", "))"),
                  left: _ctx.flipTooltip ? "unset" : "var(--tooltip-margin)",
                  right: _ctx.flipTooltip ? "var(--tooltip-margin)" : "unset"
                })
              }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])(_ctx.tooltipText), 5), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], _ctx.showTooltip && !_ctx.disabled && (_ctx.hovering || _ctx.holding) || _ctx.alwaysShowTooltip]])];
            }),
            _: 1
          }), _hoisted_410, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "track-filled",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
              height: _ctx.filledWidth + "px",
              top: _ctx.flip ? "0px" : void 0,
              bottom: _ctx.flip ? "auto" : void 0
            })
          }, null, 4), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["handle", {
              hover: _ctx.applyHandleHoverClass && !_ctx.disabled
            }]),
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])(_defineProperty({}, _ctx.flip ? "top" : "bottom", _ctx.filledWidth - _ctx.height * 1.35 / 2 + "px"))
          }, null, 6)], 44, _hoisted_359)) : (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
            key: "circular",
            class: "vue3-slider circular",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])(_objectSpread({}, _ctx.vars)),
            ref: "slider",
            tabindex: _ctx.disabled ? void 0 : 0,
            onTouchstart: _cache[10] || (_cache[10] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMousedown: _cache[11] || (_cache[11] = function($event) {
              return !_ctx.disabled ? _ctx.clickHandler($event) : null;
            }),
            onMouseenter: _cache[12] || (_cache[12] = function($event) {
              return !_ctx.disabled ? _ctx.hovering = true : null;
            }),
            onMouseleave: _cache[13] || (_cache[13] = function($event) {
              return _ctx.hovering = false;
            }),
            onKeydown: _cache[14] || (_cache[14] = function($event) {
              return !_ctx.disabled ? _ctx.handleKeydown($event) : null;
            }),
            disabled: _ctx.disabled ? "" : void 0
          }, [(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("svg", _hoisted_610, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("circle", {
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])([{
              transform: "rotate(".concat(-90 + _ctx.circleOffset, "deg) ").concat(_ctx.flip ? "scaleY(-1)" : "")
            }, {
              "transform-origin": "center"
            }]),
            stroke: "var(--track-color)",
            "vector-effect": "non-scaling-stroke",
            fill: "none",
            "stroke-width": "var(--height)",
            "stroke-linecap": "round",
            r: "50%",
            cx: "50",
            cy: "50",
            "stroke-dasharray": _ctx.circumference,
            "stroke-dashoffset": _ctx.trackStrokeOffset
          }, null, 12, _hoisted_710), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("circle", {
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])([{
              transform: "rotate(".concat(-90 + _ctx.circleOffset, "deg) ").concat(_ctx.flip ? "scaleY(-1)" : "")
            }, {
              "transform-origin": "center"
            }]),
            stroke: "var(--color)",
            "vector-effect": "non-scaling-stroke",
            fill: "none",
            "stroke-width": "var(--height)",
            r: "50%",
            cx: "50",
            cy: "50",
            "stroke-dasharray": _ctx.circumference,
            "stroke-dashoffset": _ctx.strokeOffset
          }, null, 12, _hoisted_810)])), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "handle-container",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
              transform: "rotate(".concat(_ctx.circleOffset, "deg)")
            })
          }, _hoisted_1010, 4), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: "handle-container",
            style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
              transform: "rotate(".concat(_ctx.sliderValueDegrees + _ctx.circleOffset, "deg)")
            })
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
            class: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeClass"])(["handle", {
              hover: _ctx.applyHandleHoverClass && !_ctx.disabled
            }])
          }, null, 2), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createVNode"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
            name: "fade"
          }, {
            default: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withCtx"])(function() {
              return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementVNode"])("div", {
                class: "tooltip",
                ref: "tooltip",
                style: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["normalizeStyle"])({
                  transform: "rotate(".concat(-_ctx.sliderValueDegrees - _ctx.circleOffset, "deg)"),
                  "--tooltip-margin": "calc(max(calc(".concat(_ctx.tooltipOffset, "px + 34px), calc(").concat(_ctx.tooltipOffset, "px + var(--height) * ").concat(_ctx.applyHandleHoverClass ? "calc(var(--handle-scale, 1.35) * 0.9)" : 1.35, ")) * -1)"),
                  top: _ctx.flipTooltip ? "calc(var(--tooltip-margin) * -0.7)" : "var(--tooltip-margin)"
                })
              }, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toDisplayString"])(_ctx.tooltipText), 5), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], _ctx.showTooltip && !_ctx.disabled && (_ctx.hovering || _ctx.holding) || _ctx.alwaysShowTooltip]])];
            }),
            _: 1
          })], 4)], 44, _hoisted_510));
        }
        var lengthRegex = /(\d*\.?\d+)\s?(cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%+)/i;
        var validateLength = function(val) {
          var result = val.match(lengthRegex);
          return result !== null && result.length <= 3;
        };
        var src_props = {
          width: {
            type: String,
            default: "100%",
            validator: validateLength
          },
          height: {
            type: Number,
            default: 6
          },
          handleScale: {
            type: Number,
            default: 1.35
          },
          alwaysShowHandle: {
            type: Boolean,
            default: false
          },
          color: {
            type: String,
            default: "#FB2727"
          },
          trackColor: {
            type: String,
            default: "#f1f6f828"
          },
          max: {
            type: Number,
            default: 100
          },
          min: {
            type: Number,
            default: 0
          },
          step: {
            type: Number,
            default: 1,
            validator: function validator(val) {
              if (val !== 0) {
                return true;
              } else {
                console.error("[Vue3Slider] Error: Step cannot be 0");
                return false;
              }
            }
          },
          limit: {
            type: Number,
            default: void 0,
            validator: function validator(val) {
              return val === void 0 || typeof val === "number";
            }
          },
          tooltip: {
            type: Boolean,
            default: false
          },
          tooltipText: {
            type: String,
            default: "%v",
            validator: function validator(val) {
              if (!val.includes("%v")) {
                console.error("[Vue3Slider] Error: tooltip text must contain %v");
                return false;
              }
              return true;
            }
          },
          tooltipColor: {
            type: String,
            default: "#FFFFFF"
          },
          tooltipTextColor: {
            type: String,
            default: "#000000"
          },
          formatTooltip: {
            validator: function validator(val) {
              if (typeof val !== "function") {
                console.error("[Vue3Slider] Error: formatTooltip must be a function");
                return false;
              } else if (typeof val(0) !== "string") {
                console.error("[Vue3Slider] Error: formatTooltip must return a string");
                return false;
              }
              return true;
            }
          },
          alwaysShowTooltip: {
            type: Boolean,
            default: false
          },
          flipTooltip: {
            type: Boolean,
            default: false
          },
          orientation: {
            type: String,
            default: "horizontal",
            validator: function validator(val) {
              return val === "horizontal" || val === "vertical" || val === "circular";
            }
          },
          modelValue: {
            type: Number,
            default: 0,
            required: true
          },
          repeat: {
            type: Boolean,
            default: false
          },
          sticky: {
            type: Boolean,
            default: false
          },
          flip: {
            type: Boolean,
            default: false
          },
          circleOffset: {
            type: Number,
            default: 0,
            validator: function validator(val) {
              return val >= 0 && val <= 360;
            }
          },
          circleGap: {
            type: Number,
            default: 0,
            validator: function validator(val) {
              return val >= 0 && val <= 360;
            }
          },
          disabled: {
            type: Boolean,
            default: false
          }
        };
        function useStore(props) {
          var slider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(document.createElement("div"));
          var modelValueUnrounded = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.modelValue);
          if (props.min !== 0)
            modelValueUnrounded.value -= props.min;
          var formattedSliderValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
          var sliderWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
          var filledWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
          var pixelsPerStep = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(1);
          var sliderRange = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            var range = 0;
            if (props.min < 0) {
              range = props.max + Math.abs(props.min);
            } else {
              range = props.max - props.min;
            }
            return range;
          });
          var sliderValueDegrees = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            if (props.orientation !== "circular")
              return 0;
            var degrees = modelValueUnrounded.value / (sliderRange.value / (360 - props.circleGap));
            return props.flip ? -degrees : degrees;
          });
          var holding = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
          var store = {
            slider,
            modelValueUnrounded,
            formattedSliderValue,
            filledWidth,
            pixelsPerStep,
            sliderRange,
            sliderValueDegrees,
            sliderWidth,
            holding
          };
          return store;
        }
        function useFilledWidthObserver(store, props) {
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(function() {
            store.filledWidth.value = getNewFilledWidth(store, props);
          });
          var observer = new ResizeObserver(function(entries) {
            store.filledWidth.value = getNewFilledWidth(store, props);
            store.sliderWidth.value = store.slider.value ? props.orientation === "vertical" ? store.slider.value.clientHeight : store.slider.value.clientWidth : 0;
            if (store.slider.value !== entries[0].target && store.slider.value instanceof Element) {
              observer.unobserve(entries[0].target);
              observer.observe(store.slider.value);
            }
          });
          if (store.slider.value)
            observer.observe(store.slider.value);
        }
        function getNewFilledWidth(store, props) {
          var slider = store.slider;
          if (!slider.value)
            return 0;
          var sliderWidth = props.orientation === "vertical" ? slider.value.clientHeight : slider.value.clientWidth;
          store.pixelsPerStep.value = sliderWidth / store.sliderRange.value;
          var clamped = Math.max(Math.min(store.modelValueUnrounded.value * store.pixelsPerStep.value, sliderWidth), 0);
          return clamped;
        }
        function useTooltipObserver(tooltip, tooltipWidth) {
          var observer = new ResizeObserver(function(entries) {
            if (tooltip.value) {
              tooltipWidth.value = tooltip.value.clientWidth;
              if (tooltip.value !== entries[0].target) {
                observer.unobserve(entries[0].target);
                if (tooltip.value)
                  observer.observe(tooltip.value);
              }
            }
          });
          if (tooltip.value)
            observer.observe(tooltip.value);
        }
        var useKeyboardControls = function(store, props, updateModelValue) {
          var calculateValueFromDiff = function calculateValueFromDiff2(diff) {
            var newVal = store.modelValueUnrounded.value + diff;
            newVal = Math.min(store.sliderRange.value, Math.max(0, newVal));
            if (props.limit !== void 0)
              newVal = Math.min(newVal, props.limit + Math.abs(props.min));
            updateModelValue(newVal);
          };
          var handleKeydown = function handleKeydown2(e) {
            switch (e.key) {
              case "ArrowRight":
              case "ArrowUp":
                calculateValueFromDiff(props.step);
                break;
              case "ArrowLeft":
              case "ArrowDown":
                calculateValueFromDiff(-props.step);
                break;
            }
          };
          return {
            handleKeydown
          };
        };
        var useModelValue = function(store, props, emit2) {
          var modelValueRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.modelValue);
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(function() {
            return modelValueRef.value = props.modelValue;
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(modelValueRef, function(val) {
            if (store.formattedSliderValue.value !== val) {
              if (props.limit !== void 0)
                val = Math.min(val, props.limit);
              var newValue = 0;
              if (props.min < 0) {
                newValue = val + Math.abs(props.min);
              } else {
                newValue = val - props.min;
              }
              newValue = Math.min(newValue, store.sliderRange.value);
              updateModelValue(newValue);
            }
          });
          var formatModelValue = function formatModelValue2(val) {
            var step = props.step;
            var roundedVal = 0;
            if (val > 0) {
              roundedVal = Math.round(val / step) * step;
            } else {
              roundedVal = 0;
            }
            roundedVal = roundedVal + props.min;
            if (props.limit !== void 0)
              roundedVal = Math.min(roundedVal, props.limit);
            return roundedVal;
          };
          var updateModelValue = function updateModelValue2(val) {
            store.formattedSliderValue.value = formatModelValue(val);
            if (props.sticky) {
              store.modelValueUnrounded.value = store.formattedSliderValue.value - props.min;
            } else {
              store.modelValueUnrounded.value = val;
            }
            emit2("update:modelValue", store.formattedSliderValue.value);
            emit2("change", store.formattedSliderValue.value);
          };
          return {
            formatModelValue,
            updateModelValue,
            modelValueRef
          };
        };
        var useDragHandler = function(store, props, emit2, updateModelValue) {
          var previousSliderValue = store.formattedSliderValue.value;
          var calcSliderValue = function calcSliderValue2(mouseX, mouseY, dragging) {
            var rect = store.slider.value.getBoundingClientRect();
            var value = 0;
            if (props.orientation === "horizontal") {
              value = (mouseX - rect.x) / store.pixelsPerStep.value;
              if (props.flip) {
                value = store.sliderRange.value - value;
              }
            } else if (props.orientation === "vertical") {
              value = (rect.y + rect.height - mouseY) / store.pixelsPerStep.value;
              if (props.flip) {
                value = store.sliderRange.value - value;
              }
            } else {
              var sliderX = mouseX - rect.x;
              var sliderY = mouseY - rect.y;
              var centerX = rect.width / 2;
              var centerY = rect.height / 2;
              var gradient = (sliderY - centerY) / (sliderX - centerX);
              var angle = Math.atan(gradient) * 180 / Math.PI;
              if (sliderX >= centerX) {
                if (sliderY < centerY) {
                  if (Math.ceil(angle) === 180) {
                    angle = 0;
                  } else {
                    angle = 90 - Math.abs(angle);
                  }
                } else {
                  angle += 90;
                }
              } else {
                if (sliderY < centerY) {
                  angle = 270 + angle;
                } else {
                  angle = 270 + angle;
                }
              }
              angle -= props.circleOffset;
              while (angle < 0) {
                angle += 360;
              }
              if (props.flip) {
                angle = 360 - angle;
              }
              var valPerDeg = store.sliderRange.value / (360 - props.circleGap);
              value = angle * valPerDeg;
              if (!props.repeat && dragging) {
                var diff = Math.abs(value - previousSliderValue);
                if (diff > valPerDeg * 30) {
                  value = previousSliderValue;
                }
              }
            }
            value = Math.min(store.sliderRange.value, Math.max(value, 0));
            if (props.limit !== void 0)
              value = Math.min(value, props.limit + Math.abs(props.min));
            previousSliderValue = value;
            return value;
          };
          var draggingHandler = function draggingHandler2(e) {
            var tap;
            if (e.type === "mousemove") {
              e = e;
              tap = e;
            } else {
              e = e;
              if (e.touches.length > 1)
                return;
              tap = e.touches[0];
            }
            if (store.holding.value) {
              var rect = store.slider.value.getBoundingClientRect();
              var tapPosInsideSlider = props.orientation === "vertical" ? rect.y + rect.height - tap.pageY : tap.pageX - rect.x;
              tapPosInsideSlider = Math.min(store.sliderWidth.value, Math.max(tapPosInsideSlider, 0));
              updateModelValue(calcSliderValue(tap.pageX - window.scrollX, tap.pageY - window.scrollY, true));
              emit2("dragging", store.formattedSliderValue.value, tap);
            }
          };
          var releaseDragHandler = function releaseDragHandler2(e) {
            if (store.holding.value)
              store.holding.value = false;
            if (e.type === "mouseup") {
              window.removeEventListener("mouseup", releaseDragHandler2);
              window.removeEventListener("mousemove", draggingHandler);
            } else {
              window.removeEventListener("touchend", releaseDragHandler2);
              window.removeEventListener("touchmove", draggingHandler);
            }
            emit2("drag-end", store.formattedSliderValue.value, e);
          };
          var clickHandler = function clickHandler2(e) {
            e.preventDefault();
            store.holding.value = true;
            emit2("drag-start", store.formattedSliderValue.value, e);
            if (e.type === "touchstart") {
              e = e;
              if (e.touches.length > 1)
                return;
              var t = e.touches[0];
              updateModelValue(calcSliderValue(t.pageX - window.scrollX, t.pageY - window.scrollY, false));
              window.addEventListener("touchend", releaseDragHandler);
              window.addEventListener("touchmove", draggingHandler);
            } else {
              e = e;
              updateModelValue(calcSliderValue(e.pageX - window.scrollX, e.pageY - window.scrollY, false));
              window.addEventListener("mouseup", releaseDragHandler);
              window.addEventListener("mousemove", draggingHandler);
            }
          };
          return {
            clickHandler
          };
        };
        var vue3_slidervue_type_script_lang_ts = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "vue3-slider",
          props: src_props,
          setup: function setup(props, _ref) {
            var emit2 = _ref.emit;
            if (props.modelValue < props.min || props.modelValue > props.max) {
              console.error("[Vue3Slider] Error: value exceeds limits of slider");
            }
            if (props.max <= props.min) {
              console.error("[Vue3Slider] Error: Max value cannot be less than or equal to the min value. This will cause unexpected errors to occur, please fix.");
            }
            var store = useStore(props);
            var _useModelValue = useModelValue(store, props, emit2), updateModelValue = _useModelValue.updateModelValue, formatModelValue = _useModelValue.formatModelValue;
            var _useKeyBoardControls = useKeyboardControls(store, props, updateModelValue), handleKeydown = _useKeyBoardControls.handleKeydown;
            var _useDragHandler = useDragHandler(store, props, emit2, updateModelValue), clickHandler = _useDragHandler.clickHandler;
            var hovering = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
            var applyHandleHoverClass = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (store.holding.value) {
                return true;
              } else {
                return props.alwaysShowHandle || hovering.value;
              }
            });
            var tooltip = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])();
            var tooltipText = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (!props.tooltip)
                return "";
              var stringValue = "";
              if (props.formatTooltip !== null && typeof props.formatTooltip === "function") {
                stringValue = props.formatTooltip(store.formattedSliderValue.value || formatModelValue(store.modelValueUnrounded.value));
              } else {
                stringValue = (store.formattedSliderValue.value || formatModelValue(store.modelValueUnrounded.value)).toString();
              }
              return props.tooltipText.replace("%v", stringValue);
            });
            var tooltipWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var tooltipOffset = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (!props.tooltip)
                return 0;
              var width = tooltipWidth.value;
              if (props.orientation !== "horizontal") {
                var _tooltip$value;
                width = (_tooltip$value = tooltip.value) === null || _tooltip$value === void 0 ? void 0 : _tooltip$value.clientHeight;
                if (!width) {
                  width = 20;
                }
                if (props.orientation !== "vertical") {
                  return width;
                }
              } else {
                if (!width) {
                  width = 14 + store.formattedSliderValue.value.toString().length * 9;
                } else {
                  width += props.height / 3;
                }
              }
              return store.filledWidth.value - width / 2;
            });
            var circumference = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (!store.slider.value || props.orientation !== "circular")
                return 1;
              return 2 * Math.PI * (store.sliderWidth.value / 2);
            });
            var trackStrokeOffset = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (props.orientation !== "circular")
                return 0;
              return props.circleGap / 360 * circumference.value;
            });
            var strokeOffset = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              if (props.orientation !== "circular")
                return 0;
              return circumference.value - store.modelValueUnrounded.value / store.sliderRange.value * circumference.value * (1 - props.circleGap / 360);
            });
            var vars = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return {
                "--width": props.width,
                "--height": props.height + "px",
                "--color": props.color,
                "--track-color": props.trackColor,
                "--tooltip-color": props.tooltipColor,
                "--tooltip-text-color": props.tooltipTextColor,
                "--handle-scale": props.handleScale
              };
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              useFilledWidthObserver(store, props);
              useTooltipObserver(tooltip, tooltipWidth);
            });
            return {
              filledWidth: store.filledWidth,
              slider: store.slider,
              holding: store.holding,
              flip: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return props.flip;
              }),
              clickHandler,
              handleKeydown,
              applyHandleHoverClass,
              hovering,
              showTooltip: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return props.tooltip;
              }),
              alwaysShowTooltip: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return props.alwaysShowTooltip;
              }),
              tooltip,
              tooltipText,
              tooltipOffset,
              vars,
              circumference,
              trackStrokeOffset,
              strokeOffset,
              circleOffset: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return props.circleOffset;
              }),
              circleGap: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
                return props.circleGap;
              }),
              sliderValueDegrees: store.sliderValueDegrees
            };
          }
        });
        __webpack_require__("6ac3");
        vue3_slidervue_type_script_lang_ts.render = render2;
        var vue3_slider = vue3_slidervue_type_script_lang_ts;
        var entry_esm = /* @__PURE__ */ function() {
          var installable = vue3_slider;
          installable.install = function(app) {
            app.component("Vue3Slider", installable);
          };
          return installable;
        }();
        function _slicedToArray(arr, i2) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o2, minLen) {
          if (!o2)
            return;
          if (typeof o2 === "string")
            return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor)
            n2 = o2.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return _arrayLikeToArray(o2, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
            arr2[i2] = arr[i2];
          }
          return arr2;
        }
        function _iterableToArrayLimit(arr, i2) {
          var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
          if (_i == null)
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e2;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i2 && _arr.length === i2)
                break;
            }
          } catch (err) {
            _d = true;
            _e2 = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e2;
            }
          }
          return _arr;
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        Object.entries(entry_esm_namespaceObject).forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), exportName = _ref2[0], exported = _ref2[1];
          if (exportName !== "default")
            entry_esm[exportName] = exported;
        });
        var entry = entry_esm;
        __webpack_exports__["default"] = entry;
      }
    ),
    /***/
    "ff3a": (
      /***/
      function(module2, exports, __webpack_require__) {
        var content = __webpack_require__("f855");
        if (content.__esModule)
          content = content.default;
        if (typeof content === "string")
          content = [[module2.i, content, ""]];
        if (content.locals)
          module2.exports = content.locals;
        var add2 = __webpack_require__("499e").default;
        add2("fc2d99b4", content, true, { "sourceMap": false, "shadowMode": false });
      }
    )
    /******/
  });
})(vue3Slider_common);
var vue3Slider_commonExports = vue3Slider_common.exports;
const Slider = /* @__PURE__ */ getDefaultExportFromCjs(vue3Slider_commonExports);
const VideoFeed_vue_vue_type_style_index_0_scoped_9c47a4ff_lang = "";
const _sfc_main$2 = {
  props: {
    localVideo: Boolean,
    // is our local webcam (not other's camera)
    poppedOut: Boolean,
    // Video is popped-out and draggable
    username: String,
    // username related to this video
    isExplicit: Boolean,
    // camera is marked Explicit
    isMuted: Boolean,
    // camera is muted on our end
    isSourceMuted: Boolean,
    // camera is muted on the broadcaster's end
    isWatchingMe: Boolean,
    // other video is watching us back
    isFrozen: Boolean,
    // video is detected as frozen
    isSpeaking: Boolean,
    // video is registering audio
    watermarkImage: Image
    // watermark image to overlay (nullable)
  },
  components: {
    Slider
  },
  data() {
    return {
      // Volume slider
      volume: 100,
      // Volume change debounce
      volumeDebounce: null,
      // Mouse over status
      mouseOver: false
    };
  },
  computed: {
    containerID() {
      return this.videoID + "-container";
    },
    videoID() {
      return this.localVideo ? "localVideo" : `videofeed-${this.username}`;
    },
    textColorClass() {
      return this.isExplicit ? "has-text-camera-red" : "has-text-camera-blue";
    },
    muteButtonClass() {
      let classList = [
        "button is-small ml-1 px-2"
      ];
      if (this.isMuted) {
        classList.push("is-danger");
      } else {
        classList.push("is-success is-outlined");
      }
      return classList.join(" ");
    },
    muteIconClass() {
      if (this.localVideo) {
        return this.isMuted ? "fa-microphone-slash" : "fa-microphone";
      }
      return this.isMuted ? "fa-volume-xmark" : "fa-volume-high";
    }
  },
  methods: {
    closeVideo() {
      this.$emit("close-video", this.username, "offerer");
    },
    reopenVideo() {
      this.$emit("reopen-video", this.username, true);
    },
    openProfile() {
      this.$emit("open-profile", this.username);
    },
    // Toggle the Mute button
    muteVideo() {
      this.$emit("mute-video", this.username);
    },
    popoutVideo() {
      this.$emit("popout", this.username);
    },
    fullscreen(force = false) {
      if (this.poppedOut && !force) {
        this.popoutVideo();
        window.requestAnimationFrame(() => {
          this.fullscreen(true);
        });
        return;
      }
      let $elem = document.getElementById(this.containerID);
      if ($elem) {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else if ($elem.requestFullscreen) {
          $elem.requestFullscreen();
        } else {
          window.alert("Fullscreen not supported by your browser.");
        }
      }
    },
    volumeChanged() {
      if (this.volumeDebounce !== null) {
        clearTimeout(this.volumeDebounce);
      }
      this.volumeDebounce = setTimeout(() => {
        this.$emit("set-volume", this.username, this.volume);
      }, 200);
    }
  }
};
const _withScopeId = (n2) => (pushScopeId("data-v-9c47a4ff"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$2 = ["id"];
const _hoisted_2$2 = ["id", "muted"];
const _hoisted_3$2 = { key: 0 };
const _hoisted_4$2 = ["src"];
const _hoisted_5$2 = ["src"];
const _hoisted_6$2 = {
  key: 0,
  class: "fa fa-microphone-slash mr-1 has-text-grey"
};
const _hoisted_7$2 = ["title"];
const _hoisted_8$2 = {
  key: 3,
  class: "ml-1",
  title: "Speaking"
};
const _hoisted_9$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-volume-high has-text-info" }, null, -1));
const _hoisted_10$2 = [
  _hoisted_9$2
];
const _hoisted_11$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-close" }, null, -1));
const _hoisted_12$2 = [
  _hoisted_11$2
];
const _hoisted_13$2 = { class: "controls" };
const _hoisted_14$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-up-right-from-square" }, null, -1));
const _hoisted_15$2 = [
  _hoisted_14$2
];
const _hoisted_16$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-expand" }, null, -1));
const _hoisted_17$2 = [
  _hoisted_16$2
];
const _hoisted_18$2 = { class: "volume-slider" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slider = resolveComponent("Slider");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["feed", {
      "popped-out": $props.poppedOut,
      "popped-in": !$props.poppedOut
    }]),
    id: $options.containerID,
    onMouseover: _cache[7] || (_cache[7] = ($event) => $data.mouseOver = true),
    onMouseleave: _cache[8] || (_cache[8] = ($event) => $data.mouseOver = false)
  }, [
    createBaseVNode("video", {
      id: $options.videoID,
      autoplay: "",
      disablepictureinpicture: "",
      playsinline: "",
      oncontextmenu: "return false;",
      muted: $props.localVideo
    }, null, 8, _hoisted_2$2),
    $props.watermarkImage ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
      createBaseVNode("img", {
        src: $props.watermarkImage,
        class: "watermark"
      }, null, 8, _hoisted_4$2),
      createBaseVNode("img", {
        src: $props.watermarkImage,
        class: "corner-watermark seethru invert-color"
      }, null, 8, _hoisted_5$2)
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(["caption", $options.textColorClass])
    }, [
      $props.isSourceMuted ? (openBlock(), createElementBlock("i", _hoisted_6$2)) : createCommentVNode("", true),
      createBaseVNode("a", {
        href: "#",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.openProfile && $options.openProfile(...args), ["prevent"])),
        class: normalizeClass($options.textColorClass)
      }, toDisplayString($props.username), 3),
      $props.isWatchingMe ? (openBlock(), createElementBlock("i", {
        key: 1,
        class: "fa fa-people-arrows ml-1 has-text-grey is-size-7",
        title: $props.username + " is watching your camera too"
      }, null, 8, _hoisted_7$2)) : createCommentVNode("", true),
      !$props.localVideo && $props.isFrozen ? (openBlock(), createElementBlock("a", {
        key: 2,
        class: "fa fa-mountain ml-1",
        href: "#",
        style: { "color": "#00FFFF" },
        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $options.reopenVideo(), ["prevent"])),
        title: "Frozen video detected!"
      })) : createCommentVNode("", true),
      $props.isSpeaking ? (openBlock(), createElementBlock("span", _hoisted_8$2, _hoisted_10$2)) : createCommentVNode("", true)
    ], 2),
    !$props.localVideo ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(["close", { "seethru": !$data.mouseOver }])
    }, [
      createBaseVNode("a", {
        href: "#",
        class: "button is-small is-danger is-outlined px-2",
        title: "Close video",
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $options.closeVideo(), ["prevent"]))
      }, _hoisted_12$2)
    ], 2)) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_13$2, [
      createBaseVNode("button", {
        type: "button",
        class: normalizeClass($options.muteButtonClass),
        onClick: _cache[3] || (_cache[3] = ($event) => $options.muteVideo())
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["fa", $options.muteIconClass])
        }, null, 2)
      ], 2),
      createBaseVNode("button", {
        type: "button",
        class: normalizeClass(["button is-small is-light is-outlined p-2 ml-2", { "seethru": !$data.mouseOver }]),
        title: "Pop out",
        onClick: _cache[4] || (_cache[4] = ($event) => $options.popoutVideo())
      }, _hoisted_15$2, 2),
      createBaseVNode("button", {
        type: "button",
        class: normalizeClass(["button is-small is-light is-outlined p-2 ml-2", { "seethru": !$data.mouseOver }]),
        title: "Go full screen",
        onClick: _cache[5] || (_cache[5] = ($event) => $options.fullscreen())
      }, _hoisted_17$2, 2)
    ]),
    withDirectives(createBaseVNode("div", _hoisted_18$2, [
      createVNode(_component_Slider, {
        modelValue: $data.volume,
        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.volume = $event),
        color: "#00FF00",
        "track-color": "#006600",
        min: 0,
        max: 100,
        step: 1,
        height: 7,
        orientation: "vertical",
        onChange: $options.volumeChanged
      }, null, 8, ["modelValue", "onChange"])
    ], 512), [
      [vShow, !$props.localVideo && !$props.isMuted && $data.mouseOver]
    ])
  ], 42, _hoisted_1$2);
}
const VideoFeed = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-9c47a4ff"]]);
const _sfc_main$1 = {
  props: {
    visible: Boolean,
    jwt: String,
    // caller's JWT token for authorization
    user: Object,
    // the user we are viewing
    username: String,
    // the local user
    isViewerOp: Boolean,
    // the viewer is an operator (show buttons)
    websiteUrl: String,
    isDnd: Boolean,
    isMuted: Boolean,
    isBooted: Boolean,
    profileWebhookEnabled: Boolean,
    vipConfig: Object
    // VIP config settings for BareRTC
  },
  data() {
    return {
      busy: false,
      // Profile data
      profileFields: [],
      // Ban account data
      banModalVisible: false,
      banReason: "",
      banDuration: 24,
      // Error messaging from backend
      error: null
    };
  },
  watch: {
    visible() {
      if (this.visible) {
        this.refresh();
      } else {
        this.profileFields = [];
        this.error = null;
        this.busy = false;
      }
    }
  },
  computed: {
    profileURL() {
      if (this.user.profileURL) {
        return this.urlFor(this.user.profileURL);
      }
      return null;
    },
    avatarURL() {
      if (this.user.avatar) {
        return this.urlFor(this.user.avatar);
      }
      return null;
    },
    nickname() {
      if (this.user.nickname) {
        return this.user.nickname;
      }
      return this.user.username;
    },
    isOnBlueCam() {
      if (this.user.video & VideoFlag.Active && !(this.user.video & VideoFlag.NSFW)) {
        return true;
      }
      return false;
    },
    isOnCamera() {
      return this.user.video & VideoFlag.Active;
    }
  },
  methods: {
    refresh() {
      var _a, _b;
      if (!this.profileWebhookEnabled)
        return;
      if (!this.user || !((_a = this.user) == null ? void 0 : _a.username))
        return;
      this.busy = true;
      return fetch("/api/profile", {
        method: "POST",
        mode: "same-origin",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          "JWTToken": this.jwt,
          "Username": (_b = this.user) == null ? void 0 : _b.username
        })
      }).then((response) => response.json()).then((data) => {
        if (data.Error) {
          this.error = data.Error;
          return;
        }
        if (data.ProfileFields != void 0) {
          this.profileFields = data.ProfileFields;
        }
      }).catch((resp) => {
        this.error = resp;
      }).finally(() => {
        this.busy = false;
      });
    },
    cancel() {
      this.$emit("cancel");
    },
    openProfile() {
      let url = this.profileURL;
      if (url) {
        window.open(url);
      }
    },
    openDMs() {
      this.cancel();
      this.$emit("send-dm", {
        username: this.user.username
      });
    },
    muteUser() {
      this.$emit("mute-user", this.user.username);
    },
    bootUser() {
      this.$emit("boot-user", this.user.username);
    },
    // Operator commands (may be rejected by server if not really Op)
    markNsfw() {
      if (!window.confirm("Mark this user's webcam as 'Explicit'?"))
        return;
      this.$emit("send-command", `/nsfw ${this.user.username}`);
      this.cancel();
    },
    cutCamera() {
      if (!window.confirm("Make this user stop broadcasting their camera?"))
        return;
      this.$emit("send-command", `/cut ${this.user.username}`);
      this.cancel();
    },
    kickUser() {
      if (!window.confirm("Really kick this user from the chat room?"))
        return;
      this.$emit("send-command", `/kick ${this.user.username}`);
    },
    banUser() {
      this.banModalVisible = true;
      this.banReason = "";
      this.banDuration = 24;
      window.requestAnimationFrame(() => {
        let reason = document.querySelector("#ban_reason");
        if (reason) {
          reason.focus();
        }
      });
    },
    confirmBan() {
      this.$emit("send-command", `/ban ${this.user.username} ${this.banDuration}`);
      this.$emit("report", {
        message: {
          channel: `n/a`,
          username: this.user.username,
          at: /* @__PURE__ */ new Date(),
          message: "Ban reason: " + this.banReason
        },
        classification: "User banned by admin",
        comment: `A chat admin has banned ${this.user.username} from the chat room!

* Chat admin: <a href="/u/${this.username}">${this.username}</a>
* Reason: ${this.banReason}
* Duration: ${this.banDuration} hours`
      });
      this.banModalVisible = false;
      this.cancel();
    },
    urlFor(url) {
      if (url.match(/^https?:/i)) {
        return url;
      }
      return this.websiteUrl.replace(/\/+$/, "") + url;
    }
  }
};
const _hoisted_1$1 = { class: "modal-content" };
const _hoisted_2$1 = { class: "card" };
const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-success" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "Profile Card")
], -1);
const _hoisted_4$1 = { class: "card-content" };
const _hoisted_5$1 = { class: "media mb-0" };
const _hoisted_6$1 = { class: "media-left" };
const _hoisted_7$1 = ["href"];
const _hoisted_8$1 = { class: "image is-96x96" };
const _hoisted_9$1 = ["src"];
const _hoisted_10$1 = {
  key: 1,
  src: _imports_0
};
const _hoisted_11$1 = { class: "media-content" };
const _hoisted_12$1 = ["href"];
const _hoisted_13$1 = {
  key: 1,
  class: "has-text-grey"
};
const _hoisted_14$1 = {
  key: 0,
  class: "mt-4"
};
const _hoisted_15$1 = {
  key: 0,
  class: "mr-2"
};
const _hoisted_16$1 = {
  key: 1,
  class: "tag is-warning is-light mr-2"
};
const _hoisted_17$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-peace mr-1" }, null, -1);
const _hoisted_18$1 = ["title"];
const _hoisted_19$1 = {
  key: 0,
  class: "mt-4"
};
const _hoisted_20$1 = ["title", "disabled"];
const _hoisted_21$1 = {
  key: 0,
  class: "mt-1"
};
const _hoisted_22$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-video mr-1 has-text-danger" }, null, -1);
const _hoisted_23$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-stop mr-1 has-text-danger" }, null, -1);
const _hoisted_24$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-shoe-prints mr-1 has-text-danger" }, null, -1);
const _hoisted_25$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-clock mr-1 has-text-danger" }, null, -1);
const _hoisted_26$1 = {
  key: 1,
  class: "notification is-info is-light p-2 my-2"
};
const _hoisted_27$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-spinner fa-spin mr-2" }, null, -1);
const _hoisted_28$1 = {
  key: 2,
  class: "notification is-danger is-light p-2 my-2"
};
const _hoisted_29$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-exclamation-triangle mr-2" }, null, -1);
const _hoisted_30$1 = {
  key: 3,
  class: "columns is-multiline is-mobile mt-3"
};
const _hoisted_31$1 = { class: "card-footer" };
const _hoisted_32$1 = ["href"];
const _hoisted_33$1 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-external-link ml-2" }, null, -1);
const _hoisted_34$1 = { class: "modal-content" };
const _hoisted_35$1 = { class: "card" };
const _hoisted_36$1 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-danger" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "Ban User")
], -1);
const _hoisted_37$1 = { class: "card-content" };
const _hoisted_38$1 = { class: "field" };
const _hoisted_39$1 = /* @__PURE__ */ createBaseVNode("label", {
  class: "label",
  for: "ban_reason"
}, "Reason for the ban:", -1);
const _hoisted_40$1 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " This reason is NOT shown to the banned user, but will be sent to the main website in an admin report so that it may be documented in this user's history. ", -1);
const _hoisted_41$1 = { class: "field" };
const _hoisted_42$1 = /* @__PURE__ */ createBaseVNode("label", {
  class: "label",
  for: "ban_duration"
}, "How long for the ban? (1-96 hours)", -1);
const _hoisted_43$1 = { class: "field has-text-centered" };
const _hoisted_44$1 = /* @__PURE__ */ createBaseVNode("button", {
  type: "submit",
  class: "button is-danger"
}, " Confirm Ban ", -1);
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", {
      class: normalizeClass(["modal", { "is-active": $props.visible }])
    }, [
      createBaseVNode("div", {
        class: "modal-background",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.cancel())
      }),
      createBaseVNode("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2$1, [
          _hoisted_3$1,
          createBaseVNode("div", _hoisted_4$1, [
            createBaseVNode("div", _hoisted_5$1, [
              createBaseVNode("div", _hoisted_6$1, [
                createBaseVNode("a", {
                  href: $options.profileURL,
                  onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $options.openProfile(), ["prevent"])),
                  class: normalizeClass({ "cursor-default": !$options.profileURL })
                }, [
                  createBaseVNode("figure", _hoisted_8$1, [
                    $options.avatarURL ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      src: $options.avatarURL
                    }, null, 8, _hoisted_9$1)) : (openBlock(), createElementBlock("img", _hoisted_10$1))
                  ])
                ], 10, _hoisted_7$1)
              ]),
              createBaseVNode("div", _hoisted_11$1, [
                createBaseVNode("strong", null, toDisplayString($options.nickname), 1),
                createBaseVNode("div", null, [
                  createBaseVNode("small", null, [
                    $options.profileURL ? (openBlock(), createElementBlock("a", {
                      key: 0,
                      href: $options.profileURL,
                      target: "_blank",
                      class: "has-text-grey"
                    }, " @" + toDisplayString($props.user.username), 9, _hoisted_12$1)) : (openBlock(), createElementBlock("span", _hoisted_13$1, "@" + toDisplayString($props.user.username), 1))
                  ])
                ]),
                $props.user.op || $props.user.vip || $props.user.emoji ? (openBlock(), createElementBlock("div", _hoisted_14$1, [
                  $props.user.emoji ? (openBlock(), createElementBlock("span", _hoisted_15$1, toDisplayString($props.user.emoji), 1)) : createCommentVNode("", true),
                  $props.user.op ? (openBlock(), createElementBlock("span", _hoisted_16$1, [
                    _hoisted_17$1,
                    createTextVNode(" Operator ")
                  ])) : createCommentVNode("", true),
                  $props.vipConfig && $props.user.vip ? (openBlock(), createElementBlock("span", {
                    key: 2,
                    class: "tag is-success is-light mr-2",
                    title: $props.vipConfig.Name
                  }, [
                    createBaseVNode("i", {
                      class: normalizeClass(["mr-1", $props.vipConfig.Icon])
                    }, null, 2),
                    createTextVNode(" " + toDisplayString($props.vipConfig.Name), 1)
                  ], 8, _hoisted_18$1)) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ])
            ]),
            $props.user.username !== $props.username ? (openBlock(), createElementBlock("div", _hoisted_19$1, [
              createBaseVNode("button", {
                type: "button",
                class: "button is-small px-2 mb-1",
                onClick: _cache[2] || (_cache[2] = ($event) => $options.openDMs()),
                title: $props.isDnd ? "This person is not accepting new DMs" : "Open a Direct Message (DM) thread",
                disabled: $props.isDnd
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(["fa mr-1", { "fa-comment": !$props.isDnd, "fa-comment-slash": $props.isDnd }])
                }, null, 2),
                createTextVNode(" Direct Message ")
              ], 8, _hoisted_20$1),
              createBaseVNode("button", {
                type: "button",
                class: "button is-small px-2 ml-1 mb-1",
                onClick: _cache[3] || (_cache[3] = ($event) => $options.muteUser()),
                title: "Mute user"
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(["fa fa-comment-slash mr-1", {
                    "has-text-success": $props.isMuted,
                    "has-text-danger": !$props.isMuted
                  }])
                }, null, 2),
                createTextVNode(" " + toDisplayString($props.isMuted ? "Unmute" : "Mute") + " Messages ", 1)
              ]),
              createBaseVNode("button", {
                type: "button",
                class: "button is-small px-2 ml-1 mb-1",
                onClick: _cache[4] || (_cache[4] = ($event) => $options.bootUser()),
                title: "Boot user off your webcam"
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(["fa fa-user-xmark mr-1", {
                    "has-text-danger": !$props.isBooted,
                    "has-text-success": $props.isBooted
                  }])
                }, null, 2),
                createTextVNode(" " + toDisplayString($props.isBooted ? "Allow to watch my webcam" : "Don't allow to watch my webcam"), 1)
              ]),
              $props.isViewerOp ? (openBlock(), createElementBlock("div", _hoisted_21$1, [
                $options.isOnBlueCam ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  class: "button is-small is-outlined is-danger has-text-dark px-2 mr-1 mb-1",
                  onClick: _cache[5] || (_cache[5] = ($event) => $options.markNsfw()),
                  title: "Mark their camera as Explicit (red)."
                }, [
                  _hoisted_22$1,
                  createTextVNode(" Mark camera as Explicit ")
                ])) : createCommentVNode("", true),
                $options.isOnCamera ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  class: "button is-small is-outlined is-danger has-text-dark px-2 mr-1 mb-1",
                  onClick: _cache[6] || (_cache[6] = ($event) => $options.cutCamera()),
                  title: "Turn their camera off."
                }, [
                  _hoisted_23$1,
                  createTextVNode(" Cut camera ")
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-small is-outlined is-danger has-text-dark px-2 mr-1 mb-1",
                  onClick: _cache[7] || (_cache[7] = ($event) => $options.kickUser()),
                  title: "Kick this user from the chat room."
                }, [
                  _hoisted_24$1,
                  createTextVNode(" Kick from the room ")
                ]),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-small is-outlined is-danger has-text-dark px-2 mb-1",
                  onClick: _cache[8] || (_cache[8] = ($event) => $options.banUser()),
                  title: "Ban this user from the chat room for 24 hours."
                }, [
                  _hoisted_25$1,
                  createTextVNode(" Ban from chat ")
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            $data.busy ? (openBlock(), createElementBlock("div", _hoisted_26$1, [
              _hoisted_27$1,
              createTextVNode(" Loading profile details... ")
            ])) : $data.error ? (openBlock(), createElementBlock("div", _hoisted_28$1, [
              _hoisted_29$1,
              createTextVNode(" Error loading profile details: " + toDisplayString($data.error), 1)
            ])) : $data.profileFields.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.profileFields, (field, i2) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(["column py-1", { "is-half": i2 < $data.profileFields.length - 1 }]),
                  key: field.Name
                }, [
                  createBaseVNode("strong", null, toDisplayString(field.Name) + ":", 1),
                  createTextVNode(" " + toDisplayString(field.Value), 1)
                ], 2);
              }), 128))
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("footer", _hoisted_31$1, [
            $options.profileURL ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: $options.profileURL,
              target: "_blank",
              class: "card-footer-item",
              onClick: _cache[9] || (_cache[9] = ($event) => $options.cancel())
            }, [
              createTextVNode(" Full profile "),
              _hoisted_33$1
            ], 8, _hoisted_32$1)) : createCommentVNode("", true),
            createBaseVNode("a", {
              href: "#",
              onClick: _cache[10] || (_cache[10] = withModifiers(($event) => $options.cancel(), ["prevent"])),
              class: "card-footer-item"
            }, " Close ")
          ])
        ])
      ])
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(["modal", { "is-active": $data.banModalVisible }])
    }, [
      createBaseVNode("div", {
        class: "modal-background",
        onClick: _cache[11] || (_cache[11] = ($event) => $data.banModalVisible = false)
      }),
      createBaseVNode("div", _hoisted_34$1, [
        createBaseVNode("form", {
          onSubmit: _cache[15] || (_cache[15] = withModifiers((...args) => $options.confirmBan && $options.confirmBan(...args), ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_35$1, [
            _hoisted_36$1,
            createBaseVNode("div", _hoisted_37$1, [
              createBaseVNode("div", _hoisted_38$1, [
                _hoisted_39$1,
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  class: "input",
                  id: "ban_reason",
                  placeholder: "Please describe why this user will be banned.",
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.banReason = $event),
                  required: ""
                }, null, 512), [
                  [vModelText, $data.banReason]
                ]),
                _hoisted_40$1
              ]),
              createBaseVNode("div", _hoisted_41$1, [
                _hoisted_42$1,
                withDirectives(createBaseVNode("input", {
                  type: "number",
                  min: "1",
                  max: "96",
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.banDuration = $event),
                  class: "input"
                }, null, 512), [
                  [vModelText, $data.banDuration]
                ])
              ]),
              createBaseVNode("div", _hoisted_43$1, [
                _hoisted_44$1,
                createBaseVNode("a", {
                  href: "#",
                  onClick: _cache[14] || (_cache[14] = withModifiers(($event) => $data.banModalVisible = false, ["prevent"])),
                  class: "button ml-2"
                }, " Cancel ")
              ])
            ])
          ])
        ], 32)
      ])
    ], 2)
  ], 64);
}
const ProfileModal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
class ChatClient {
  /**
   * Constructor for the client.
   *
   * @param usePolling: instead of WebSocket use the ajax polling API.
   * @param onClientError: function to receive 'ChatClient' messages to
   *                       add to the chat room (this.ChatClient())
   */
  constructor({
    usePolling = false,
    onClientError,
    username,
    jwt,
    // JWT token for authorization
    prefs,
    // User preferences for 'me' action (close DMs, etc)
    // Chat Protocol handler functions for the caller.
    onWho,
    onMe,
    onMessage,
    onTakeback,
    onReact,
    onPresence,
    onRing,
    onOpen,
    onCandidate,
    onSDP,
    onWatch,
    onUnwatch,
    onBlock,
    onCut,
    // Misc function registrations for callback.
    onLoggedIn,
    // connection is fully established (first 'me' echo from server).
    onNewJWT,
    // new JWT token from ping response
    bulkMuteUsers,
    // Upload our blocklist on connect.
    focusMessageBox,
    // Tell caller to focus the message entry box.
    pushHistory
  }) {
    this.usePolling = usePolling;
    this.ChatClient = onClientError;
    this.username = username;
    this.jwt = jwt;
    this.prefs = prefs;
    this.onWho = onWho;
    this.onMe = onMe;
    this.onMessage = onMessage;
    this.onTakeback = onTakeback;
    this.onReact = onReact;
    this.onPresence = onPresence;
    this.onRing = onRing;
    this.onOpen = onOpen;
    this.onCandidate = onCandidate;
    this.onSDP = onSDP;
    this.onWatch = onWatch;
    this.onUnwatch = onUnwatch;
    this.onBlock = onBlock;
    this.onCut = onCut;
    this.onLoggedIn = onLoggedIn;
    this.onNewJWT = onNewJWT;
    this.bulkMuteUsers = bulkMuteUsers;
    this.focusMessageBox = focusMessageBox;
    this.pushHistory = pushHistory;
    this.firstMe = false;
    this.ws = {
      conn: null,
      connected: false,
      // Disconnect spamming: don't retry too many times.
      reconnect: true,
      // unless told to go away
      disconnectLimit: 2,
      disconnectCount: 0
    };
    this.polling = {
      username: "",
      sessionID: "",
      timeout: null
      // setTimeout for next poll.
    };
  }
  // Connected polls if the client is connected.
  connected() {
    if (this.usePolling) {
      return this.polling.timeout != null && this.polling.sessionID != "";
    }
    return this.ws.connected;
  }
  // Disconnect from the server.
  disconnect() {
    if (this.usePolling) {
      this.polling.sessionID = "";
      this.polling.username = "";
      this.stopPolling();
      this.ChatClient("You have disconnected from the server.");
      return;
    }
    this.ws.connected = false;
    this.ws.conn.close(1e3, "server asked to close the connection");
  }
  // Common function to send a message to the server. The message
  // is a JSON object before stringify.
  send(message) {
    if (this.usePolling) {
      fetch("/poll", {
        method: "POST",
        mode: "same-origin",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          username: this.polling.username,
          session_id: this.polling.sessionID,
          msg: message
        })
      }).then((resp) => resp.json()).then((resp) => {
        console.log(resp);
        this.polling.sessionID = resp.session_id;
        this.polling.username = resp.username;
        for (let msg of resp.messages) {
          this.handle(msg);
        }
      }).catch((err) => {
        this.ChatClient("Error from polling API: " + err);
      });
      return;
    }
    if (!this.ws.connected) {
      this.ChatClient("Couldn't send WebSocket message: not connected.");
      return;
    }
    if (typeof message !== "string") {
      message = JSON.stringify(message);
    }
    this.ws.conn.send(message);
  }
  // Common function to handle a message from the server.
  handle(msg) {
    switch (msg.action) {
      case "who":
        this.onWho(msg);
        break;
      case "me":
        this.onMe(msg);
        if (!this.firstMe) {
          this.firstMe = true;
          this.onLoggedIn();
        }
        break;
      case "message":
        this.onMessage(msg);
        break;
      case "takeback":
        this.onTakeback(msg);
        break;
      case "react":
        this.onReact(msg);
        break;
      case "presence":
        this.onPresence(msg);
        break;
      case "ring":
        this.onRing(msg);
        break;
      case "open":
        this.onOpen(msg);
        break;
      case "candidate":
        this.onCandidate(msg);
        break;
      case "sdp":
        this.onSDP(msg);
        break;
      case "watch":
        this.onWatch(msg);
        break;
      case "unwatch":
        this.onUnwatch(msg);
        break;
      case "block":
        this.onBlock(msg);
        break;
      case "cut":
        this.onCut(msg);
        break;
      case "error":
        this.pushHistory({
          channel: msg.channel,
          username: msg.username || "Internal Server Error",
          message: msg.message,
          isChatServer: true
        });
        break;
      case "disconnect":
        this.onWho({ whoList: [] });
        this.ws.reconnect = false;
        this.disconnect();
        break;
      case "ping":
        if (msg.jwt) {
          this.onNewJWT(msg.jwt);
        }
        this.ws.disconnectCount = 0;
        break;
      default:
        console.error("Unexpected action: %s", JSON.stringify(msg));
    }
  }
  // Dial the WebSocket.
  dial() {
    if (this.usePolling) {
      this.ChatClient("Connecting to the server via polling API...");
      this.startPolling();
      this.send({
        action: "login",
        username: this.username,
        jwt: this.jwt.token,
        dnd: this.prefs.closeDMs
      });
      return;
    }
    this.ChatClient("Establishing connection to server...");
    const proto = location.protocol === "https:" ? "wss" : "ws";
    const conn = new WebSocket(`${proto}://${location.host}/ws`);
    conn.addEventListener("close", (ev) => {
      this.onWho({ whoList: [] });
      this.ws.connected = false;
      this.ChatClient(`WebSocket Disconnected code: ${ev.code}, reason: ${ev.reason}`);
      this.ws.disconnectCount++;
      if (this.ws.disconnectCount > this.ws.disconnectLimit) {
        this.ChatClient(
          `It seems there's a problem connecting to the server. Please try some other time.<br><br>If you experience this problem frequently, try going into the Chat Settings 'Misc' tab and switch to the 'Polling' Server Connection method.`
        );
        return;
      }
      if (this.ws.reconnect) {
        if (ev.code !== 1001 && ev.code !== 1e3) {
          this.ChatClient("Reconnecting in 5s");
          setTimeout(() => {
            this.dial();
          }, 5e3);
        }
      }
    });
    conn.addEventListener("open", () => {
      this.ws.connected = true;
      this.ChatClient("Websocket connected!");
      this.bulkMuteUsers();
      this.send({
        action: "login",
        username: this.username,
        jwt: this.jwt.token,
        dnd: this.prefs.closeDMs
      });
      window.requestAnimationFrame(() => {
        this.focusMessageBox();
      });
    });
    conn.addEventListener("message", (ev) => {
      if (typeof ev.data !== "string") {
        console.error("unexpected message type", typeof ev.data);
        return;
      }
      let msg = JSON.parse(ev.data);
      this.handle(msg);
    });
    this.ws.conn = conn;
  }
  // Start the polling interval.
  startPolling() {
    if (!this.usePolling)
      return;
    this.stopPolling();
    this.polling.timeout = setTimeout(() => {
      this.poll();
      this.startPolling();
    }, 5e3);
  }
  // Poll the API.
  poll() {
    if (!this.usePolling) {
      this.stopPolling();
      return;
    }
    this.send({
      action: "ping"
    });
    this.startPolling();
  }
  // Stop polling.
  stopPolling() {
    if (this.polling.timeout != null) {
      clearTimeout(this.polling.timeout);
    }
  }
}
const StatusOptions = [
  {
    category: "Status",
    options: [
      {
        name: "online",
        label: "Active",
        emoji: "☀️",
        icon: "fa fa-clock"
      },
      {
        name: "away",
        label: "Away",
        emoji: "🕒",
        icon: "fa fa-clock"
      },
      {
        name: "brb",
        label: "Be right back",
        emoji: "⏰",
        icon: "fa fa-stopwatch-20"
      },
      {
        name: "afk",
        label: "Away from keyboard",
        emoji: "⌨️",
        icon: "fa fa-keyboard who-status-wide-icon-1"
      },
      {
        name: "lunch",
        label: "Out to lunch",
        emoji: "🍴",
        icon: "fa fa-utensils"
      },
      {
        name: "call",
        label: "On the phone",
        emoji: "📞",
        icon: "fa fa-phone-volume"
      },
      {
        name: "busy",
        label: "Working",
        emoji: "💼",
        icon: "fa fa-briefcase"
      },
      {
        name: "book",
        label: "Studying",
        emoji: "📖",
        icon: "fa fa-book"
      },
      {
        name: "gaming",
        label: "Gaming",
        emoji: "🎮",
        icon: "fa fa-gamepad who-status-wide-icon-2"
      },
      {
        name: "movie",
        label: "Watching a movie",
        emoji: "🎞️",
        icon: "fa fa-film"
      },
      {
        name: "workout",
        label: "Working out",
        emoji: "🏋️",
        icon: "fa-solid fa-dumbbell who-status-wide-icon-2"
      },
      {
        name: "travel",
        label: "Traveling",
        emoji: "✈️",
        icon: "fa fa-plane"
      },
      // Hidden/special statuses
      {
        name: "idle",
        label: "Idle",
        emoji: "🕒",
        icon: "fa-regular fa-moon",
        hidden: true
      },
      {
        name: "hidden",
        label: "Hidden",
        emoji: "🕵️",
        icon: "",
        adminOnly: true
      }
    ]
  },
  {
    category: "Mood",
    options: [
      {
        name: "chatty",
        label: "Chatty and sociable",
        emoji: "🗨️",
        icon: "fa fa-comment"
      },
      {
        name: "introverted",
        label: "Introverted and quiet",
        emoji: "🥄",
        icon: "fa fa-spoon"
      },
      // If NSFW enabled
      {
        name: "horny",
        label: "Horny",
        emoji: "🔥",
        icon: "fa fa-fire",
        nsfw: true
      },
      {
        name: "exhibitionist",
        label: "Watch me",
        emoji: "👀",
        icon: "fa-regular fa-eye who-status-wide-icon-1",
        nsfw: true
      }
    ]
  }
];
const StatusFlattened = function() {
  let result = [];
  for (let category of StatusOptions) {
    for (let option of category.options) {
      result.push(option);
    }
  }
  return result;
}();
const StatusByName = function() {
  let result = {};
  for (let item of StatusFlattened) {
    result[item.name] = item;
  }
  return result;
}();
class StatusMessageController {
  // The caller configures:
  // - nsfw (bool): the BareRTC PermitNSFW setting, which controls some status options.
  // - isAdmin (func): return a boolean if the current user is operator.
  // - currentStatus (func): return the name of the user's current status.
  constructor() {
    this.nsfw = false;
    this.isAdmin = function() {
      return false;
    };
    this.currentStatus = function() {
      return StatusFlattened[0];
    };
  }
  // Iterate the category <optgroup> for the Status dropdown menu.
  iterSelectOptGroups() {
    return StatusOptions;
  }
  // Iterate the <option> for a category of statuses.
  iterSelectOptions(category) {
    let current = this.currentStatus(), isAdmin = this.isAdmin();
    for (let group of StatusOptions) {
      if (group.category === category) {
        let result = group.options.filter((option) => {
          if (option.hidden && current !== option.name || option.adminOnly && !isAdmin || option.nsfw && !this.nsfw) {
            return false;
          }
          return true;
        });
        return result;
      }
    }
    return [];
  }
  // Get details on a status message.
  getStatus(name) {
    if (StatusByName[name] != void 0) {
      return StatusByName[name];
    }
    return {
      name,
      label: name,
      icon: "fa fa-clock",
      emoji: "🕒"
    };
  }
  // Offline status.
  offline() {
    return {
      name: "offline",
      label: "Offline",
      icon: "fa fa-house-circle-xmark",
      emoji: "🌜"
    };
  }
}
const StatusMessage = new StatusMessageController();
const SoundEffects = [
  {
    name: "Quiet",
    filename: null
  },
  {
    name: "Trill",
    filename: "beep-6-96243.mp3"
  },
  {
    name: "Beep",
    filename: "beep-sound-8333.mp3"
  },
  {
    name: "Bird",
    filename: "bird-3-f-89236.mp3"
  },
  {
    name: "Ping",
    filename: "ping-82822.mp3"
  },
  {
    name: "Sonar",
    filename: "sonar-ping-95840.mp3"
  },
  {
    name: "Up Chime",
    filename: "notification-6175-up.mp3"
  },
  {
    name: "Down Chime",
    filename: "notification-6175-down.mp3"
  }
];
var DefaultSounds = {
  Chat: "Quiet",
  DM: "Trill",
  Enter: "Quiet",
  Leave: "Quiet",
  Watch: "Quiet",
  Unwatch: "Quiet",
  Mentioned: "Ping"
};
class BitBuffer {
  constructor(bitCapacity) {
    this.bitCapacity = bitCapacity;
    const byteLength = this.bitCapacity + 7 >> 3;
    this.buffer = new Uint8Array(byteLength);
    this.bitOffset = 0;
  }
  append(value, bitCount) {
    for (let i2 = 0; i2 < bitCount; i2++) {
      const writeByte = this.buffer[this.bitOffset >> 3];
      const writeBit = 7 - (this.bitOffset & 7);
      const writeMask = 1 << writeBit;
      const readMask = 1 << bitCount - 1 - i2;
      this.buffer[this.bitOffset >> 3] = writeByte & ~writeMask | (value & readMask ? writeMask : 0);
      this.bitOffset++;
    }
  }
  position() {
    return this.bitOffset;
  }
  read(bitPosition) {
    const value = this.buffer[bitPosition >> 3] & 1 << 7 - (bitPosition & 7) ? 1 : 0;
    return value;
  }
}
const _SegmentNumeric = class _SegmentNumeric {
  static canEncode(text) {
    return [...text].every((c2) => _SegmentNumeric.CHARSET.includes(c2));
  }
  static payloadSize(text) {
    const charCount = text.length;
    return 10 * Math.floor(charCount / 3) + charCount % 3 * 4 - Math.floor(charCount % 3 / 2);
  }
  static countSize(version2) {
    return version2 < 10 ? 10 : version2 < 27 ? 12 : 14;
  }
  static totalSize(version2, text) {
    return Segment.MODE_BITS + _SegmentNumeric.countSize(version2) + _SegmentNumeric.payloadSize(text);
  }
  static encode(bitBuffer, version2, text) {
    const data = [...text].map((c2) => c2.charCodeAt(0) - 48);
    bitBuffer.append(_SegmentNumeric.MODE, Segment.MODE_BITS);
    bitBuffer.append(data.length, _SegmentNumeric.countSize(version2));
    for (let i2 = 0; i2 < data.length; ) {
      data.length - i2 > 3 ? 3 : data.length - i2;
      let value = data[i2];
      let bits = 4;
      i2++;
      if (i2 < data.length) {
        value = value * 10 + data[i2];
        bits += 3;
        i2++;
      }
      if (i2 < data.length) {
        value = value * 10 + data[i2];
        bits += 3;
        i2++;
      }
      bitBuffer.append(value, bits);
    }
  }
};
__publicField(_SegmentNumeric, "MODE", 1);
__publicField(_SegmentNumeric, "CHARSET", "0123456789");
let SegmentNumeric = _SegmentNumeric;
const _SegmentAlphanumeric = class _SegmentAlphanumeric {
  static canEncode(text) {
    return [...text].every((c2) => _SegmentAlphanumeric.CHARSET.includes(c2));
  }
  static payloadSize(text) {
    const charCount = text.length;
    return 11 * Math.floor(charCount / 2) + 6 * (charCount % 2);
  }
  static countSize(version2) {
    return version2 < 10 ? 9 : version2 < 27 ? 11 : 13;
  }
  static totalSize(version2, text) {
    return Segment.MODE_BITS + _SegmentAlphanumeric.countSize(version2) + _SegmentAlphanumeric.payloadSize(text);
  }
  static encode(bitBuffer, version2, text) {
    const data = [...text].map((c2) => _SegmentAlphanumeric.CHARSET.indexOf(c2));
    bitBuffer.append(_SegmentAlphanumeric.MODE, Segment.MODE_BITS);
    bitBuffer.append(data.length, _SegmentAlphanumeric.countSize(version2));
    for (let i2 = 0; i2 < data.length; ) {
      let value = data[i2];
      let bits = 6;
      i2++;
      if (i2 < data.length) {
        value = value * 45 + data[i2];
        bits += 5;
        i2++;
      }
      bitBuffer.append(value, bits);
    }
  }
};
__publicField(_SegmentAlphanumeric, "MODE", 2);
__publicField(_SegmentAlphanumeric, "CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
let SegmentAlphanumeric = _SegmentAlphanumeric;
const _SegmentEightBit = class _SegmentEightBit {
  static canEncode(text) {
    return [...text].every((c2) => c2.charCodeAt(0) >= 0 && c2.charCodeAt(0) <= 255);
  }
  static payloadSize(text) {
    const charCount = text.length;
    return 8 * charCount;
  }
  static countSize(version2) {
    return version2 < 10 ? 8 : version2 < 27 ? 16 : 16;
  }
  static totalSize(version2, text) {
    return Segment.MODE_BITS + _SegmentEightBit.countSize(version2) + _SegmentEightBit.payloadSize(text);
  }
  static encode(bitBuffer, version2, text) {
    const data = [...text].map((c2) => c2.charCodeAt(0));
    bitBuffer.append(_SegmentEightBit.MODE, Segment.MODE_BITS);
    bitBuffer.append(data.length, _SegmentEightBit.countSize(version2));
    for (let i2 = 0; i2 < data.length; i2++) {
      bitBuffer.append(data[i2], 8);
    }
  }
};
__publicField(_SegmentEightBit, "MODE", 4);
let SegmentEightBit = _SegmentEightBit;
const _Segment = class _Segment {
  // 0b0000
  // ECI Assignment Numbers
  //static ECI_UTF8 = 26; // "\000026" UTF8 - ISO/IEC 10646 UTF-8 encoding
  constructor(text) {
    this.text = text;
    for (let mode of Object.values(_Segment.MODES)) {
      if (mode.canEncode(this.text)) {
        this.mode = mode;
        return;
      }
    }
    throw "Cannot encode text";
  }
};
// In descending order of coding efficiency
__publicField(_Segment, "MODES", {
  numeric: SegmentNumeric,
  alphanumeric: SegmentAlphanumeric,
  eightBit: SegmentEightBit
});
__publicField(_Segment, "MODE_BITS", 4);
// 4-bits to indicate mode
__publicField(_Segment, "MODE_INDICATOR_TERMINATOR", 0);
let Segment = _Segment;
class ReedSolomon {
  // Product modulo GF(2^8/0x011D)
  static Multiply(a2, b2) {
    let value = 0;
    for (let i2 = 7; i2 >= 0; i2--) {
      value = (value << 1 ^ (value >> 7) * 285) & 255;
      value ^= (b2 >> i2 & 1) * a2;
    }
    return value;
  }
  // Reed-Solomon ECC generator polynomial for given degree
  static Divisor(degree) {
    const result = new Uint8Array(degree);
    result.fill(0);
    result[degree - 1] = 1;
    let root = 1;
    for (let i2 = 0; i2 < degree; i2++) {
      for (let j = 0; j < degree; j++) {
        result[j] = ReedSolomon.Multiply(result[j], root);
        if (j + 1 < degree) {
          result[j] ^= result[j + 1];
        }
      }
      root = ReedSolomon.Multiply(root, 2) & 255;
    }
    return result;
  }
  // Reed-Solomon ECC
  static Remainder(data, dataOffset, dataLen, generator, degree, result, resultOffset) {
    result.fill(0, resultOffset, resultOffset + degree);
    for (let i2 = 0; i2 < dataLen; i2++) {
      let factor = data[dataOffset + i2] ^ result[resultOffset + 0];
      result.copyWithin(resultOffset, resultOffset + 1, resultOffset + 1 + degree - 1);
      result[resultOffset + degree - 1] = 0;
      for (let j = 0; j < degree; j++) {
        result[resultOffset + j] ^= ReedSolomon.Multiply(generator[j], factor);
      }
    }
  }
}
const _Matrix = class _Matrix {
  static calculateDimension(version2) {
    return 17 + 4 * version2;
  }
  static calculateMask(maskPattern, j, i2) {
    switch (maskPattern) {
      case 0:
        return (i2 + j & 1) == 0;
      case 1:
        return (i2 & 1) == 0;
      case 2:
        return j % 3 == 0;
      case 3:
        return (i2 + j) % 3 == 0;
      case 4:
        return ((i2 >> 1) + (j / 3 | 0) & 1) == 0;
      case 5:
        return (i2 * j & 1) + i2 * j % 3 == 0;
      case 6:
        return ((i2 * j & 1) + i2 * j % 3 & 1) == 0;
      case 7:
        return (i2 * j % 3 + (i2 + j & 1) & 1) == 0;
      default:
        return false;
    }
  }
  // Returns coordinates to be used in all combinations (unless overlapping finder pattern) as x/y pairs for alignment, <0: end
  static alignmentCoordinates(version2) {
    const count = version2 <= 1 ? 0 : Math.floor(version2 / 7) + 2;
    const coords = Array(count);
    const step = version2 == 32 ? 26 : Math.floor((version2 * 4 + count * 2 + 1) / (count * 2 - 2)) * 2;
    let location2 = version2 * 4 + 10;
    for (let i2 = count - 1; i2 > 0; i2--) {
      coords[i2] = location2;
      location2 -= step;
    }
    if (count > 0)
      coords[0] = 6;
    return coords;
  }
  constructor(version2) {
    this.version = version2;
    this.dimension = _Matrix.calculateDimension(this.version);
    const capacity = this.dimension * this.dimension;
    this.buffer = new Array(capacity);
    this.identity = new Array(capacity);
    this.quiet = _Matrix.QUIET_STANDARD;
    this.invert = false;
    this.text = null;
  }
  setModule(x2, y2, value, identity) {
    if (x2 < 0 || y2 < 0 || x2 >= this.dimension || y2 >= this.dimension)
      return;
    const index = y2 * this.dimension + x2;
    this.buffer[index] = value;
    if (typeof identity !== "undefined")
      this.identity[index] = identity;
  }
  getModule(x2, y2) {
    if (x2 < 0 || y2 < 0 || x2 >= this.dimension || y2 >= this.dimension)
      return null;
    const index = y2 * this.dimension + x2;
    return this.buffer[index];
  }
  identifyModule(x2, y2) {
    if (x2 < 0 || y2 < 0 || x2 >= this.dimension || y2 >= this.dimension)
      return void 0;
    const index = y2 * this.dimension + x2;
    return this.identity[index];
  }
  // Draw finder and separator
  drawFinder(ox, oy) {
    for (let y2 = -Math.floor(_Matrix.FINDER_SIZE / 2) - 1; y2 <= Math.floor(_Matrix.FINDER_SIZE / 2) + 1; y2++) {
      for (let x2 = -Math.floor(_Matrix.FINDER_SIZE / 2) - 1; x2 <= Math.floor(_Matrix.FINDER_SIZE / 2) + 1; x2++) {
        let value = (Math.abs(x2) > Math.abs(y2) ? Math.abs(x2) : Math.abs(y2)) & 1 ? _Matrix.MODULE_DARK : _Matrix.MODULE_LIGHT;
        if (x2 == 0 && y2 == 0)
          value = _Matrix.MODULE_DARK;
        const id = x2 == 0 && y2 == 0 ? "FI" : "Fi";
        this.setModule(ox + x2, oy + y2, value, id);
      }
    }
  }
  drawTiming() {
    const id = "Ti";
    for (let i2 = _Matrix.FINDER_SIZE + 1; i2 < this.dimension - _Matrix.FINDER_SIZE - 1; i2++) {
      let value = ~i2 & 1 ? _Matrix.MODULE_DARK : _Matrix.MODULE_LIGHT;
      this.setModule(i2, _Matrix.TIMING_OFFSET, value, id);
      this.setModule(_Matrix.TIMING_OFFSET, i2, value, id);
    }
  }
  drawAlignment(ox, oy) {
    for (let y2 = -_Matrix.ALIGNMENT_RADIUS; y2 <= _Matrix.ALIGNMENT_RADIUS; y2++) {
      for (let x2 = -_Matrix.ALIGNMENT_RADIUS; x2 <= _Matrix.ALIGNMENT_RADIUS; x2++) {
        let value = 1 - ((Math.abs(x2) > Math.abs(y2) ? Math.abs(x2) : Math.abs(y2)) & 1) ? _Matrix.MODULE_DARK : _Matrix.MODULE_LIGHT;
        const id = x2 == 0 && y2 == 0 ? "AL" : "Al";
        this.setModule(ox + x2, oy + y2, value, id);
      }
    }
  }
  // Populate the matrix with function patterns: finder, separators, timing, alignment, temporary version & format info
  populateFunctionPatterns() {
    this.drawFinder(Math.floor(_Matrix.FINDER_SIZE / 2), Math.floor(_Matrix.FINDER_SIZE / 2));
    this.drawFinder(this.dimension - 1 - Math.floor(_Matrix.FINDER_SIZE / 2), Math.floor(_Matrix.FINDER_SIZE / 2));
    this.drawFinder(Math.floor(_Matrix.FINDER_SIZE / 2), this.dimension - 1 - Math.floor(_Matrix.FINDER_SIZE / 2));
    this.drawTiming();
    const alignmentCoords = _Matrix.alignmentCoordinates(this.version);
    for (let h2 of alignmentCoords) {
      for (let v2 of alignmentCoords) {
        if (h2 <= _Matrix.FINDER_SIZE && v2 <= _Matrix.FINDER_SIZE)
          continue;
        if (h2 >= this.dimension - 1 - _Matrix.FINDER_SIZE && v2 <= _Matrix.FINDER_SIZE)
          continue;
        if (h2 <= _Matrix.FINDER_SIZE && v2 >= this.dimension - 1 - _Matrix.FINDER_SIZE)
          continue;
        this.drawAlignment(h2, v2);
      }
    }
    this.drawFormatInfo(0);
    this.drawVersionInfo(0);
  }
  // Set the data drawing cursor to the start position (lower-right corner)
  cursorReset() {
    this.cursorX = this.dimension - 1;
    this.cursorY = this.dimension - 1;
  }
  // Advance the data drawing cursor to next position
  cursorAdvance() {
    while (this.cursorX >= 0) {
      if (this.cursorX & 1 ^ (this.cursorX > _Matrix.TIMING_OFFSET ? 1 : 0)) {
        this.cursorX--;
      } else {
        this.cursorX++;
        if ((this.cursorX - (this.cursorX > _Matrix.TIMING_OFFSET ? 1 : 0)) / 2 & 1) {
          if (this.cursorY <= 0)
            this.cursorX -= 2;
          else
            this.cursorY--;
        } else {
          if (this.cursorY >= this.dimension - 1)
            this.cursorX -= 2;
          else
            this.cursorY++;
        }
      }
      if (!this.identifyModule(this.cursorX, this.cursorY))
        return true;
    }
    return false;
  }
  cursorWrite(buffer2, sourceBit, countBits) {
    let index = sourceBit;
    for (let countWritten = 0; countWritten < countBits; countWritten++) {
      let bit = buffer2.read(index);
      this.setModule(this.cursorX, this.cursorY, bit);
      index++;
      if (!this.cursorAdvance())
        break;
    }
    return index - sourceBit;
  }
  // Draw 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)
  drawFormatInfo(value) {
    const id = "Fo";
    for (let i2 = 0; i2 < 15; i2++) {
      const v2 = value >> i2 & 1;
      if (i2 < 6)
        this.setModule(_Matrix.FINDER_SIZE + 1, i2, v2, id);
      else if (i2 == 6)
        this.setModule(_Matrix.FINDER_SIZE + 1, _Matrix.FINDER_SIZE, v2, id);
      else if (i2 == 7)
        this.setModule(_Matrix.FINDER_SIZE + 1, _Matrix.FINDER_SIZE + 1, v2, id);
      else if (i2 == 8)
        this.setModule(_Matrix.FINDER_SIZE, _Matrix.FINDER_SIZE + 1, v2, id);
      else
        this.setModule(14 - i2, _Matrix.FINDER_SIZE + 1, v2, id);
      if (i2 < 8)
        this.setModule(this.dimension - 1 - i2, _Matrix.FINDER_SIZE + 1, v2, id);
      else
        this.setModule(_Matrix.FINDER_SIZE + 1, this.dimension - _Matrix.FINDER_SIZE - 8 + i2, v2, id);
    }
    this.setModule(_Matrix.FINDER_SIZE + 1, this.dimension - 1 - _Matrix.FINDER_SIZE, _Matrix.MODULE_DARK, id);
  }
  // Draw 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)
  drawVersionInfo(value) {
    const id = "Ve";
    if (value === null || this.version < 7)
      return;
    for (let i2 = 0; i2 < 18; i2++) {
      const v2 = value >> i2 & 1;
      const col = Math.floor(i2 / _Matrix.VERSION_SIZE);
      const row = i2 % _Matrix.VERSION_SIZE;
      this.setModule(col, this.dimension - 1 - _Matrix.FINDER_SIZE - _Matrix.VERSION_SIZE + row, v2, id);
      this.setModule(this.dimension - 1 - _Matrix.FINDER_SIZE - _Matrix.VERSION_SIZE + row, col, v2, id);
    }
  }
  applyMaskPattern(maskPattern) {
    for (let y2 = 0; y2 < this.dimension; y2++) {
      for (let x2 = 0; x2 < this.dimension; x2++) {
        const part = this.identifyModule(x2, y2);
        if (!part) {
          const mask = _Matrix.calculateMask(maskPattern, x2, y2);
          if (mask) {
            const module = this.getModule(x2, y2);
            const value = 1 ^ module;
            this.setModule(x2, y2, value);
          }
        }
      }
    }
  }
  evaluatePenalty() {
    const scoreN1 = 3;
    const scoreN2 = 3;
    const scoreN3 = 40;
    const scoreN4 = 10;
    let totalPenalty = 0;
    for (let swapAxis = 0; swapAxis <= 1; swapAxis++) {
      let runs = Array(5);
      let runsCount = 0;
      for (let y2 = 0; y2 < this.dimension; y2++) {
        let lastBit = -1;
        let runLength = 0;
        for (let x2 = 0; x2 < this.dimension; x2++) {
          let bit = this.getModule(swapAxis ? y2 : x2, swapAxis ? x2 : y2);
          if (bit == lastBit)
            runLength++;
          if (bit != lastBit || x2 >= this.dimension - 1) {
            if (lastBit >= 0) {
              if (runLength >= 5) {
                totalPenalty += scoreN1 + (runLength - 5);
              }
              runsCount++;
              runs[runsCount % 5] = runLength;
              if (runsCount >= 5) {
                let v2 = runs[(runsCount + 1) % 5];
                if (runs[runsCount % 5] == 3 * v2 && v2 == runs[(runsCount + 2) % 5] && v2 == runs[(runsCount + 3) % 5] && v2 == runs[(runsCount + 4) % 5]) {
                  totalPenalty += scoreN3;
                }
              }
            }
            runLength = 1;
            lastBit = bit;
          }
        }
      }
    }
    for (let y2 = 0; y2 < this.dimension - 1; y2++) {
      for (let x2 = 0; x2 < this.dimension - 1; x2++) {
        let bits = this.getModule(x2, y2);
        bits += this.getModule(x2 + 1, y2);
        bits += this.getModule(x2, y2 + 1);
        bits += this.getModule(x2 + 1, y2 + 1);
        if (bits == 0 || bits == 4)
          totalPenalty += scoreN2;
      }
    }
    {
      let darkCount = 0;
      for (let y2 = 0; y2 < this.dimension; y2++) {
        for (let x2 = 0; x2 < this.dimension; x2++) {
          let bit = this.getModule(x2, y2);
          if (bit == _Matrix.MODULE_DARK)
            darkCount++;
        }
      }
      let percentage = (100 * darkCount + this.dimension * this.dimension / 2) / (this.dimension * this.dimension);
      let deviation = Math.abs(percentage - 50);
      let rating = Math.floor(deviation / 5);
      let penalty = scoreN4 * rating;
      totalPenalty += penalty;
    }
    return totalPenalty;
  }
};
__publicField(_Matrix, "MODULE_LIGHT", 0);
__publicField(_Matrix, "MODULE_DARK", 1);
__publicField(_Matrix, "FINDER_SIZE", 7);
__publicField(_Matrix, "TIMING_OFFSET", 6);
__publicField(_Matrix, "VERSION_SIZE", 3);
__publicField(_Matrix, "ALIGNMENT_RADIUS", 2);
__publicField(_Matrix, "QUIET_NONE", 0);
__publicField(_Matrix, "QUIET_STANDARD", 4);
let Matrix = _Matrix;
const _QrCode = class _QrCode {
  // Pad codewords 0b11101100=0xec 0b00010001=0x11
  // Calculate the (square) dimension for a version. V1=21x21; V40=177x177.
  static dimension(version2) {
    return 17 + 4 * version2;
  }
  // Calculate the total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.
  static totalDataModules(version2) {
    return (16 * version2 + 128) * version2 + 64 - (version2 < 2 ? 0 : (25 * (Math.floor(version2 / 7) + 2) - 10) * (Math.floor(version2 / 7) + 2) - 55) - (version2 < 7 ? 0 : 36);
  }
  // Calculate the total number of data bits available in the codewords (cooked: after ecc and remainder)
  static dataCapacity(version2, errorCorrectionLevel) {
    const capacityCodewords = Math.floor(_QrCode.totalDataModules(version2) / 8);
    const eccTotalCodewords = _QrCode.eccBlockCodewords(version2, errorCorrectionLevel) * _QrCode.eccBlockCount(version2, errorCorrectionLevel);
    const dataCapacityCodewords = capacityCodewords - eccTotalCodewords;
    return dataCapacityCodewords * 8;
  }
  // Number of error correction blocks
  static eccBlockCount(version2, errorCorrectionLevel) {
    const eccBlockCountLookup = [
      [0, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
      // 0b00 Medium
      [0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
      // 0b01 Low
      [0, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],
      // 0b10 High
      [0, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68]
      // 0b11 Quartile
    ];
    return eccBlockCountLookup[errorCorrectionLevel][version2];
  }
  // Number of error correction codewords in each block
  static eccBlockCodewords(version2, errorCorrectionLevel) {
    const eccBlockCodewordsLookup = [
      [0, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
      // 0b00 Medium
      [0, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
      // 0b01 Low
      [0, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
      // 0b10 High
      [0, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
      // 0b11 Quartile
    ];
    return eccBlockCodewordsLookup[errorCorrectionLevel][version2];
  }
  // Calculate 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)
  static calculateVersionInfo(version2) {
    if (version2 < 7)
      return null;
    let golay = version2;
    for (let i2 = 0; i2 < 12; i2++)
      golay = golay << 1 ^ (golay >>> 11) * 7973;
    const value = version2 << 12 | golay;
    return value;
  }
  // Calculate 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)
  static calculateFormatInfo(errorCorrectionLevel, maskPattern) {
    const value = (errorCorrectionLevel & 3) << 3 | maskPattern & 7;
    let bch = value;
    for (let i2 = 0; i2 < 10; i2++)
      bch = bch << 1 ^ (bch >>> 9) * 1335;
    let format = value << 10 | bch & 1023;
    const formatMask = 21522;
    format ^= formatMask;
    return format;
  }
  // Total number of data bits used (may later require 0-padding to a byte boundary and padding bytes added)
  static measureSegments(segments, version2) {
    let total = 0;
    for (let segment of segments) {
      total += segment.mode.totalSize(version2, segment.text);
    }
    return total;
  }
  static doSegmentsFit(segments, version2, errorCorrectionLevel) {
    const sizeBits = _QrCode.measureSegments(segments, version2);
    const dataCapacity = _QrCode.dataCapacity(version2, errorCorrectionLevel);
    return sizeBits <= dataCapacity;
  }
  static findMinimumVersion(segments, errorCorrectionLevel, minVersion = _QrCode.VERSION_MIN, maxVersion = _QrCode.VERSION_MAX) {
    for (let version2 = minVersion; version2 <= maxVersion; version2++) {
      if (_QrCode.doSegmentsFit(segments, version2, errorCorrectionLevel)) {
        return version2;
      }
    }
    throw "Cannot fit data in any allowed versions";
  }
  static tryToImproveErrorCorrectionLevel(segments, version2, currentErrorCorrectionLevel) {
    const ranking = Object.values(_QrCode.ErrorCorrectionLevel);
    for (let i2 = 1; i2 < ranking.length; i2++) {
      if (currentErrorCorrectionLevel == ranking[i2 - 1]) {
        if (_QrCode.doSegmentsFit(segments, version2, ranking[i2])) {
          currentErrorCorrectionLevel = ranking[i2];
        }
      }
    }
    return currentErrorCorrectionLevel;
  }
  // Write segments: header/count/payload
  static writeData(scratchBuffer, version2, segments) {
    for (let segment of segments) {
      segment.mode.encode(scratchBuffer, version2, segment.text);
    }
  }
  // Finish segments: given the available space, write terminator, rounding bits, and padding codewords
  static writePadding(scratchBuffer, version2, errorCorrectionLevel) {
    const dataCapacity = _QrCode.dataCapacity(version2, errorCorrectionLevel);
    let remaining;
    remaining = Math.min(dataCapacity - scratchBuffer.position(), Segment.MODE_BITS);
    scratchBuffer.append(Segment.MODE_INDICATOR_TERMINATOR, remaining);
    remaining = Math.min(dataCapacity - scratchBuffer.position(), 8 - (scratchBuffer.position() & 7) & 7);
    scratchBuffer.append(0, remaining);
    while ((remaining = Math.min(dataCapacity - scratchBuffer.position(), 16)) > 0) {
      scratchBuffer.append(_QrCode.PAD_CODEWORDS >> 16 - remaining, remaining);
    }
    console.assert(scratchBuffer.position() === dataCapacity, "Unexpectedly failed to correctly fill the data buffer");
  }
  // Calculate ECC data at the end of the codewords
  // ...and fill the matrix
  // TODO: Split this function into two (but depends on a lot of calculated state)
  static calculateEccAndFillMatrix(scratchBuffer, version2, errorCorrectionLevel, matrix) {
    const eccBlockCount = _QrCode.eccBlockCount(version2, errorCorrectionLevel);
    const eccCodewords = _QrCode.eccBlockCodewords(version2, errorCorrectionLevel);
    const totalCapacity = _QrCode.totalDataModules(version2);
    const eccOffset = Math.floor((totalCapacity - 8 * eccCodewords * eccBlockCount) / 8);
    console.assert(8 * eccOffset === scratchBuffer.bitOffset, `Expected current bit position ${scratchBuffer.bitOffset} to match ECC offset *8 ${8 * eccOffset}`);
    const eccDivisor = ReedSolomon.Divisor(eccCodewords);
    const dataCapacityBytes = eccOffset;
    const dataLenShort = Math.floor(dataCapacityBytes / eccBlockCount);
    const countShortBlocks = eccBlockCount - (dataCapacityBytes - dataLenShort * eccBlockCount);
    const dataLenLong = dataLenShort + (countShortBlocks >= eccBlockCount ? 0 : 1);
    for (let block = 0; block < eccBlockCount; block++) {
      let dataOffset;
      if (block < countShortBlocks) {
        dataOffset = block * dataLenShort;
      } else {
        dataOffset = block * dataLenShort + (block - countShortBlocks);
      }
      let dataLen = dataLenShort + (block < countShortBlocks ? 0 : 1);
      let eccDest = eccOffset + block * eccCodewords;
      ReedSolomon.Remainder(scratchBuffer.buffer, dataOffset, dataLen, eccDivisor, eccCodewords, scratchBuffer.buffer, eccDest);
    }
    matrix.cursorReset();
    let totalWritten = 0;
    for (let i2 = 0; i2 < dataLenLong; i2++) {
      for (let block = 0; block < eccBlockCount; block++) {
        if (i2 >= dataLenShort && block < countShortBlocks)
          continue;
        const codeword = block * dataLenShort + (block > countShortBlocks ? block - countShortBlocks : 0) + i2;
        const sourceBit = codeword * 8;
        const countBits = 8;
        totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);
      }
    }
    for (let i2 = 0; i2 < eccCodewords; i2++) {
      for (let block = 0; block < eccBlockCount; block++) {
        const sourceBit = 8 * eccOffset + block * eccCodewords * 8 + i2 * 8;
        const countBits = 8;
        totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);
      }
    }
    const bit = Matrix.MODULE_LIGHT;
    while (totalWritten < totalCapacity) {
      matrix.setModule(matrix.cursorX, matrix.cursorY, bit);
      totalWritten++;
      if (!matrix.cursorAdvance())
        break;
    }
  }
  //
  static findOptimalMaskPattern(matrix, errorCorrectionLevel) {
    let lowestPenalty = -1;
    let bestMaskPattern = null;
    for (let maskPattern = 0; maskPattern <= 7; maskPattern++) {
      matrix.applyMaskPattern(maskPattern);
      const formatInfo = _QrCode.calculateFormatInfo(errorCorrectionLevel, maskPattern);
      matrix.drawFormatInfo(formatInfo);
      const penalty = matrix.evaluatePenalty();
      matrix.applyMaskPattern(maskPattern);
      if (lowestPenalty < 0 || penalty < lowestPenalty) {
        lowestPenalty = penalty;
        bestMaskPattern = maskPattern;
      }
    }
    return bestMaskPattern;
  }
  constructor() {
  }
  static generate(text, userOptions) {
    const options = Object.assign({
      errorCorrectionLevel: _QrCode.ErrorCorrectionLevel.M,
      minVersion: _QrCode.VERSION_MIN,
      maxVersion: _QrCode.VERSION_MAX,
      optimizeEcc: true,
      maskPattern: null,
      quiet: Matrix.QUIET_STANDARD,
      // only information for the renderer
      invert: false
      // only a flag for the renderer
    }, userOptions);
    const textArray = Array.isArray(text) ? text : [text];
    const segments = textArray.map((text2) => new Segment(text2));
    let errorCorrectionLevel = options.errorCorrectionLevel;
    const version2 = _QrCode.findMinimumVersion(segments, errorCorrectionLevel, options.minVersion, options.maxVersion);
    if (options.optimizeEcc) {
      errorCorrectionLevel = _QrCode.tryToImproveErrorCorrectionLevel(segments, version2, errorCorrectionLevel);
    }
    const totalCapacity = _QrCode.totalDataModules(version2);
    const scratchBuffer = new BitBuffer(totalCapacity);
    _QrCode.writeData(scratchBuffer, version2, segments);
    _QrCode.writePadding(scratchBuffer, version2, errorCorrectionLevel);
    const matrix = new Matrix(version2);
    matrix.text = text;
    matrix.quiet = options.quiet;
    matrix.invert = options.invert;
    matrix.populateFunctionPatterns();
    _QrCode.calculateEccAndFillMatrix(scratchBuffer, version2, errorCorrectionLevel, matrix);
    let maskPattern = options.maskPattern;
    if (maskPattern === null) {
      maskPattern = _QrCode.findOptimalMaskPattern(matrix, errorCorrectionLevel);
    }
    matrix.applyMaskPattern(maskPattern);
    const versionInfo = _QrCode.calculateVersionInfo(version2);
    matrix.drawVersionInfo(versionInfo);
    const formatInfo = _QrCode.calculateFormatInfo(errorCorrectionLevel, maskPattern);
    matrix.drawFormatInfo(formatInfo);
    return matrix;
  }
  static render(mode, matrix, renderOptions) {
    const renderers = {
      "debug": renderDebug,
      "large": renderTextLarge,
      "medium": renderTextMedium,
      "compact": renderTextCompact,
      "svg": renderSvg,
      "svg-uri": renderSvgUri,
      "bmp": renderBmp,
      "bmp-uri": renderBmpUri
    };
    if (!renderers[mode])
      throw new Error("ERROR: Invalid render mode: " + mode);
    return renderers[mode](matrix, renderOptions);
  }
};
__publicField(_QrCode, "VERSION_MIN", 1);
__publicField(_QrCode, "VERSION_MAX", 40);
// In ascending order of robustness
__publicField(_QrCode, "ErrorCorrectionLevel", {
  L: 1,
  // 0b01 Low (~7%)
  M: 0,
  // 0b00 Medium (~15%)
  Q: 3,
  // 0b11 Quartile (~25%)
  H: 2
  // 0b10 High (~30%)
});
__publicField(_QrCode, "ECC_CODEWORDS_MAX", 30);
__publicField(_QrCode, "PAD_CODEWORDS", 60433);
let QrCode = _QrCode;
function BitmapGenerate(data, width, height, alpha = false) {
  const bitsPerPixel = alpha ? 32 : 24;
  const fileHeaderSize = 14;
  const bmpHeaderSizeByVersion = {
    BITMAPCOREHEADER: 12,
    BITMAPINFOHEADER: 40,
    BITMAPV2INFOHEADER: 52,
    BITMAPV3INFOHEADER: 56,
    BITMAPV4HEADER: 108,
    BITMAPV5HEADER: 124
  };
  const version2 = alpha ? "BITMAPV4HEADER" : "BITMAPCOREHEADER";
  if (!bmpHeaderSizeByVersion.hasOwnProperty(version2))
    throw `Unknown BMP header version: ${version2}`;
  const bmpHeaderSize = bmpHeaderSizeByVersion[version2];
  const stride = 4 * Math.floor((width * Math.floor((bitsPerPixel + 7) / 8) + 3) / 4);
  const biSizeImage = stride * Math.abs(height);
  const bfOffBits = fileHeaderSize + bmpHeaderSize;
  const bfSize = bfOffBits + biSizeImage;
  const buffer2 = new ArrayBuffer(bfSize);
  const view = new DataView(buffer2);
  view.setUint8(0, "B".charCodeAt(0));
  view.setUint8(1, "M".charCodeAt(0));
  view.setUint32(2, bfSize, true);
  view.setUint16(6, 0, true);
  view.setUint16(8, 0, true);
  view.setUint32(10, bfOffBits, true);
  if (bmpHeaderSize == bmpHeaderSizeByVersion.BITMAPCOREHEADER) {
    view.setUint32(14, bmpHeaderSize, true);
    view.setUint16(18, width, true);
    view.setInt16(20, height, true);
    view.setUint16(22, 1, true);
    view.setUint16(24, bitsPerPixel, true);
  } else if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPINFOHEADER) {
    view.setUint32(14, bmpHeaderSize, true);
    view.setUint32(18, width, true);
    view.setInt32(22, height, true);
    view.setUint16(26, 1, true);
    view.setUint16(28, bitsPerPixel, true);
    view.setUint32(30, alpha ? 3 : 0, true);
    view.setUint32(34, biSizeImage, true);
    view.setUint32(38, 2835, true);
    view.setUint32(42, 2835, true);
    view.setUint32(46, 0, true);
    view.setUint32(50, 0, true);
  }
  if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV2INFOHEADER) {
    view.setUint32(54, alpha ? 16711680 : 0, true);
    view.setUint32(58, alpha ? 65280 : 0, true);
    view.setUint32(62, alpha ? 255 : 0, true);
  }
  if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV3INFOHEADER) {
    view.setUint32(66, alpha ? 4278190080 : 0, true);
  }
  if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV4HEADER) {
    const colorSpace = "Win ";
    view.setUint8(70, colorSpace.charCodeAt(0));
    view.setUint8(71, colorSpace.charCodeAt(1));
    view.setUint8(72, colorSpace.charCodeAt(2));
    view.setUint8(73, colorSpace.charCodeAt(3));
    view.setUint32(110, 0, true);
    view.setUint32(114, 0, true);
    view.setUint32(118, 0, true);
  }
  if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV5HEADER) {
    view.setUint32(122, 4, true);
    view.setUint32(126, 0, true);
    view.setUint32(130, 0, true);
    view.setUint32(134, 0, true);
  }
  for (let y2 = 0; y2 < height; y2++) {
    let offset2 = bfOffBits + (height - 1 - y2) * stride;
    for (let x2 = 0; x2 < width; x2++) {
      const value = data[y2 * width + x2];
      view.setUint8(offset2 + 0, value[2]);
      view.setUint8(offset2 + 1, value[1]);
      view.setUint8(offset2 + 2, value[0]);
      if (alpha) {
        view.setUint8(offset2 + 3, value[3]);
        offset2 += 4;
      } else {
        offset2 += 3;
      }
    }
  }
  return buffer2;
}
function renderDebug(matrix, options) {
  options = Object.assign({
    segments: ["  ", "██"],
    sep: "\n"
  }, options);
  const lines = [];
  for (let y2 = -matrix.quiet; y2 < matrix.dimension + matrix.quiet; y2++) {
    const parts = [];
    for (let x2 = -matrix.quiet; x2 < matrix.dimension + matrix.quiet; x2++) {
      let part = matrix.identifyModule(x2, y2);
      const bit = matrix.getModule(x2, y2) ? !matrix.invert : matrix.invert;
      const value = bit ? 1 : 0;
      if (typeof part == "undefined" || part === null)
        part = options.segments[value];
      parts.push(part);
    }
    lines.push(parts.join(""));
  }
  return lines.join(options.sep);
}
function renderTextLarge(matrix, options) {
  options = Object.assign({
    segments: ["  ", "██"],
    sep: "\n"
  }, options);
  const lines = [];
  for (let y2 = -matrix.quiet; y2 < matrix.dimension + matrix.quiet; y2++) {
    const parts = [];
    for (let x2 = -matrix.quiet; x2 < matrix.dimension + matrix.quiet; x2++) {
      const bit = matrix.getModule(x2, y2) ? !matrix.invert : matrix.invert;
      const value = bit ? 1 : 0;
      const chars = options.segments.length >= 3 && bit && !matrix.identifyModule(x2, y2) ? options.segments[2] : options.segments[value];
      parts.push(chars);
    }
    lines.push(parts.join(""));
  }
  return lines.join(options.sep);
}
function renderTextMedium(matrix, options) {
  options = Object.assign({
    segments: [" ", "▀", "▄", "█"],
    sep: "\n"
  }, options);
  const lines = [];
  for (let y2 = -matrix.quiet; y2 < matrix.dimension + matrix.quiet; y2 += 2) {
    const parts = [];
    for (let x2 = -matrix.quiet; x2 < matrix.dimension + matrix.quiet; x2++) {
      const upper = matrix.getModule(x2, y2) ? !matrix.invert : matrix.invert;
      const lower = (y2 + 1 < matrix.dimension ? matrix.getModule(x2, y2 + 1) : 0) ? !matrix.invert : matrix.invert;
      const value = (upper ? 1 : 0) | (lower ? 2 : 0);
      const c2 = options.segments[value];
      parts.push(c2);
    }
    lines.push(parts.join(""));
  }
  return lines.join(options.sep);
}
function renderTextCompact(matrix, options) {
  options = Object.assign({
    segments: [" ", "▘", "▝", "▀", "▖", "▌", "▞", "▛", "▗", "▚", "▐", "▜", "▄", "▙", "▟", "█"],
    sep: "\n"
  }, options);
  const lines = [];
  for (let y2 = -matrix.quiet; y2 < matrix.dimension + matrix.quiet; y2 += 2) {
    const parts = [];
    for (let x2 = -matrix.quiet; x2 < matrix.dimension + matrix.quiet; x2 += 2) {
      let value = 0;
      value |= (matrix.getModule(x2, y2) ? !matrix.invert : matrix.invert) ? 1 : 0;
      value |= ((x2 + 1 < matrix.dimension ? matrix.getModule(x2 + 1, y2) : 0) ? !matrix.invert : matrix.invert) ? 2 : 0;
      value |= ((y2 + 1 < matrix.dimension ? matrix.getModule(x2, y2 + 1) : 0) ? !matrix.invert : matrix.invert) ? 4 : 0;
      value |= ((y2 + 1 < matrix.dimension && x2 + 1 < matrix.dimension ? matrix.getModule(x2 + 1, y2 + 1) : 0) ? !matrix.invert : matrix.invert) ? 8 : 0;
      let c2 = options.segments[value];
      parts.push(c2);
    }
    lines.push(parts.join(""));
  }
  return lines.join(options.sep);
}
function escape(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&apos;");
}
function renderSvg(matrix, options) {
  options = Object.assign({
    moduleRound: null,
    finderRound: null,
    alignmentRound: null,
    white: false,
    // Output an element for every module, not just black/dark ones but white/light ones too.
    moduleSize: 1
  }, options);
  const vbTopLeft = `${-matrix.quiet - options.moduleSize / 2}`;
  const vbWidthHeight = `${2 * (matrix.quiet + options.moduleSize / 2) + matrix.dimension - 1}`;
  const lines = [];
  lines.push(`<?xml version="1.0"?>`);
  lines.push(`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="${vbTopLeft} ${vbTopLeft} ${vbWidthHeight} ${vbWidthHeight}" shape-rendering="crispEdges">`);
  lines.push(`<title>${escape(matrix.text)}</title>`);
  lines.push(`<defs>`);
  lines.push(`<rect id="b" x="${-options.moduleSize / 2}" y="${-options.moduleSize / 2}" width="${options.moduleSize}" height="${options.moduleSize}" rx="${0.5 * (options.moduleRound || 0) * options.moduleSize}" />`);
  if (options.white) {
    lines.push(`<path id="w" d="" visibility="hidden" />`);
  }
  if (options.finderRound != null) {
    lines.push(`<path id="f" d="" visibility="hidden" />`);
    if (options.white)
      lines.push(`<path id="fw" d="" visibility="hidden" />`);
    lines.push(`<g id="fc"><rect x="-3" y="-3" width="6" height="6" rx="${3 * options.finderRound}" stroke="currentColor" stroke-width="1" fill="none" /><rect x="-1.5" y="-1.5" width="3" height="3" rx="${1.5 * options.finderRound}" /></g>`);
    lines.push(`<g id="fc"><rect x="-3" y="-3" width="6" height="6" rx="${3 * options.finderRound}" stroke="currentColor" stroke-width="1" fill="none" /><rect x="-1.5" y="-1.5" width="3" height="3" rx="${1.5 * options.finderRound}" /></g>`);
  } else {
    lines.push(`<use id="f" xlink:href="#b" />`);
    if (options.white)
      lines.push(`<use id="fw" xlink:href="#w" />`);
    lines.push(`<path id="fc" d="" visibility="hidden" />`);
  }
  if (options.alignmentRound != null) {
    lines.push(`<path id="a" d="" visibility="hidden" />`);
    if (options.white)
      lines.push(`<path id="aw" d="" visibility="hidden" />`);
    lines.push(`<g id="ac"><rect x="-2" y="-2" width="4" height="4" rx="${2 * options.alignmentRound}" stroke="currentColor" stroke-width="1" fill="none" /><rect x="-0.5" y="-0.5" width="1" height="1" rx="${0.5 * options.alignmentRound}" /></g>`);
  } else {
    lines.push(`<use id="a" xlink:href="#b" />`);
    if (options.white)
      lines.push(`<use id="aw" xlink:href="#w" />`);
    lines.push(`<path id="ac" d="" visibility="hidden" />`);
  }
  lines.push(`</defs>`);
  for (let y2 = 0; y2 < matrix.dimension; y2++) {
    for (let x2 = 0; x2 < matrix.dimension; x2++) {
      const mod = matrix.identifyModule(x2, y2);
      let bit = matrix.getModule(x2, y2);
      if (matrix.invert)
        bit = !bit;
      let type = bit ? "b" : "w";
      if (mod == "Fi" || mod == "FI") {
        type = bit ? "f" : "fw";
      } else if (mod == "Al" || mod == "AL") {
        type = bit ? "a" : "aw";
      }
      if (bit || options.white) {
        lines.push(`<use x="${x2}" y="${y2}" xlink:href="#${type}" />`);
      }
    }
  }
  for (let y2 = 0; y2 < matrix.dimension; y2++) {
    for (let x2 = 0; x2 < matrix.dimension; x2++) {
      const mod = matrix.identifyModule(x2, y2);
      let type = null;
      if (mod == "FI")
        type = "fc";
      else if (mod == "AL")
        type = "ac";
      if (type == null)
        continue;
      lines.push(`<use x="${x2}" y="${y2}" xlink:href="#${type}" />`);
    }
  }
  lines.push(`</svg>`);
  const svgString = lines.join("\n");
  return svgString;
}
function renderSvgUri(matrix, options) {
  return "data:image/svg+xml," + encodeURIComponent(renderSvg(matrix, options));
}
function renderBmp(matrix, options) {
  options = Object.assign({
    scale: 8,
    alpha: false,
    width: null,
    height: null
  }, options);
  const size2 = matrix.dimension + 2 * matrix.quiet;
  if (options.width === null)
    options.width = Math.floor(size2 * options.scale);
  if (options.height === null)
    options.height = options.width;
  const colorData = Array(options.width * options.height).fill(null);
  for (let y2 = 0; y2 < options.height; y2++) {
    const my = Math.floor(y2 * size2 / options.height) - matrix.quiet;
    for (let x2 = 0; x2 < options.width; x2++) {
      const mx = Math.floor(x2 * size2 / options.width) - matrix.quiet;
      let bit = matrix.getModule(mx, my);
      let color;
      if (matrix.invert) {
        color = bit ? [255, 255, 255, 255] : [0, 0, 0, 0];
      } else {
        color = bit ? [0, 0, 0, 255] : [255, 255, 255, 0];
      }
      colorData[y2 * options.width + x2] = color;
    }
  }
  const bmpData = BitmapGenerate(colorData, options.width, options.height, options.alpha);
  return bmpData;
}
function renderBmpUri(matrix, options) {
  const bmpData = renderBmp(matrix, options);
  const encoded = btoa(new Uint8Array(bmpData).reduce((data, v2) => data + String.fromCharCode(v2), ""));
  return "data:image/bmp;base64," + encoded;
}
function WatermarkImage(username) {
  let now = /* @__PURE__ */ new Date();
  let dateString = [
    now.getFullYear(),
    ("0" + (now.getMonth() + 1)).slice(-2),
    ("0" + now.getDate()).slice(-2)
  ].join("-");
  let fields = [
    window.location.hostname,
    username,
    dateString
  ].join(" ");
  console.error("watermark message:", fields);
  const matrix = QrCode.generate(fields);
  const uri = QrCode.render("svg-uri", matrix);
  return uri;
}
const App_vue_vue_type_style_index_0_lang = "";
const configuration = {
  iceServers: TURN.URLs.map((val) => {
    let row = {
      urls: val
    };
    if (val.indexOf("turn:") === 0) {
      row.username = TURN.Username;
      row.credential = TURN.Credential;
    }
    return row;
  })
};
const FileUploadMaxSize = 1024 * 1024 * 8;
const DebugChannelID = "barertc-debug";
const WebcamWidth = 640, WebcamHeight = 480;
const WebcamMaxWidth = 1280, WebcamMaxHeight = 720;
const _sfc_main = {
  name: "BareRTC",
  components: {
    // Third party components
    FloatingVue: xt,
    Mentionable,
    EmojiPicker: Picker,
    // My components
    AlertModal,
    LoginModal,
    ExplicitOpenModal,
    ReportModal,
    MessageBox,
    WhoListRow,
    VideoFeed,
    ProfileModal
  },
  data() {
    return {
      // busy: false, // TODO: not used
      pageTitle: document.title,
      disconnect: false,
      // don't try to reconnect (e.g. kicked)
      windowFocused: true,
      // browser tab is active
      windowFocusedAt: /* @__PURE__ */ new Date(),
      // Disconnect spamming: don't retry too many times.
      disconnectLimit: 2,
      disconnectCount: 0,
      // Temp: spam counting for OF links
      spamWarningCount: 0,
      // Website configuration provided by chat.html template.
      config: {
        branding: Branding,
        strings: BareRTCStrings,
        channels: PublicChannels,
        dmDisclaimer: DMDisclaimer,
        website: WebsiteURL,
        permitNSFW: PermitNSFW,
        webhookURLs: WebhookURLs,
        cacheHash: CacheHash,
        VIP,
        fontSizeClasses: [
          ["x-2", "Very small chat room text"],
          ["x-1", "50% smaller chat room text"],
          ["", "Default size"],
          ["x1", "50% larger chat room text"],
          ["x2", "2x larger chat room text"],
          ["x3", "3x larger chat room text"],
          ["x4", "4x larger chat room text"]
        ],
        messageStyleSettings: [
          ["cards", "Card style (default)"],
          ["compact", "Compact style (with display names)"],
          ["compact2", "Compact style (usernames only)"]
        ],
        imageDisplaySettings: [
          ["show", "Always show images in chat"],
          ["collapse", "Collapse images in chat, clicking to expand (default)"],
          ["hide", "Never show images shared in chat"]
        ],
        sounds: {
          available: SoundEffects,
          settings: DefaultSounds,
          ready: false,
          audioContext: null,
          audioTracks: {}
        },
        // Cached blocklist for the current user sent by your website.
        CachedBlocklist
      },
      // User JWT settings if available.
      jwt: {
        token: UserJWTToken,
        valid: UserJWTValid,
        claims: UserJWTClaims,
        rules: UserJWTRules
      },
      channel: "lobby",
      username: "",
      //"test",
      autoLogin: false,
      // e.g. from JWT auth
      message: "",
      messageBox: null,
      // HTML element for message entry box
      typingNotifDebounce: null,
      status: "online",
      // away/idle status
      StatusMessage,
      // Emoji picker visible for messages
      showEmojiPicker: false,
      // Idle detection variables
      idleTimeout: null,
      idleThreshold: 300,
      // number of seconds you must be idle
      // WebSocket connection.
      // Initialized in the dial() function.
      client: {},
      // Who List for the room.
      whoList: [],
      whoTab: "online",
      whoSort: "a-z",
      whoMap: {},
      // map username to wholist entry
      whoOnline: {},
      // map users actually online right now
      muted: {},
      // muted usernames for client side state
      // Misc. user preferences (TODO: move all of them here)
      prefs: {
        usePolling: false,
        // use the polling API instead of WebSockets.
        joinMessages: true,
        // show "has entered the room" in public channels
        exitMessages: false,
        // hide exit messages by default in public channels
        watchNotif: true,
        // notify in chat about cameras being watched
        closeDMs: false,
        // ignore unsolicited DMs
        muteSounds: false,
        // mute all sound effects
        theme: "auto",
        // auto, light, dark theme
        debug: false
        // enable debugging features
      },
      // My video feed.
      webcam: {
        busy: false,
        active: false,
        elem: null,
        // <video id="localVideo"> element
        stream: null,
        // MediaStream object
        muted: false,
        // our outgoing mic is muted, not by default
        autoMute: false,
        // mute our mic automatically when going live (user option)
        nsfw: false,
        // user has flagged their camera to be NSFW
        mutual: false,
        // user wants viewers to share their own videos
        mutualOpen: false,
        // user wants to open video mutually
        nonExplicit: false,
        // user prefers not to see explicit cameras
        vipOnly: false,
        // only show camera to fellow VIP users
        rememberExpresslyClosed: true,
        // remember cams we expressly closed
        autoMuteWebcams: false,
        // auto-mute other cameras' audio channels
        // My watermark image for screen recording protection.
        // Set after login in setWatermark.
        watermark: null,
        // Who all is watching me? map of users.
        watching: {},
        // Scaling setting for the videos drawer, so the user can
        // embiggen the webcam sizes so a suitable size.
        videoScale: "",
        videoScaleOptions: [
          ["", "Default size"],
          ["x1", "50% larger videos"],
          ["x2", "2x larger videos"],
          ["x3", "3x larger videos"],
          ["x4", "4x larger videos (not recommended)"]
        ],
        // Available cameras and microphones for the Settings modal.
        gettingDevices: false,
        // busy indicator for refreshing devices
        videoDevices: [],
        videoDeviceID: null,
        audioDevices: [],
        audioDeviceID: null,
        // Advanced: automatically share your webcam when the page loads.
        autoshare: false,
        // After we get a device selected, remember it (by name) so that we
        // might hopefully re-select it by default IF we are able to enumerate
        // devices before they go on camera the first time.
        preferredDeviceNames: {
          video: null,
          audio: null
        },
        // Detect dark video streams.
        darkVideo: {
          canvas: null,
          // <canvas> element to screenshot video into
          ctx: null,
          // Canvas context2d
          interval: null,
          // interval loop
          lastImage: null,
          // data: uri of last screenshot taken
          lastAverage: [],
          // last average RGB color
          lastAverageColor: "rgba(255, 0, 255, 1)",
          wasTooDark: false,
          // previous average was too dark
          // Configuration thresholds: how dark is too dark? (0-255)
          // NOTE: 0=disable the feature.
          threshold: 10
        }
      },
      // Video flag constants (sync with values in messages.go)
      VideoFlag,
      // WebRTC sessions with other users.
      WebRTC: {
        // Streams per username.
        streams: {},
        muted: {},
        // muted bool per username
        booted: {},
        // booted bool per username
        poppedOut: {},
        // popped-out video per username
        speaking: {},
        // speaking boolean per username
        // RTCPeerConnections per username.
        pc: {},
        // Video stream freeze detection.
        frozenStreamInterval: {},
        // map usernames to intervals
        frozenStreamDetected: {},
        // map usernames to bools
        // Debounce connection attempts since now every click = try to connect.
        debounceOpens: {},
        // map usernames to bools
        // Timeouts for open camera attempts. e.g.: when you click to view
        // a camera, the icon changes to a spinner for a few seconds to see
        // whether the video goes on to open.
        openTimeouts: {},
        // map usernames to timeouts
        // Map of usernames whose cameras were expressly closed by us.
        // Example: we have mutualOpen enabled, someone opens our cam
        // so we open theirs back, and then we expressly 'X' out and
        // close their camera. If they close and re-open ours, we don't
        // want to auto-open their cam back because we had previously
        // closed out of it manually.
        //
        // Usernames are added when we 'X' out of their video,
        // and usernames are removed when we expressly re-open their
        // video (e.g., by clicking their Who List video button).
        expresslyClosed: {}
        // bool per username
      },
      // Chat history.
      channels: {
        // There will be values here like:
        // "lobby": {
        //   "history": [],
        //   "updated": timestamp,
        //   "unread": 4,
        //   "urgent": false, // true if at-mentioned
        // },
        // "@username": {
        //   "history": [],
        //   ...
        // }
      },
      historyScrollbox: null,
      autoscroll: true,
      // scroll to bottom on new messages
      fontSizeClass: "",
      // font size magnification
      messageStyle: "cards",
      // message display style
      imageDisplaySetting: "collapse",
      // image show/hide setting
      scrollback: 1e3,
      // scrollback buffer (messages to keep per channel)
      DMs: {},
      messageReactions: {
        // Will look like:
        // "123": {    (message ID)
        //    "❤️": [  (reaction emoji)
        //        "username"  // users who reacted
        //    ]
        // }
      },
      // Loading older Direct Message chat history.
      directMessageHistory: {
        /* Will look like:
        "username": {
            "busy": false,  // ajax request in flight
            "beforeID": 1234, // next page cursor
            "remaining": 50,  // number of older messages remaining
        }
        */
      },
      clearDirectMessages: {
        busy: false,
        ok: false,
        messagesErased: 0,
        timeout: null
      },
      // Responsive CSS controls for mobile.
      responsive: {
        leftDrawerOpen: false,
        rightDrawerOpen: false,
        nodes: {
          // DOM nodes for the CSS grid cells.
          $container: null,
          $left: null,
          $center: null,
          $right: null
        }
      },
      // Generic Alert/Confirm modal to replace native browser events.
      // See also: modalAlert, modalConfirm functions.
      alertModal: {
        visible: false,
        isConfirm: false,
        title: "Alert",
        icon: "",
        message: "",
        callback() {
        }
      },
      loginModal: {
        visible: false
      },
      settingsModal: {
        visible: false,
        tab: "prefs"
        // selected setting tab
      },
      nsfwModalCast: {
        visible: false
      },
      nsfwModalView: {
        visible: false,
        dontShowAgain: false,
        user: null
        // staged User we wanted to open
      },
      reportModal: {
        visible: false,
        busy: false,
        user: {},
        // full copy of the user for the modal component
        message: {},
        origMessage: {}
        // pointer, so we can set the "reported" flag
      },
      profileModal: {
        visible: false,
        user: {},
        username: ""
      }
    };
  },
  mounted() {
    this.setupConfig();
    this.setupIdleDetection();
    this.setupDropZone();
    window.SendMessage = this.sendCommand;
    StatusMessage.nsfw = this.config.permitNSFW;
    StatusMessage.currentStatus = () => {
      return this.status;
    };
    StatusMessage.isAdmin = () => {
      return this.isOp;
    };
    this.webcam.elem = document.querySelector("#localVideo");
    this.historyScrollbox = document.querySelector("#chatHistory");
    this.responsive.nodes = {
      $container: document.querySelector(".chat-container"),
      $left: document.querySelector(".left-column"),
      $center: document.querySelector(".chat-column"),
      $right: document.querySelector(".right-column")
    };
    this.messageBox = document.getElementById("messageBox");
    window.addEventListener("resize", () => {
      this.resetResponsiveCSS();
    });
    window.addEventListener("focus", () => {
      this.windowFocused = true;
      this.windowFocusedAt = /* @__PURE__ */ new Date();
      let channel = this.channel;
      if (this.channels[channel].unread > 0) {
        this.channels[channel].unread = 0;
        this.channels[channel].urgent = false;
      }
    });
    window.addEventListener("blur", () => {
      this.windowFocused = false;
    });
    window.addEventListener("click", () => {
      this.setupSounds();
    });
    window.addEventListener("keyup", () => {
      this.setupSounds();
    });
    for (let channel of this.config.channels) {
      this.initHistory(channel.ID);
    }
    this.ChatClient("Welcome to BareRTC!");
    if (this.jwt.valid && this.jwt.claims.sub) {
      this.username = this.jwt.claims.sub;
      this.autoLogin = true;
    }
    history.pushState(null, "", location.href.split("?")[0]);
    if (!this.username) {
      this.loginModal.visible = true;
    } else {
      this.signIn(this.username);
    }
  },
  watch: {
    "webcam.videoScale": function() {
      document.querySelectorAll(".video-feeds > .feed").forEach((node) => {
        node.style.width = null;
        node.style.height = null;
      });
      LocalStorage.set("videoScale", this.webcam.videoScale);
    },
    whoSort() {
      LocalStorage.set("whoSort", this.whoSort);
    },
    fontSizeClass() {
      LocalStorage.set("fontSizeClass", this.fontSizeClass);
    },
    messageStyle() {
      LocalStorage.set("messageStyle", this.messageStyle);
    },
    imageDisplaySetting() {
      LocalStorage.set("imageDisplaySetting", this.imageDisplaySetting);
    },
    scrollback() {
      LocalStorage.set("scrollback", this.scrollback);
    },
    status() {
      this.sendMe();
    },
    pageTitleUnreadPrefix() {
      document.title = this.pageTitleUnreadPrefix + this.pageTitle;
    },
    // Webcam preferences that the user can edit while live.
    "webcam.nsfw": function() {
      this.webcam.wasServerNSFW = false;
      LocalStorage.set("videoExplicit", this.webcam.nsfw);
      if (this.webcam.active) {
        this.sendMe();
      }
    },
    "webcam.mutual": function() {
      LocalStorage.set("videoMutual", this.webcam.mutual);
      if (this.webcam.active) {
        this.sendMe();
      }
    },
    "webcam.mutualOpen": function() {
      LocalStorage.set("videoMutualOpen", this.webcam.mutualOpen);
      if (this.webcam.active) {
        this.sendMe();
      }
    },
    "webcam.nonExplicit": function() {
      LocalStorage.set("videoNonExplicit", this.webcam.nonExplicit);
      if (this.webcam.active) {
        this.sendMe();
      }
    },
    "webcam.vipOnly": function() {
      LocalStorage.set("videoVipOnly", this.webcam.vipOnly);
      if (this.webcam.active) {
        this.sendMe();
      }
      for (let username of Object.keys(this.WebRTC.pc)) {
        if (this.whoMap[username] != void 0 && this.isVideoNotAllowed(this.whoMap[username])) {
          this.closeVideo(username);
        }
      }
    },
    "webcam.rememberExpresslyClosed": function() {
      LocalStorage.set("rememberExpresslyClosed", this.webcam.rememberExpresslyClosed);
    },
    "webcam.autoMuteWebcams": function() {
      LocalStorage.set("autoMuteWebcams", this.webcam.autoMuteWebcams);
    },
    "webcam.autoshare": function() {
      LocalStorage.set("videoAutoShare", this.webcam.autoshare);
    },
    // Misc preference watches
    "prefs.joinMessages": function() {
      LocalStorage.set("joinMessages", this.prefs.joinMessages);
    },
    "prefs.exitMessages": function() {
      LocalStorage.set("exitMessages", this.prefs.exitMessages);
    },
    "prefs.watchNotif": function() {
      LocalStorage.set("watchNotif", this.prefs.watchNotif);
    },
    "prefs.muteSounds": function() {
      LocalStorage.set("muteSounds", this.prefs.muteSounds);
    },
    "prefs.usePolling": function() {
      LocalStorage.set("usePolling", this.prefs.usePolling);
      this.resetChatClient();
    },
    "prefs.closeDMs": function() {
      LocalStorage.set("closeDMs", this.prefs.closeDMs);
      this.sendMe();
    },
    "prefs.debug": function() {
      LocalStorage.set("debug", this.prefs.debug);
    },
    "prefs.theme": function() {
      LocalStorage.set("theme", this.prefs.theme);
    }
  },
  computed: {
    connected() {
      if (this.client.connected != void 0) {
        return this.client.connected();
      }
      return false;
    },
    chatHistory() {
      if (this.channels[this.channel] == void 0) {
        return [];
      }
      let history2 = this.channels[this.channel].history;
      if (this.channel.indexOf("@") === 0)
        ;
      return history2;
    },
    activeDMs() {
      let result = [];
      for (let channel of Object.keys(this.channels)) {
        if (channel.indexOf("@") !== 0) {
          continue;
        }
        result.push({
          channel,
          name: channel.substring(1),
          updated: this.channels[channel].updated,
          unread: this.channels[channel].unread
        });
      }
      result.sort((a2, b2) => b2.updated - a2.updated);
      return result;
    },
    channelName() {
      if (this.channel.indexOf("@") === 0) {
        return this.channel;
      }
      for (let channel of this.config.channels) {
        if (channel.ID === this.channel) {
          return channel.Name;
        }
      }
      return this.channel;
    },
    isDM() {
      return this.channel.indexOf("@") === 0;
    },
    currentDMPartner() {
      if (!this.isDM)
        return {};
      return this.whoMap[this.normalizeUsername(this.channel)];
    },
    pageTitleUnreadPrefix() {
      if (this.windowFocused)
        return "";
      let count = 0;
      for (let channel of Object.keys(this.channels)) {
        if (channel.indexOf("@") === 0 && this.channels[channel].unread > 0) {
          count += this.channels[channel].unread;
        }
      }
      return count > 0 ? `(${count}) ` : "";
    },
    chatPartnerStatusMessage() {
      if (!this.isDM) {
        return null;
      }
      let username = this.normalizeUsername(this.channel), user = this.whoMap[username];
      if (user == void 0 || this.isUserOffline(username)) {
        return this.StatusMessage.offline();
      }
      return this.StatusMessage.getStatus(user.status);
    },
    isChatPartnerAway() {
      if (!this.isDM)
        return false;
      let status = this.chatPartnerStatusMessage;
      return status === null || status.name !== "online";
    },
    canUploadFile() {
      if (this.jwt.rules.IsNoImageRule)
        return false;
      if (!this.isDM) {
        for (let cfg of this.config.channels) {
          if (cfg.ID === this.channel && cfg.PermitPhotos) {
            return true;
          }
        }
        return false;
      }
      if (this.jwt.claims.op) {
        return true;
      }
      if (this.isDM) {
        let partner = this.normalizeUsername(this.channel);
        if (this.whoMap[partner] != void 0 && this.whoMap[partner].op) {
          return true;
        }
      }
      return !this.isDM;
    },
    isOp() {
      var _a;
      return this.jwt.claims.op || ((_a = this.whoMap[this.username]) == null ? void 0 : _a.op);
    },
    isVIP() {
      return this.jwt.claims.vip;
    },
    myVideoFlag() {
      let status = 0;
      if (!this.webcam.active)
        return 0;
      if (this.webcam.active)
        status |= this.VideoFlag.Active;
      if (this.webcam.muted)
        status |= this.VideoFlag.Muted;
      if (this.webcam.nsfw && this.config.permitNSFW)
        status |= this.VideoFlag.NSFW;
      if (this.webcam.mutual)
        status |= this.VideoFlag.MutualRequired;
      if (this.webcam.mutualOpen)
        status |= this.VideoFlag.MutualOpen;
      if (this.webcam.nonExplicit)
        status |= this.VideoFlag.NonExplicit;
      if (this.webcam.vipOnly && this.isVIP)
        status |= this.VideoFlag.VipOnly;
      return status;
    },
    anyVideosOpen() {
      return this.webcam.active || this.numVideosOpen > 0;
    },
    numVideosOpen() {
      return Object.keys(this.WebRTC.streams).length;
    },
    activeChannels() {
      let result = [];
      for (let channel of this.config.channels) {
        if (channel.VIP && !this.isVIP)
          continue;
        let data = {
          ID: channel.ID,
          Name: channel.Name
        };
        if (this.channels[channel.ID] != void 0) {
          data.Unread = this.channels[channel.ID].unread;
          data.Urgent = this.channels[channel.ID].urgent;
          data.Updated = this.channels[channel.ID].updated;
        }
        result.push(data);
      }
      if (this.prefs.debug) {
        result.push({
          ID: DebugChannelID,
          Name: "Debug Log"
        });
      }
      return result;
    },
    atMentionItems() {
      let result = [
        {
          value: "all",
          label: "All people in the current room",
          searchText: "all people in the current room"
        },
        {
          value: "here",
          label: "Everybody here in the current room",
          searchText: "all people in the current room"
        }
      ];
      for (let user of this.whoList) {
        if (user.username === this.username)
          continue;
        result.push({
          value: user.username,
          label: user.nickname,
          searchText: user.username + " " + user.nickname
        });
      }
      return result;
    },
    sortedWhoList() {
      let result = [...this.whoList];
      switch (this.whoSort) {
        case "broadcasting":
          result.sort((a2, b2) => {
            return (b2.video & this.VideoFlag.Active) - (a2.video & this.VideoFlag.Active);
          });
          break;
        case "nsfw":
          result.sort((a2, b2) => {
            let left2 = a2.video & (this.VideoFlag.Active | this.VideoFlag.NSFW), right2 = b2.video & (this.VideoFlag.Active | this.VideoFlag.NSFW);
            return right2 - left2;
          });
          break;
        case "status":
          result.sort((a2, b2) => {
            if (a2.status === b2.status)
              return 0;
            return b2.status < a2.status ? -1 : 1;
          });
          break;
        case "op":
          result.sort((a2, b2) => {
            return b2.op - a2.op;
          });
          break;
        case "emoji":
          result.sort((a2, b2) => {
            if (a2.emoji === b2.emoji)
              return 0;
            return a2.emoji < b2.emoji ? -1 : 1;
          });
          break;
        case "login":
          result.sort((a2, b2) => {
            return b2.loginAt - a2.loginAt;
          });
          break;
        case "gender":
          result.sort((a2, b2) => {
            if (a2.gender === b2.gender)
              return 0;
            let left2 = a2.gender || "z", right2 = b2.gender || "z";
            return left2 < right2 ? -1 : 1;
          });
          break;
        case "z-a":
          result = result.reverse();
      }
      return result;
    },
    sortedWatchingList() {
      let result = [];
      for (let username of Object.keys(this.webcam.watching)) {
        let user = this.getUser(username);
        result.push(user);
      }
      switch (this.whoSort) {
        case "broadcasting":
          result.sort((a2, b2) => {
            return (b2.video & this.VideoFlag.Active) - (a2.video & this.VideoFlag.Active);
          });
          break;
        case "nsfw":
          result.sort((a2, b2) => {
            let left2 = a2.video & (this.VideoFlag.Active | this.VideoFlag.NSFW), right2 = b2.video & (this.VideoFlag.Active | this.VideoFlag.NSFW);
            return right2 - left2;
          });
          break;
        case "status":
          result.sort((a2, b2) => {
            if (a2.status === b2.status)
              return 0;
            return b2.status < a2.status ? -1 : 1;
          });
          break;
        case "op":
          result.sort((a2, b2) => {
            return b2.op - a2.op;
          });
          break;
        case "emoji":
          result.sort((a2, b2) => {
            if (a2.emoji === b2.emoji)
              return 0;
            return a2.emoji < b2.emoji ? -1 : 1;
          });
          break;
        case "login":
          result.sort((a2, b2) => {
            return b2.loginAt - a2.loginAt;
          });
          break;
        case "gender":
          result.sort((a2, b2) => {
            if (a2.gender === b2.gender)
              return 0;
            let left2 = a2.gender || "z", right2 = b2.gender || "z";
            return left2 < right2 ? -1 : 1;
          });
          break;
        case "z-a":
          result = result.reverse();
      }
      return result;
    }
  },
  methods: {
    // Load user prefs from localStorage, called on startup
    setupConfig() {
      const settings = LocalStorage.getSettings();
      if (settings.fontSizeClass != void 0) {
        this.fontSizeClass = settings.fontSizeClass;
      }
      if (settings.messageStyle != void 0) {
        this.messageStyle = settings.messageStyle;
      }
      if (settings.videoScale != void 0) {
        this.webcam.videoScale = settings.videoScale;
      }
      if (settings.imageDisplaySetting != void 0) {
        this.imageDisplaySetting = settings.imageDisplaySetting;
      }
      if (settings.scrollback != void 0) {
        this.scrollback = parseInt(settings.scrollback);
      }
      if (settings.preferredDeviceNames != void 0) {
        let dev = settings.preferredDeviceNames;
        this.webcam.preferredDeviceNames.video = dev.video;
        this.webcam.preferredDeviceNames.audio = dev.audio;
      }
      if (settings.videoMutual === true) {
        this.webcam.mutual = true;
      }
      if (settings.videoMutualOpen === true) {
        this.webcam.mutualOpen = true;
      }
      if (settings.videoAutoMute === true) {
        this.webcam.autoMute = true;
      }
      if (settings.videoAutoShare === true) {
        this.webcam.autoshare = true;
      }
      if (settings.videoVipOnly === true) {
        this.webcam.vipOnly = true;
      }
      if (settings.videoExplicit === true && this.config.permitNSFW) {
        this.webcam.nsfw = true;
      }
      if (settings.videoNonExplicit === true) {
        this.webcam.nonExplicit = true;
      }
      if (settings.rememberExpresslyClosed === false) {
        this.webcam.rememberExpresslyClosed = false;
      }
      if (settings.autoMuteWebcams === true) {
        this.webcam.autoMuteWebcams = true;
      }
      if (settings.usePolling != void 0) {
        this.prefs.usePolling = settings.usePolling === true;
      }
      if (settings.joinMessages != void 0) {
        this.prefs.joinMessages = settings.joinMessages === true;
      }
      if (settings.exitMessages != void 0) {
        this.prefs.exitMessages = settings.exitMessages === true;
      }
      if (settings.watchNotif != void 0) {
        this.prefs.watchNotif = settings.watchNotif === true;
      }
      if (settings.muteSounds != void 0) {
        this.prefs.muteSounds = settings.muteSounds === true;
      }
      if (settings.closeDMs != void 0) {
        this.prefs.closeDMs = settings.closeDMs === true;
      }
      if (this.prefs.debug != void 0) {
        this.prefs.debug = settings.debug === true;
      }
      if (settings.whoSort != void 0) {
        this.whoSort = settings.whoSort;
      }
      if (settings.theme != void 0) {
        this.prefs.theme = settings.theme;
      }
    },
    signIn(username) {
      this.username = username;
      this.loginModal.visible = false;
      this.dial();
    },
    // Normalize a DM channel name into a username (remove the @ prefix)
    normalizeUsername(channel) {
      return channel.replace(/^@+/, "");
    },
    /**
     * Chat API Methods (WebSocket packets sent/received)
     */
    onSelectEmoji(e) {
      let selectionStart = this.messageBox.selectionStart;
      this.message = this.message.slice(0, selectionStart) + e.i + this.message.slice(selectionStart);
      this.hideEmojiPicker();
    },
    hideEmojiPicker() {
      if (!this.showEmojiPicker)
        return;
      window.requestAnimationFrame(() => {
        this.showEmojiPicker = false;
        this.messageBox.focus();
        this.messageBox.selectionStart = this.messageBox.selectionEnd = this.messageBox.value.length;
      });
    },
    sendCommand(message) {
      let origMsg = this.message;
      this.message = message;
      this.sendMessage();
      this.message = origMsg;
    },
    sendMessage() {
      if (!this.message) {
        return;
      }
      if (!this.connected) {
        this.ChatClient("You are not connected to the server.");
        return;
      }
      if (this.message.toLowerCase().indexOf("onlyfans.com") > -1 || this.message.toLowerCase().indexOf("justfor.fans") > -1 || this.message.toLowerCase().indexOf("justforfans") > -1 || this.message.toLowerCase().match(/fans[^A-Za-z0-9]+dot/)) {
        if (this.spamWarningCount >= 1) {
          this.client.send({
            action: "message",
            channel: "lobby",
            message: "**(Message of Shame)** I have been naughty and posted spam in chat despite being warned, and I am now being kicked from the room in shame. ☹️"
          });
          this.ChatServer(
            "It is <strong>not allowed</strong> to promote your Onlyfans (or similar) site on the chat room. You have been removed from the chat room, and this incident has been reported to the site admin."
          );
          this.pushHistory({
            channel: this.channel,
            username: this.username,
            message: "has been kicked from the room!",
            action: "presence"
          });
          this.disconnect = true;
          this.client.ws.connected = false;
          setTimeout(() => {
            this.client.disconnect();
          }, 1e3);
          return;
        }
        this.spamWarningCount++;
        this.ChatClient(
          "Please <strong>do not</strong> send links to your Onlyfans (or similar sites) in the chat room. Those links are widely regarded to be spam and make a lot of people uncomfortable. If you violate this again, your account will be suspended."
        );
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/toggle-debug-settings") === 0) {
        this.prefs.debug = !this.prefs.debug;
        this.ChatClient(
          `Debug tools have been turned: <strong>${this.prefs.debug ? "on" : "off"}.</strong>`
        );
        this.message = "";
        return;
      }
      let match = this.message.match(/^\/freeze (.+?)$/i);
      if (match) {
        let username = match[1];
        this.WebRTC.frozenStreamDetected[username] = true;
        this.ChatClient(`DEBUG: Marked ${username} stream as frozen.`);
        this.message = "";
        return;
      }
      match = this.message.match(/^\/takeback (\d+)$/i);
      if (match) {
        let msgID = parseInt(match[1]);
        this.client.send({
          action: "takeback",
          msgID
        });
        this.ChatClient(`Takeback command send for message ID ${msgID}.`);
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/debug-broken-video") === 0) {
        this.WebRTC.streams["#broken"] = null;
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/debug-webrtc") === 0) {
        let lines = [
          "<strong>WebRTC PeerConnections:</strong>"
        ];
        for (let username of Object.keys(this.WebRTC.pc)) {
          let pc = this.WebRTC.pc[username];
          let line = `${username}: `;
          if (pc.offerer != void 0) {
            line += "offerer; ";
          }
          if (pc.answerer != void 0) {
            line += "answerer; ";
          }
          lines.push(line);
        }
        this.ChatClient(lines.join("<br>"));
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/debug-dark-video") === 0) {
        if (this.webcam.darkVideo.lastImage === null) {
          this.ChatClient("There is no recent image available.");
        } else {
          this.ChatClient(`
                        <strong>Dark Video Detector: Diagnostics</strong><br><br>
                        If your camera has been detected as being "too dark" but you believe this was an error, please
                        find a chat moderator (or visit the main website and contact the support team) for assistance:
                        you may be able to help us to resolve this error.<br><br>
                        In your message to an admin, please copy the following information:<br><br>
                        * The last average color detected from your video: ${JSON.stringify(this.webcam.darkVideo.lastAverage)}
                          <span style="background-color: ${this.webcam.darkVideo.lastAverageColor}">${this.webcam.darkVideo.lastAverageColor}</span><br>
                        * Your web browser user-agent: ${navigator.userAgent}<br><br>
                        Below is a recent screenshot from your webcam, which the chat page uses to find the average color
                        of your video feed. Note: if this image appears to be solid black, but your webcam was <strong>not</strong>
                        actually this dark, definitely let us know! It may point to a bug in the dark video detector:<br><br>
                        <img src="${this.webcam.darkVideo.lastImage}" width="160" height="120"><br><br>
                        For a troubleshooting tip: if your webcam is a removable USB device, please try <strong>closing your web browser,
                        unplugging and reconnecting your webcam, and then open your web browser again</strong> and see if the issue
                        is resolved. If that worked, also let a chat moderator know!
                    `);
        }
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/reconnect") === 0) {
        this.resetChatClient();
        this.message = "";
        return;
      }
      if (this.message.toLowerCase().indexOf("/clear-history") === 0) {
        this.clearMessageHistory();
        this.message = "";
        return;
      }
      this.client.send({
        action: "message",
        channel: this.channel,
        message: this.message
      });
      this.message = "";
    },
    sendTypingNotification() {
    },
    // Emoji reactions
    sendReact(message, emoji) {
      if (message.message.indexOf("barertc-no-emoji-reactions") > -1)
        return;
      this.client.send({
        action: "react",
        msgID: message.msgID,
        message: emoji
      });
    },
    onReact(msg) {
      let msgID = msg.msgID, who = msg.username, emoji = msg.message;
      if (this.messageReactions[msgID] == void 0) {
        this.messageReactions[msgID] = {};
      }
      if (this.messageReactions[msgID][emoji] == void 0) {
        this.messageReactions[msgID][emoji] = [];
      }
      let unreact = false;
      for (let i2 = 0; i2 < this.messageReactions[msgID][emoji].length; i2++) {
        let reactor = this.messageReactions[msgID][emoji][i2];
        if (reactor === who) {
          this.messageReactions[msgID][emoji].splice(i2, 1);
          unreact = true;
        }
      }
      if (unreact) {
        if (this.messageReactions[msgID][emoji].length === 0) {
          delete this.messageReactions[msgID][emoji];
        }
        return;
      }
      this.messageReactions[msgID][emoji].push(who);
    },
    // Sync the current user state (such as video broadcasting status) to
    // the backend, which will reload everybody's Who List.
    sendMe() {
      if (!this.connected)
        return;
      this.client.send({
        action: "me",
        video: this.myVideoFlag,
        status: this.status,
        dnd: this.prefs.closeDMs
      });
    },
    onMe(msg) {
      if (this.username != msg.username) {
        this.ChatServer(`Your username has been changed to ${msg.username}.`);
        this.username = msg.username;
      }
      let myNSFW = this.webcam.nsfw;
      let theirNSFW = (msg.video & this.VideoFlag.NSFW) > 0;
      if (this.webcam.active && myNSFW != theirNSFW && theirNSFW) {
        this.webcam.nsfw = theirNSFW;
        window.requestAnimationFrame(() => {
          this.webcam.wasServerNSFW = true;
        });
      }
      this.bulkMuteUsers();
    },
    // WhoList updates.
    onWho(msg) {
      var _a;
      let sendMe = false;
      this.whoList = msg.whoList;
      this.whoOnline = {};
      if (this.whoList == void 0) {
        this.whoList = [];
      }
      for (let row of this.whoList) {
        if (this.webcam.nonExplicit && this.WebRTC.streams[row.username] != void 0) {
          if (!(this.whoMap[row.username].video & this.VideoFlag.NSFW) && row.video & this.VideoFlag.NSFW) {
            this.closeVideo(row.username, "offerer");
          }
        }
        this.whoMap[row.username] = row;
        this.whoOnline[row.username] = true;
        if (this.WebRTC.streams[row.username] != void 0 && !(row.video & this.VideoFlag.Active)) {
          this.closeVideo(row.username, "offerer");
        }
        if (row.username === this.username && row.status !== this.status) {
          sendMe = true;
        }
      }
      this.unMutualVideo();
      for (let username of Object.keys(this.WebRTC.pc)) {
        if (this.whoOnline[username] == void 0) {
          this.closeVideo(username);
        }
      }
      if (this.webcam.active && !(((_a = this.whoMap[this.username]) == null ? void 0 : _a.video) & this.VideoFlag.Active)) {
        sendMe = true;
      }
      if (sendMe) {
        this.sendMe();
      }
    },
    // Server side "block" event: for when the main website sends a BlockNow API request.
    onBlock(msg) {
      this.closeVideo(msg.username);
      for (let existing of this.config.CachedBlocklist) {
        if (existing === msg.username) {
          return;
        }
      }
      this.config.CachedBlocklist.push(msg.username);
    },
    // Server side "cut" event: tells the user to turn off their camera.
    onCut(msg) {
      this.DebugChannel(`Received cut command from server: ${JSON.stringify(msg)}`);
      this.stopVideo();
    },
    // Mute or unmute a user.
    muteUser(username) {
      username = this.normalizeUsername(username);
      let mute = this.muted[username] == void 0;
      if (this.config.CachedBlocklist.length > 0) {
        for (let user of this.config.CachedBlocklist) {
          if (user === username) {
            this.ChatClient(
              `You can not unmute <strong>${username}</strong> because you have blocked them on the main website. To unmute them, you will need to unblock them on the website and then reload the chat room.`
            );
            return;
          }
        }
      }
      const callback = () => {
        this.closeVideo(username);
        this.sendMute(username, mute);
        if (mute) {
          this.ChatClient(
            `You have muted <strong>${username}</strong> and will no longer see their chat messages, and they will not see whether your webcam is active. You may unmute them via the Who Is Online list.`
          );
        } else {
          this.ChatClient(
            `You have unmuted <strong>${username}</strong> and can see their chat messages from now on.`
          );
        }
      };
      if (mute) {
        this.modalConfirm({
          title: `Mute ${username}`,
          icon: "fa fa-comment-slash",
          message: `Do you want to mute ${username}? If muted, you will no longer see their chat messages or any DMs they send you going forward. Also, ${username} will not be able to see whether your webcam is active until you unmute them.`
        }).then(() => {
          this.muted[username] = true;
          callback();
        });
      } else {
        this.modalConfirm({
          title: `Un-mute ${username}`,
          icon: "fa fa-comment",
          message: `Do you want to remove your mute on ${username}? If you un-mute them, you will be able to see their chat messages or DMs going forward, but most importantly, they may be able to watch your webcam now if you are broadcasting!`
        }).then(() => {
          delete this.muted[username];
          callback();
        });
      }
    },
    sendMute(username, mute) {
      this.client.send({
        action: mute ? "mute" : "unmute",
        username
      });
    },
    isMutedUser(username) {
      return this.muted[this.normalizeUsername(username)] != void 0;
    },
    isBlockedUser(username) {
      if (this.config.CachedBlocklist.length > 0) {
        for (let user of this.config.CachedBlocklist) {
          if (user === username) {
            return true;
          }
        }
      }
      return false;
    },
    bulkMuteUsers() {
      let mapBlockedUsers = {};
      if (this.config.CachedBlocklist.length > 0) {
        let blocklist = this.config.CachedBlocklist;
        for (let username of blocklist) {
          mapBlockedUsers[username] = true;
          this.muted[username] = true;
        }
        this.client.send({
          action: "blocklist",
          usernames: blocklist
        });
      }
      for (let username of Object.keys(this.WebRTC.booted)) {
        this.sendBoot(username);
      }
      for (let username of Object.keys(this.muted)) {
        if (mapBlockedUsers[username])
          continue;
        this.sendMute(username, true);
      }
    },
    // Send a video request to access a user's camera.
    sendOpen(username) {
      this.DebugChannel(`[WebRTC] Sending "open" message to ask to connect to: ${username}`);
      this.client.send({
        action: "open",
        username
      });
    },
    sendBoot(username) {
      this.client.send({
        action: "boot",
        username
      });
    },
    sendUnboot(username) {
      this.client.send({
        action: "unboot",
        username
      });
    },
    onOpen(msg) {
      this.DebugChannel(`[WebRTC] Received "open" echo from chat server to connect to: ${msg.username}`);
      this.startWebRTC(msg.username, true);
    },
    onRing(msg) {
      this.DebugChannel(`[WebRTC] Received "ring" message from chat server to share my video with: ${msg.username}`);
      this.startWebRTC(msg.username, false);
    },
    onUserExited(msg) {
      this.closeVideo(msg.username);
    },
    // Handle messages sent in chat.
    onMessage(msg) {
      if (msg.channel.indexOf("@") === 0) {
        this.initDirectMessageHistory(msg.channel, msg.msgID);
        if (msg.channel !== this.channel || !this.windowFocused) {
          if (this.prefs.closeDMs && this.channels[msg.channel] == void 0) {
            console.log("Unsolicited DM received");
          } else {
            this.playSound("DM");
          }
        }
      } else if (msg.channel !== this.channel || !this.windowFocused) {
        this.playSound("Chat");
      }
      this.pushHistory({
        channel: msg.channel,
        username: msg.username,
        message: msg.message,
        messageID: msg.msgID
      });
    },
    // A user deletes their message for everybody
    onTakeback(msg) {
      for (let channel of Object.keys(this.channels)) {
        for (let i2 = 0; i2 < this.channels[channel].history.length; i2++) {
          let cmp = this.channels[channel].history[i2];
          if (cmp.msgID === msg.msgID) {
            this.channels[channel].history.splice(i2, 1);
            return;
          }
        }
      }
      console.error("Got a takeback for msgID %d but did not find it!", msg.msgID);
    },
    // User logged in or out.
    onPresence(msg) {
      let isLeave = false, isJoin = false;
      if (msg.message.indexOf("has exited the room!") > -1) {
        this.onUserExited(msg);
        this.playSound("Leave");
        isLeave = true;
      } else if (msg.message.indexOf("has joined the room!") > -1) {
        this.playSound("Enter");
        isJoin = true;
      }
      if (isJoin && this.prefs.joinMessages || isLeave && this.prefs.exitMessages || !isJoin && !isLeave) {
        let channel2 = this.config.channels[0];
        this.pushHistory({
          channel: channel2.ID,
          action: msg.action,
          username: msg.username,
          message: msg.message
        });
        if (!this.isDM && this.channel !== channel2.ID) {
          this.pushHistory({
            channel: this.channel.ID,
            action: msg.action,
            username: msg.username,
            message: msg.message
          });
        }
      }
      let channel = "@" + msg.username;
      if (this.channels[channel] != void 0) {
        this.pushHistory({
          channel,
          action: msg.action,
          username: msg.username,
          message: msg.message
        });
      }
    },
    // Dial the WebSocket connection.
    dial() {
      this.client = new ChatClient({
        usePolling: this.prefs.usePolling,
        onClientError: this.ChatClient,
        username: this.username,
        jwt: this.jwt,
        prefs: this.prefs,
        onLoggedIn: this.onLoggedIn,
        onWho: this.onWho,
        onMe: this.onMe,
        onMessage: this.onMessage,
        onTakeback: this.onTakeback,
        onReact: this.onReact,
        onPresence: this.onPresence,
        onRing: this.onRing,
        onOpen: this.onOpen,
        onCandidate: this.onCandidate,
        onSDP: this.onSDP,
        onWatch: this.onWatch,
        onUnwatch: this.onUnwatch,
        onBlock: this.onBlock,
        onCut: this.onCut,
        bulkMuteUsers: this.bulkMuteUsers,
        focusMessageBox: () => {
          this.messageBox.focus();
        },
        pushHistory: this.pushHistory,
        onNewJWT: (jwt) => {
          this.jwt.token = jwt;
        }
      });
      this.client.dial();
    },
    resetChatClient() {
      if (!this.connected)
        return;
      this.ChatClient(
        "Your connection method to the chat server has been updated; attempting to reconnect now."
      );
      window.requestAnimationFrame(() => {
        this.client.disconnect();
        setTimeout(() => {
          this.dial();
        }, 1e3);
      });
    },
    onLoggedIn() {
      this.webcam.watermark = WatermarkImage(this.username);
      if (this.webcam.autoshare) {
        this.startVideo({ force: true });
      }
    },
    /**
     * WebRTC concerns.
     */
    // Start WebRTC with the other username.
    startWebRTC(username, isOfferer) {
      let pc = new RTCPeerConnection(configuration);
      if (this.WebRTC.pc[username] == void 0) {
        this.WebRTC.pc[username] = {};
      }
      if (isOfferer) {
        this.WebRTC.pc[username].offerer = pc;
      } else {
        this.WebRTC.pc[username].answerer = pc;
      }
      this.DebugChannel(`[WebRTC] Starting WebRTC with: ${username} (I am the: ${isOfferer ? "offerer" : "answerer"})`);
      this.WebRTC.pc[username].connecting = pc;
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          this.client.send({
            action: "candidate",
            username,
            candidate: JSON.stringify(event.candidate)
          });
        }
      };
      if (isOfferer) {
        pc.onnegotiationneeded = () => {
          pc.createOffer().then(this.localDescCreated(pc, username)).catch(this.ChatClient);
        };
      }
      pc.ontrack = (event) => {
        if (!isOfferer && !this.webcam.mutualOpen) {
          this.DebugChannel(`[WebRTC] The offerer ${username} gave us a video, but we don't auto-open their video.`);
          return;
        }
        const stream = event.streams[0];
        if (this.WebRTC.expresslyClosed[username] && this.webcam.rememberExpresslyClosed) {
          if (!isOfferer) {
            return;
          }
        }
        if (this.isBootedAdmin(username)) {
          return;
        }
        if (this.WebRTC.openTimeouts[username] != void 0) {
          clearTimeout(this.WebRTC.openTimeouts[username]);
          delete this.WebRTC.openTimeouts[username];
        }
        if (this.WebRTC.streams[username] == void 0 || this.WebRTC.streams[username].id !== stream.id) {
          this.WebRTC.streams[username] = stream;
        }
        window.requestAnimationFrame(() => {
          let $ref = document.getElementById(`videofeed-${username}`);
          $ref.srcObject = stream;
          if (this.webcam.autoMuteWebcams) {
            this.WebRTC.muted[username] = true;
            $ref.muted = true;
          }
          this.initSpeakingEvents(username, $ref);
        });
        this.sendWatch(username, true);
        stream.getVideoTracks().forEach((videoTrack) => {
          let freezeDetected = () => {
            this.DebugChannel("[WebRTC] A video freeze was detected from:", username);
            setTimeout(() => {
              if (videoTrack.muted) {
                this.WebRTC.frozenStreamDetected[username] = true;
              }
            }, 7500);
          };
          videoTrack.onmute = freezeDetected;
          if (this.WebRTC.frozenStreamInterval[username]) {
            clearInterval(this.WebRTC.frozenStreamInterval[username]);
          }
          this.WebRTC.frozenStreamInterval[username] = setInterval(() => {
            if (videoTrack.muted)
              freezeDetected();
          }, 3e3);
        });
      };
      if (!isOfferer && this.webcam.active) {
        this.DebugChannel(`[WebRTC] Answerer: attaching my video to the connection with: ${username}`);
        let stream = this.webcam.stream;
        stream.getTracks().forEach((track2) => {
          pc.addTrack(track2, stream);
        });
      }
      if (isOfferer) {
        let shouldOfferVideo = this.whoMap[username].video & this.VideoFlag.MutualOpen && this.webcam.active && !this.isBooted(username) && !this.isMutedUser(username) && (!this.webcam.nsfw || !(this.whoMap[username].video & this.VideoFlag.NonExplicit));
        if (shouldOfferVideo) {
          this.DebugChannel(`[WebRTC] Offerer: I am attaching my video to the connection with: ${username}`);
          let stream = this.webcam.stream;
          stream.getTracks().forEach((track2) => {
            pc.addTrack(track2, stream);
          });
        } else {
          this.DebugChannel(`[WebRTC] Offer: I am attaching a receive-only video/audio transceiver to the connection with: ${username}`);
          pc.addTransceiver("video", { direction: "recvonly" });
          pc.addTransceiver("audio", { direction: "recvonly" });
        }
      }
      if (isOfferer) {
        this.DebugChannel(`[WebRTC] Offerer: create the offer and send it to ${username}`);
        pc.createOffer({
          offerToReceiveVideo: true,
          offerToReceiveAudio: true
        }).then(this.localDescCreated(pc, username)).catch(this.ChatClient);
      }
    },
    // Common handler function for
    localDescCreated(pc, username) {
      return (desc) => {
        pc.setLocalDescription(desc).then(() => {
          this.DebugChannel(`[WebRTC] Local description created; sending SDP message to ${username}:<br><br>${JSON.stringify(pc.localDescription)}`);
          this.client.send({
            action: "sdp",
            username,
            description: JSON.stringify(pc.localDescription)
          });
        }).catch((e) => {
          console.error(`Error sending WebRTC negotiation message (SDP): ${e}`);
        });
      };
    },
    // Handle inbound WebRTC signaling messages proxied by the websocket.
    onCandidate(msg) {
      if (this.WebRTC.pc[msg.username] == void 0 || !this.WebRTC.pc[msg.username].connecting) {
        return;
      }
      let pc = this.WebRTC.pc[msg.username].connecting;
      let candidate = JSON.parse(msg.candidate);
      this.DebugChannel(`[WebRTC] ICE candidate from ${msg.username}:<br><br>${msg.candidate}`);
      pc.addIceCandidate(candidate).catch((e) => {
        console.error(`addIceCandidate: ${e}`);
      });
    },
    onSDP(msg) {
      if (this.WebRTC.pc[msg.username] == void 0 || !this.WebRTC.pc[msg.username].connecting) {
        return;
      }
      let pc = this.WebRTC.pc[msg.username].connecting;
      this.DebugChannel(`[WebRTC] Received SDP message from ${msg.username}:<br><br>${msg.description}`);
      let message = JSON.parse(msg.description);
      pc.setRemoteDescription(new RTCSessionDescription(message)).then(() => {
        this.DebugChannel(`[WebRTC] <strong>setRemoteDescription</strong> called back OK!<br>Our pc.remoteDescription.type is: ${pc.remoteDescription.type}`);
        if (pc.remoteDescription.type === "offer") {
          this.DebugChannel(`[WebRTC] Answerer: create SDP answer message for ${msg.username}`);
          pc.createAnswer().then(this.localDescCreated(pc, msg.username)).catch(this.ChatClient);
        } else {
          this.DebugChannel(`[WebRTC] pc.remoteDescription.type was not 'offer', we do not need to create an SDP Answer message.`);
        }
      }).catch(this.DebugChannel);
    },
    onWatch(msg) {
      if (this.isBootedAdmin(msg.username))
        return;
      if (this.prefs.watchNotif && this.webcam.watching[msg.username] != true) {
        this.ChatServer(
          `<strong>${msg.username}</strong> is now watching your camera.`
        );
      }
      this.webcam.watching[msg.username] = true;
      this.playSound("Watch");
    },
    onUnwatch(msg) {
      delete this.webcam.watching[msg.username];
      this.playSound("Unwatch");
      this.cleanupPeerConnections();
    },
    sendWatch(username, watching) {
      this.client.send({
        action: watching ? "watch" : "unwatch",
        username
      });
    },
    isWatchingMe(username) {
      return this.webcam.watching[username] === true;
    },
    /**
     * Front-end web app concerns.
     */
    // Generic window.alert replacement modal.
    async modalAlert({ message, title = "Alert", icon = "", isConfirm = false }) {
      return new Promise((resolve2, reject) => {
        this.alertModal.isConfirm = isConfirm;
        this.alertModal.title = title;
        this.alertModal.icon = icon;
        this.alertModal.message = message;
        this.alertModal.callback = () => {
          resolve2();
        };
        this.alertModal.visible = true;
      });
    },
    async modalConfirm({ message, title = "Confirmation", icon = "" }) {
      return this.modalAlert({
        isConfirm: true,
        message,
        title,
        icon
      });
    },
    modalClose() {
      this.alertModal.visible = false;
    },
    // Settings modal.
    showSettings() {
      this.settingsModal.visible = true;
    },
    hideSettings() {
      this.settingsModal.visible = false;
    },
    // Set active chat room.
    setChannel(channel) {
      this.channel = typeof channel === "string" ? channel : channel.ID;
      this.scrollHistory(this.channel, true);
      if (this.channels[this.channel]) {
        this.channels[this.channel].unread = 0;
        this.channels[this.channel].urgent = false;
      }
      this.openChatPanel();
      this.makeLinksExternal();
      this.messageBox.focus();
    },
    hasAnyUnread() {
      let count = 0;
      for (let channel of Object.keys(this.channels)) {
        count += this.channels[channel].unread;
      }
      return count;
    },
    anyUnreadDMs() {
      for (let channel of Object.keys(this.channels)) {
        if (channel.indexOf("@") === 0 && this.channels[channel].unread > 0) {
          return true;
        }
      }
      return false;
    },
    openDMs(user) {
      let channel = "@" + user.username;
      this.initHistory(channel);
      this.initDirectMessageHistory(channel);
      this.setChannel(channel);
      this.openChatPanel();
    },
    openProfile(user) {
      let url = this.profileURLForUsername(user.username);
      if (url) {
        window.open(url);
      }
    },
    avatarURL(user) {
      if (user.avatar.match(/^https?:/i)) {
        return user.avatar;
      } else if (user.avatar.indexOf("/") === 0) {
        return this.config.website.replace(/\/+$/, "") + user.avatar;
      }
      return "";
    },
    getUser(username) {
      if (this.whoMap[username] != void 0) {
        return this.whoMap[username];
      }
      return {
        username
      };
    },
    isUserOffline(username) {
      return this.whoOnline[username] !== true && username !== "ChatServer" && username !== "ChatClient";
    },
    avatarForUsername(username) {
      if (this.whoMap[username] != void 0 && this.whoMap[username].avatar) {
        return this.avatarURL(this.whoMap[username]);
      }
      return null;
    },
    profileURLForUsername(username) {
      if (!username)
        return;
      username = username.replace(/^@/, "");
      if (this.whoMap[username] != void 0 && this.whoMap[username].profileURL) {
        let url = this.whoMap[username].profileURL;
        if (url.match(/^https?:/i)) {
          return url;
        } else if (url.indexOf("/") === 0) {
          return this.config.website.replace(/\/+$/, "") + url;
        } else {
          this.ChatClient("Didn't know how to open profile URL: " + url);
        }
        return url;
      }
      return null;
    },
    nicknameForUsername(username) {
      if (!username)
        return;
      username = username.replace(/^@/, "");
      if (this.whoMap[username] != void 0 && this.whoMap[username].profileURL) {
        let nick = this.whoMap[username].nickname;
        if (nick) {
          return nick;
        }
      }
      return username;
    },
    isUsernameDND(username) {
      if (!username)
        return false;
      return this.whoMap[username] != void 0 && this.whoMap[username].dnd;
    },
    isUsernameCamNSFW(username) {
      if (this.whoMap[username] != void 0 && this.whoMap[username].video & this.VideoFlag.NSFW) {
        return true;
      }
      return false;
    },
    leaveDM(channel) {
      if (channel.indexOf("@") !== 0)
        return;
      this.modalConfirm({
        title: "Close conversation thread",
        icon: "fa fa-trash",
        message: `Do you want to close this chat with ${channel}? This will remove the conversation from your view, but your chat partner may still have the conversation open on their device.`
      }).then(() => {
        this.setChannel(this.config.channels[0].ID);
        delete this.channels[channel];
        delete this.directMessageHistory[channel];
      });
    },
    /* Take back messages (for everyone) or remove locally */
    takeback(msg) {
      this.modalConfirm({
        title: "Take back message",
        icon: "fa fa-rotate-left",
        message: "Do you want to take this message back? Doing so will remove this message from everybody's view in the chat room."
      }).then(() => {
        this.client.send({
          action: "takeback",
          msgID: msg.msgID
        });
      });
    },
    removeMessage(msg) {
      this.modalConfirm({
        title: "Hide this message",
        icon: "fa fa-trash",
        message: "Do you want to remove this message from your view? This will delete the message only for you, but others in this chat thread may still see it."
      }).then(() => {
        this.onTakeback({
          msgID: msg.msgID
        });
      });
    },
    /* message reaction emojis */
    hasReactions(msg) {
      return this.messageReactions[msg.msgID] != void 0;
    },
    getReactions(msg) {
      if (!this.hasReactions(msg))
        return [];
      return this.messageReactions[msg.msgID];
    },
    iReacted(msg, emoji) {
      if (this.messageReactions[msg.msgID] != void 0 && this.messageReactions[msg.msgID][emoji] != void 0) {
        for (let reactor of this.messageReactions[msg.msgID][emoji]) {
          if (reactor === this.username) {
            return true;
          }
        }
      }
      return false;
    },
    // Start broadcasting my webcam.
    // - force=true to skip the NSFW modal prompt (this param is passed by the button in that modal)
    // - changeCamera=true to re-negotiate WebRTC connections with a new camera device (invoked by the Settings modal)
    startVideo({ force = false, changeCamera = false }) {
      if (this.webcam.busy)
        return;
      if (this.jwt.rules.IsNoBroadcastRule) {
        return this.modalAlert({
          title: "Broadcasting video is not allowed for you",
          message: this.config.strings.ModRuleErrorNoBroadcast || "A chat room moderation rule is currently in place which restricts your ability to broadcast your webcam.\n\nPlease contact a chat operator for more information."
        });
      }
      if (!changeCamera && !force) {
        this.getDevices();
      }
      if (!force) {
        this.nsfwModalCast.visible = true;
        return;
      }
      let mediaParams = {
        audio: true,
        video: {
          width: { ideal: WebcamWidth, max: WebcamMaxWidth },
          height: { ideal: WebcamHeight, max: WebcamMaxHeight }
        }
      };
      if (this.webcam.videoDeviceID) {
        mediaParams.video.deviceId = { exact: this.webcam.videoDeviceID };
      }
      if (this.webcam.audioDeviceID) {
        mediaParams.audio = {
          deviceId: { exact: this.webcam.audioDeviceID }
        };
      }
      this.webcam.busy = true;
      navigator.mediaDevices.getUserMedia(mediaParams).then((stream) => {
        this.webcam.active = true;
        this.webcam.elem.srcObject = stream;
        this.webcam.stream = stream;
        LocalStorage.set("videoMutual", this.webcam.mutual);
        LocalStorage.set("videoMutualOpen", this.webcam.mutualOpen);
        LocalStorage.set("videoAutoMute", this.webcam.autoMute);
        LocalStorage.set("videoVipOnly", this.webcam.vipOnly);
        LocalStorage.set("videoExplicit", this.webcam.nsfw);
        if (this.webcam.muted || this.webcam.autoMute) {
          this.webcam.stream.getAudioTracks().forEach((track2) => {
            track2.enabled = false;
          });
          this.webcam.muted = true;
        }
        this.sendMe();
        this.webcam.videoDeviceID = stream.getVideoTracks()[0].getSettings().deviceId;
        this.webcam.audioDeviceID = stream.getAudioTracks()[0].getSettings().deviceId;
        let videoSettings = stream.getVideoTracks()[0].getSettings();
        this.DebugChannel(`navigator.getUserMedia(): chosen video resolution is ${videoSettings.width}x${videoSettings.height}`);
        this.getDevices().then(() => {
          this.storePreferredDeviceNames();
        });
        if (changeCamera) {
          this.updateWebRTCStreams();
        }
        this.initDarkVideoDetection();
        this.initSpeakingEvents(this.username, this.webcam.elem);
      }).catch((err) => {
        this.ChatClient(`Webcam error: ${err}<br><br>Please see the <a href="/about#troubleshooting">troubleshooting guide</a> for help.`);
      }).finally(() => {
        this.webcam.busy = false;
      });
    },
    getDevices() {
      var _a;
      if (!((_a = navigator.mediaDevices) == null ? void 0 : _a.enumerateDevices)) {
        console.log("enumerateDevices() not supported.");
        return;
      }
      this.webcam.gettingDevices = true;
      return navigator.mediaDevices.enumerateDevices().then((devices) => {
        this.webcam.videoDevices = [];
        this.webcam.audioDevices = [];
        devices.forEach((device) => {
          if (!device.label) {
            return;
          }
          if (device.kind === "videoinput") {
            this.webcam.videoDevices.push({
              id: device.deviceId,
              label: device.label
            });
          } else if (device.kind === "audioinput") {
            this.webcam.audioDevices.push({
              id: device.deviceId,
              label: device.label
            });
          }
        });
        if (!this.webcam.videoDeviceID && this.webcam.preferredDeviceNames.video) {
          for (let dev of this.webcam.videoDevices) {
            if (dev.label === this.webcam.preferredDeviceNames.video) {
              this.webcam.videoDeviceID = dev.id;
            }
          }
        }
        if (!this.webcam.audioDeviceID && this.webcam.preferredDeviceNames.audio) {
          for (let dev of this.webcam.audioDevices) {
            if (dev.label === this.webcam.preferredDeviceNames.audio) {
              this.webcam.audioDeviceID = dev.id;
            }
          }
        }
      }).catch((err) => {
        this.ChatClient(`Error listing your cameras and microphones: ${err.name}: ${err.message}`);
      }).finally(() => {
        setTimeout(() => {
          this.webcam.gettingDevices = false;
        }, 500);
      });
    },
    storePreferredDeviceNames() {
      if (this.webcam.videoDeviceID) {
        for (let dev of this.webcam.videoDevices) {
          if (dev.id === this.webcam.videoDeviceID && dev.label) {
            this.webcam.preferredDeviceNames.video = dev.label;
          }
        }
      }
      if (this.webcam.audioDeviceID) {
        for (let dev of this.webcam.audioDevices) {
          if (dev.id === this.webcam.audioDeviceID && dev.label) {
            this.webcam.preferredDeviceNames.audio = dev.label;
          }
        }
      }
      LocalStorage.set("preferredDeviceNames", this.webcam.preferredDeviceNames);
    },
    // The 'Explicit' button at the top of the page: toggle the user's NSFW setting but
    // with some smarts in case the user was just marked NSFW by an admin.
    topNavExplicitButtonClicked() {
      if (this.webcam.wasServerNSFW) {
        this.webcam.wasServerNSFW = false;
        this.ChatClient(
          `Notice: your webcam was already marked as "Explicit" recently by the chat server.<br><br>If you were recently notified that a chat moderator has marked your camera as 'explicit' (red) for you, then you do not need to do anything: your camera is marked Explicit already. Please leave it as Explicit if you are being sexual on camera.<br><br>If you really mean to <strong>remove</strong> the Explicit label (and turn your camera 'blue'), then click on the Explicit button at the top of the page one more time to confirm.`
        );
        return;
      }
      this.webcam.nsfw = !this.webcam.nsfw;
    },
    // Replace your video/audio streams for your watchers (on camera changes)
    updateWebRTCStreams() {
      console.log("Re-negotiating video and audio channels to your watchers.");
      for (let username of Object.keys(this.WebRTC.pc)) {
        let pc = this.WebRTC.pc[username];
        if (pc.answerer != void 0) {
          let oldTracks = pc.answerer.getSenders();
          let newTracks = this.webcam.stream.getTracks();
          for (let old of oldTracks) {
            if (old.track.kind === "audio") {
              for (let replace of newTracks) {
                if (replace.kind === "audio") {
                  old.replaceTrack(replace);
                }
              }
            } else if (old.track.kind === "video") {
              for (let replace of newTracks) {
                if (replace.kind === "video") {
                  old.replaceTrack(replace);
                }
              }
            }
          }
        }
      }
    },
    // Begin connecting to someone else's webcam.
    openVideoByUsername(username, force) {
      if (this.whoMap[username] != void 0) {
        this.openVideo(this.whoMap[username], force);
        return;
      }
      this.ChatClient("Couldn't open video by username: not found.");
    },
    setSkipNSFWModal() {
      LocalStorage.set("skip-nsfw-modal", true);
    },
    openVideo(user, force) {
      this.nsfwModalView.visible = false;
      if (user.username === this.username) {
        this.ChatClient("You can already see your own webcam.");
        return;
      }
      if (this.jwt.rules.IsNoVideoRule) {
        return this.modalAlert({
          title: "Videos are not available to you",
          message: this.config.strings.ModRuleErrorNoVideo || "A chat room moderation rule is currently in place which restricts your ability to watch webcams.\n\nPlease contact a chat operator for more information."
        });
      }
      if (this.isMutedUser(user.username) && !this.isOp) {
        this.ChatClient(`You have muted <strong>${user.username}</strong> and so should not see their camera.`);
        return;
      }
      if (this.isBooted(user.username) && !this.isOp) {
        this.ChatClient(`You had kicked <strong>${user.username}</strong> off your camera and so it wouldn't be right to still watch their camera.`);
        return;
      }
      let dontShowAgain = LocalStorage.get("skip-nsfw-modal") === true;
      if (user.video & this.VideoFlag.NSFW && !dontShowAgain && !force) {
        this.nsfwModalView.user = user;
        this.nsfwModalView.visible = true;
        return;
      }
      delete this.WebRTC.expresslyClosed[user.username];
      if (this.WebRTC.debounceOpens[user.username])
        return;
      this.WebRTC.debounceOpens[user.username] = true;
      setTimeout(() => {
        delete this.WebRTC.debounceOpens[user.username];
      }, 5e3);
      if (this.WebRTC.pc[user.username] != void 0 && this.WebRTC.pc[user.username].offerer != void 0) {
        this.DebugChannel(`OpenVideo(${user.username}): already had a connection open, closing it first.`);
        this.closeVideo(user.username, "offerer");
      }
      if (this.isVideoNotAllowed(user) && !this.isOp) {
        this.ChatClient(
          `<strong>${user.username}</strong> has requested that you should share your own camera too before opening theirs.`
        );
        return;
      }
      if (this.WebRTC.openTimeouts[user.username] != void 0) {
        clearTimeout(this.WebRTC.openTimeouts[user.username]);
        delete this.WebRTC.openTimeouts[user.username];
      }
      this.WebRTC.openTimeouts[user.username] = setTimeout(() => {
        this.ChatClient(
          `There was an error opening <strong>${user.username}</strong>'s camera.`
        );
        delete this.WebRTC.openTimeouts[user.username];
      }, 1e4);
      this.sendOpen(user.username);
      this.openChatPanel();
    },
    closeVideo(username, name) {
      delete this.WebRTC.frozenStreamDetected[username];
      if (this.WebRTC.frozenStreamInterval[username]) {
        clearInterval(this.WebRTC.frozenStreamInterval[username]);
        delete this.WebRTC.frozenStreamInterval[username];
      }
      if (name === "offerer") {
        delete this.WebRTC.streams[username];
        delete this.WebRTC.muted[username];
        delete this.WebRTC.poppedOut[username];
        if (this.WebRTC.pc[username] != void 0 && this.WebRTC.pc[username].offerer != void 0) {
          if (this.webcam.mutualOpen && this.isWatchingMe(username)) {
            console.log(`OFFERER(${username}): Close video locally only: do not hang up the connection.`);
          } else {
            this.WebRTC.pc[username].offerer.close();
            delete this.WebRTC.pc[username];
          }
        }
        this.sendWatch(username, false);
        this.cleanupPeerConnections();
        return;
      } else if (name === "answerer") {
        if (this.WebRTC.pc[username] != void 0 && this.WebRTC.pc[username].answerer != void 0) {
          if (this.webcam.mutualOpen && this.isWatchingMe(username)) {
            console.log(`ANSWERER(${username}): Close video locally only: do not hang up the connection.`);
          } else {
            this.WebRTC.pc[username].answerer.close();
            delete this.WebRTC.pc[username];
          }
        }
        this.cleanupPeerConnections();
        return;
      }
      delete this.WebRTC.streams[username];
      delete this.webcam.watching[username];
      if (this.WebRTC.pc[username] != void 0) {
        if (this.WebRTC.pc[username].offerer) {
          this.WebRTC.pc[username].offerer.close();
        }
        if (this.WebRTC.pc[username].answerer) {
          this.WebRTC.pc[username].answerer.close();
        }
        delete this.WebRTC.pc[username];
        delete this.WebRTC.muted[username];
        delete this.WebRTC.poppedOut[username];
      }
      delete this.WebRTC.frozenStreamDetected[username];
      if (this.WebRTC.frozenStreamInterval[username]) {
        clearInterval(this.WebRTC.frozenStreamInterval[username]);
        delete this.WebRTC.frozenStreamInterval[username];
      }
      this.sendWatch(username, false);
      this.cleanupPeerConnections();
    },
    expresslyCloseVideo(username, name) {
      this.WebRTC.expresslyClosed[username] = true;
      return this.closeVideo(username, name);
    },
    closeOpenVideos() {
      for (let username of Object.keys(this.WebRTC.streams)) {
        this.closeVideo(username, "offerer");
      }
    },
    cleanupPeerConnections() {
      for (let username of Object.keys(this.WebRTC.pc)) {
        let pc = this.WebRTC.pc[username];
        if (this.WebRTC.streams[username] != void 0) {
          continue;
        }
        if (this.isWatchingMe(username)) {
          continue;
        }
        if (this.isBootedAdmin(username)) {
          continue;
        }
        if (pc.answerer != void 0) {
          console.log("Clean up WebRTC answerer connection with " + username);
          pc.answerer.close();
          delete this.WebRTC.pc[username];
        }
        if (pc.offerer != void 0) {
          console.log("Clean up WebRTC offerer connection with " + username);
          pc.offerer.close();
          delete this.WebRTC.pc[username];
        }
      }
    },
    muteAllVideos() {
      let count = 0;
      for (let username of Object.keys(this.WebRTC.streams)) {
        if (this.WebRTC.muted[username])
          continue;
        this.WebRTC.muted[username] = true;
        let $ref = document.getElementById(`videofeed-${username}`);
        if ($ref) {
          $ref.muted = this.WebRTC.muted[username];
        }
        count++;
      }
      if (count > 0) {
        this.ChatClient(`You have muted the audio on ${count} video${count === 1 ? "" : "s"}.`);
      }
    },
    unMutualVideo() {
      if (this.webcam.active)
        return;
      for (let row of this.whoList) {
        let username = row.username;
        if (row.video & this.VideoFlag.MutualRequired && this.WebRTC.pc[username] != void 0) {
          this.closeVideo(username);
        }
      }
    },
    webcamIconClass(user) {
      if (user.username === this.username && this.webcam.active) {
        return "fa-eye";
      }
      if (this.WebRTC.openTimeouts[user.username] != void 0) {
        return "fa-spinner fa-spin";
      }
      if (this.WebRTC.pc[user.username] != void 0 && this.WebRTC.streams[user.username] != void 0) {
        return "fa-eye";
      }
      if (this.isVideoNotAllowed(user))
        return "fa-video-slash";
      return "fa-video";
    },
    isUsernameOnCamera(username) {
      return this.whoMap[username].video & VideoFlag.Active;
    },
    webcamButtonClass(username) {
      let video = this.whoMap[username].video;
      if (!(video & VideoFlag.Active)) {
        return "";
      }
      if (video & VideoFlag.NSFW) {
        return "is-danger";
      }
      return "is-link";
    },
    isVideoNotAllowed(user) {
      if (this.jwt.rules.IsNoVideoRule)
        return true;
      if (user.video & this.VideoFlag.Active && user.video & this.VideoFlag.MutualRequired) {
        if (this.webcam.active && this.isVIP && this.webcam.vipOnly && this.whoMap[user.username] != void 0 && !this.whoMap[user.username].vip) {
          return true;
        }
        if (!this.webcam.active) {
          return true;
        }
      }
      if (this.isMutedUser(user.username) || this.isBooted(user.username)) {
        return true;
      }
      return false;
    },
    // Show who watches our video.
    showViewers() {
      let users = Object.keys(this.webcam.watching);
      if (users.length === 0) {
        this.ChatClient("There is currently nobody viewing your camera.");
      } else {
        this.ChatClient("Your current webcam viewers are:<br><br>" + users.join(", "));
      }
      this.whoTab = "watching";
      if (screen.width < 1024) {
        this.openWhoPanel();
      }
    },
    // Boot someone off your video.
    bootUser(username) {
      if (this.isBooted(username)) {
        this.modalConfirm({
          title: "Unboot user",
          icon: "fa fa-user-xmark",
          message: `Allow ${username} to watch your webcam again?`
        }).then(() => {
          this.sendUnboot(username);
          delete this.WebRTC.booted[username];
        });
        return;
      }
      this.modalConfirm({
        title: "Boot user",
        icon: "fa fa-user-xmark",
        message: `Kick ${username} off your camera? This will also prevent them from seeing that your camera is active for the remainder of your chat session.`
      }).then(() => {
        this.sendBoot(username);
        this.WebRTC.booted[username] = true;
        if (this.WebRTC.pc[username] != void 0) {
          this.closeVideo(username);
        }
        delete this.webcam.watching[username];
        this.ChatClient(
          `You have booted ${username} off your camera. They will no longer be able to connect to your camera, or even see that your camera is active at all -- to them it appears as though you had turned yours off.<br><br>This will be in place for the remainder of your time in chat, until you log off.`
        );
      });
    },
    isBooted(username) {
      return this.WebRTC.booted[username] === true;
    },
    isBootedAdmin(username) {
      return (this.WebRTC.booted[username] === true || this.muted[username] === true) && this.whoMap[username] != void 0 && this.whoMap[username].op;
    },
    // Stop broadcasting.
    stopVideo() {
      this.stopDarkVideoDetection();
      for (let username of Object.keys(this.WebRTC.pc)) {
        this.closeVideo(username, "answerer");
      }
      this.unMutualVideo();
      this.webcam.stream.getTracks().forEach((track2) => {
        track2.stop();
      });
      this.webcam.elem.srcObject = null;
      this.webcam.stream = null;
      this.webcam.active = false;
      this.webcam.muted = false;
      this.whoTab = "online";
      this.sendMe();
    },
    // Mute my microphone if broadcasting.
    muteMe() {
      this.webcam.muted = !this.webcam.muted;
      this.webcam.stream.getAudioTracks().forEach((track2) => {
        track2.enabled = !this.webcam.muted;
      });
      this.sendMe();
    },
    isSourceMuted(username) {
      if (this.whoMap[username] != void 0 && this.whoMap[username].video & this.VideoFlag.Muted) {
        return true;
      }
      return false;
    },
    isMuted(username) {
      return this.WebRTC.muted[username] === true;
    },
    muteVideo(username) {
      this.WebRTC.muted[username] = !this.isMuted(username);
      let $ref = document.getElementById(`videofeed-${username}`);
      if ($ref) {
        $ref.muted = this.WebRTC.muted[username];
      }
    },
    setVideoVolume(username, volume) {
      let $ref = document.getElementById(`videofeed-${username}`);
      if ($ref) {
        $ref.volume = volume / 100;
      }
    },
    // Pop out a user's video.
    popoutVideo(username) {
      this.WebRTC.poppedOut[username] = !this.WebRTC.poppedOut[username];
      window.requestAnimationFrame(this.makeDraggableVideos);
    },
    // Outside of Vue, attach draggable video scripts to DOM.
    makeDraggableVideos() {
      let $panel = document.querySelector("#video-feeds");
      interact(".popped-in").unset();
      window.requestAnimationFrame(() => {
        document.querySelectorAll(".popped-out").forEach((node) => {
          document.body.appendChild(node);
        });
        document.querySelectorAll(".popped-in").forEach((node) => {
          $panel.appendChild(node);
          node.style.top = null;
          node.style.left = null;
          node.setAttribute("data-x", 0);
          node.setAttribute("data-y", 0);
        });
      });
      interact(".popped-out").draggable({
        // enable inertial throwing
        inertia: true,
        // keep the element within the area of it's parent
        modifiers: [
          interact.modifiers.restrictRect({
            restriction: "parent",
            endOnly: true
          })
        ],
        listeners: {
          // call this function on every dragmove event
          move(event) {
            let target = event.target;
            let x2 = (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
            let y2 = (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;
            target.style.top = `${y2}px`;
            target.style.left = `${x2}px`;
            target.setAttribute("data-x", x2);
            target.setAttribute("data-y", y2);
          },
          // call this function on every dragend event
          end(event) {
            console.log(
              "moved a distance of " + Math.sqrt(Math.pow(event.pageX - event.x0, 2) + Math.pow(event.pageY - event.y0, 2) | 0).toFixed(2) + "px"
            );
          }
        }
      }).resizable({
        edges: { left: true, right: true, bottom: true, right: true },
        listeners: {
          move(event) {
            var target = event.target;
            var x2 = parseFloat(target.getAttribute("data-x")) || 0;
            var y2 = parseFloat(target.getAttribute("data-y")) || 0;
            target.style.width = event.rect.width + "px";
            target.style.height = event.rect.height + "px";
            x2 += event.deltaRect.left;
            y2 += event.deltaRect.top;
            target.style.top = `${y2}px`;
            target.style.left = `${x2}px`;
            target.setAttribute("data-x", x2);
            target.setAttribute("data-y", y2);
          }
        },
        modifiers: [
          // keep the edges inside the parent
          interact.modifiers.restrictEdges({
            outer: "parent"
          }),
          // minimum size
          interact.modifiers.restrictSize({
            min: { width: 100, height: 50 }
          })
        ],
        inertia: true
      });
    },
    // Webcam "is speaking" functions.
    initSpeakingEvents(username, element) {
      let stream = element.srcObject, feedElem = element.closest("div.feed"), options = {}, speechEvents = hark$1(stream, options);
      speechEvents.on("speaking", () => {
        feedElem.classList.add("is-speaking");
        this.WebRTC.speaking[username] = true;
      });
      speechEvents.on("stopped_speaking", () => {
        feedElem.classList.remove("is-speaking");
        this.WebRTC.speaking[username] = false;
      });
    },
    // Dark video detection.
    initDarkVideoDetection() {
      if (this.webcam.darkVideo.canvas === null) {
        let canvas = document.querySelector("#darkVideoCanvas"), ctx = canvas.getContext("2d");
        canvas.width = WebcamWidth;
        canvas.height = WebcamHeight;
        this.webcam.darkVideo.canvas = canvas;
        this.webcam.darkVideo.ctx = ctx;
      }
      if (this.webcam.darkVideo.interval !== null) {
        clearInterval(this.webcam.darkVideo.interval);
      }
      this.webcam.darkVideo.interval = setInterval(() => {
        this.darkVideoInterval();
      }, 5e3);
    },
    stopDarkVideoDetection() {
      if (this.webcam.darkVideo.interval !== null) {
        clearInterval(this.webcam.darkVideo.interval);
      }
    },
    darkVideoInterval() {
      if (!this.webcam.active) {
        this.stopDarkVideoDetection();
        return;
      }
      let canvas = this.webcam.darkVideo.canvas, ctx = this.webcam.darkVideo.ctx;
      ctx.drawImage(this.webcam.elem, 0, 0, canvas.width, canvas.height);
      let img = canvas.toDataURL("image/jpeg");
      this.webcam.darkVideo.lastImage = img;
      let rgb = this.getAverageRGB(ctx);
      if (rgb === null) {
        return;
      }
      this.webcam.darkVideo.lastAverage = rgb;
      this.webcam.darkVideo.lastAverageColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 1)`;
      if (this.jwt.rules.IsNoDarkVideoRule)
        return;
      let averageBrightness = Math.floor((rgb[0] + rgb[1] + rgb[2]) / 3);
      if (averageBrightness < this.webcam.darkVideo.threshold) {
        if (this.wasTooDark) {
          this.stopVideo();
          this.ChatClient(`
                        Your webcam was too dark to see anything and has been turned off.<br><br>
                        <strong>Note:</strong> if your camera did not look dark to you and you believe there
                        may have been an error, please
                        <button type="button" onclick="SendMessage('/debug-dark-video')" class="button is-small is-link is-outlined">click here</button> to see
                        diagnostic information and contact a chat room moderator for assistance.
                    `);
        } else {
          this.wasTooDark = true;
        }
      } else {
        this.wasTooDark = false;
      }
    },
    getAverageRGB(ctx) {
      const blockSize = 16;
      let img = null, rgb = [0, 0, 0];
      try {
        img = ctx.getImageData(0, 0, WebcamWidth, WebcamHeight);
      } catch (e) {
        return null;
      }
      let length = img.data.length, i2 = 0, count = 0, firstColor = [], allSame = true;
      while ((i2 += blockSize * 4) < length) {
        count++;
        let thisColor = [
          img.data[i2],
          img.data[i2 + 1],
          img.data[i2 + 2]
        ];
        rgb[0] += thisColor[0];
        rgb[1] += thisColor[1];
        rgb[2] += thisColor[2];
        if (firstColor.length === 0) {
          firstColor = [rgb[0], rgb[1], rgb[2]];
        } else if (allSame) {
          if (firstColor[0] !== thisColor[0] || firstColor[1] !== thisColor[1] || firstColor[2] !== thisColor[2]) {
            allSame = false;
          }
        }
      }
      if (allSame) {
        return [0, 0, 0];
      }
      rgb[0] = Math.floor(rgb[0] / count);
      rgb[1] = Math.floor(rgb[1] / count);
      rgb[2] = Math.floor(rgb[2] / count);
      return rgb;
    },
    initHistory(channel) {
      if (this.channels[channel] == void 0) {
        this.channels[channel] = {
          history: [],
          updated: Date.now(),
          unread: 0,
          urgent: false
        };
      }
    },
    pushHistory({ channel, username, message, action = "message", isChatServer, isChatClient, messageID, timestamp = null, unshift = false }) {
      if (isChatServer && (message.match(/ has booted you off of their camera!$/) || message.match(/ had booted you off their camera before, and won't be notified of your watch.$/))) {
        channel = DebugChannelID;
      }
      if (!channel) {
        channel = this.channel;
      }
      if (timestamp === null) {
        timestamp = /* @__PURE__ */ new Date();
      } else {
        timestamp = new Date(timestamp);
      }
      if (this.prefs.closeDMs && channel.indexOf("@") === 0) {
        let isSenderOp = this.whoMap[username] != void 0 && this.whoMap[username].op;
        if (username !== this.username && this.channels[channel] == void 0 && !isSenderOp)
          return;
      }
      this.initHistory(channel);
      if (message.indexOf("<img") > -1) {
        if (this.jwt.rules.IsNoImageRule) {
          message = `
                        <span class="has-text-danger barertc-no-emoji-reactions">
                            <i class="fa fa-image mr-1"></i>
                            An image was shared, but is not visible to you due to a chat moderation rule on your account.
                        </span>`;
        } else if (this.imageDisplaySetting === "hide") {
          return;
        } else if (this.imageDisplaySetting === "collapse") {
          let collapseID = `collapse-${messageID}`;
          if (!messageID) {
            collapseID = "collapse-missingno-" + parseInt(Math.random() * 1e5);
          }
          message = `
                        <a href="#" id="img-show-${collapseID}"
                            class="button is-outlined is-small is-info"
                            onclick="document.querySelector('#img-${collapseID}').style.display = 'block';
                                     document.querySelector('#img-show-${collapseID}').style.display = 'none';
                                     return false">
                            <i class="fa fa-image mr-1"></i>
                            Image attachment - click to expand
                        </a>
                        <div id="img-${collapseID}" style="display: none">${message}</div>`;
        }
        message = message.replace(/<img /g, `<img oncontextmenu="return false" `);
      }
      if (message.indexOf("@" + this.username) > -1) {
        let re2 = new RegExp("@" + this.username + "\\b", "ig");
        message = message.replace(re2, `<strong class="has-background-at-mention">@${this.username}</strong>`);
        if (channel.indexOf("@") !== 0 && (this.channel !== channel || !this.windowFocused)) {
          this.playSound("Mentioned");
          this.channels[channel].urgent = true;
        }
      }
      message = message.replace(/@(here|all)\b/ig, `<strong class="has-background-at-mention">@$1</strong>`);
      let toAppend = {
        action,
        channel,
        username,
        message,
        msgID: messageID,
        at: timestamp,
        isChatServer,
        isChatClient
      };
      this.channels[channel].updated = (/* @__PURE__ */ new Date()).getTime();
      if (unshift) {
        this.channels[channel].history.unshift(toAppend);
      } else {
        this.channels[channel].history.push(toAppend);
      }
      if (this.scrollback > 0 && this.channels[channel].history.length > this.scrollback) {
        this.channels[channel].history = this.channels[channel].history.slice(
          -this.scrollback,
          this.channels[channel].history.length + 1
        );
      }
      if (!unshift) {
        this.scrollHistory(channel);
      }
      if (this.channel !== channel || !this.windowFocused) {
        if (channel !== DebugChannelID && // don't notify about debug channel
        action !== "presence" && action !== "notification" && !isChatServer && !unshift) {
          this.channels[channel].unread++;
        }
      }
      this.makeLinksExternal();
    },
    scrollHistory(channel, force) {
      if (!this.autoscroll && !force)
        return;
      window.requestAnimationFrame(() => {
        if (channel !== this.channel)
          return;
        if (this.historyScrollbox === null)
          return;
        this.historyScrollbox.scroll({
          top: this.historyScrollbox.scrollHeight,
          behavior: "smooth"
        });
      });
    },
    // Responsive CSS controls for mobile. Notes for maintenance:
    // - The chat.css has responsive CSS to hide the left/right panels
    //   and set the grid-template-columns for devices < 1024px width
    // - These functions override w/ style tags to force the drawer to
    //   be visible and change the grid-template-columns.
    // - On window resize (e.g. device rotation) or when closing one
    //   of the side drawers, we reset our CSS overrides to default so
    //   the main chat window reappears.
    openChannelsPanel() {
      let $container = this.responsive.nodes.$container, $drawer = this.responsive.nodes.$left;
      $container.style.gridTemplateColumns = "1fr 0 0";
      $drawer.style.display = "block";
    },
    openWhoPanel() {
      let $container = this.responsive.nodes.$container, $drawer = this.responsive.nodes.$right;
      $container.style.gridTemplateColumns = "0 0 1fr";
      $drawer.style.display = "block";
    },
    openChatPanel() {
      this.resetResponsiveCSS();
    },
    resetResponsiveCSS() {
      let $container = this.responsive.nodes.$container, $left = this.responsive.nodes.$left, $right = this.responsive.nodes.$right;
      $left.style.removeProperty("display");
      $right.style.removeProperty("display");
      $container.style.removeProperty("grid-template-columns");
    },
    // Send a chat message as ChatServer
    ChatServer(message) {
      this.pushHistory({
        username: "ChatServer",
        message,
        isChatServer: true
      });
    },
    ChatClient(message) {
      this.pushHistory({
        username: "ChatClient",
        message,
        isChatClient: true
      });
    },
    DebugChannel(message) {
      this.pushHistory({
        channel: DebugChannelID,
        username: "ChatClient",
        message,
        isChatClient: true
      });
    },
    // CSS classes for the profile button (color coded genders)
    profileButtonClass(user) {
      let result = "";
      if (user.vip) {
        result = "has-background-vip ";
      }
      let gender = (user.gender || "").toLowerCase();
      if (gender.indexOf("m") === 0) {
        return result + "has-text-gender-male";
      } else if (gender.indexOf("f") === 0) {
        return result + "has-text-gender-female";
      } else if (gender.length > 0) {
        return result + "has-text-gender-other";
      }
      return "";
    },
    /**
     * Image sharing in chat
     */
    // Set up the HTML5 drag/drop handlers.
    setupDropZone() {
      let $dropArea = document.querySelector("#drop-modal");
      let $body = document.querySelector("body");
      $body.addEventListener("dragstart", (e) => {
        e.preventDefault();
        return false;
      });
      $body.addEventListener("dragenter", (e) => {
        e.preventDefault();
        e.stopPropagation();
        $dropArea.classList.add("is-active");
      });
      $body.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.stopPropagation();
        $dropArea.classList.add("is-active");
      });
      $body.addEventListener("dragleave", (e) => {
        e.preventDefault();
        e.stopPropagation();
        $dropArea.classList.remove("is-active");
      });
      $body.addEventListener("drop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        $dropArea.classList.remove("is-active");
        let dt2 = e.dataTransfer;
        let file = dt2.files[0];
        this.onFileUpload(file);
      });
    },
    // Common file selection handler for drag/drop or manual upload.
    onFileUpload(file) {
      if (!this.canUploadFile) {
        this.ChatClient("Photo sharing in this channel is not available.");
        return;
      }
      let msg = {
        action: "file",
        channel: this.channel
      };
      if (file.size > FileUploadMaxSize) {
        this.ChatClient(`Please share an image smaller than ${FileUploadMaxSize / 1024 / 1024} MB in size!`);
        return;
      }
      this.ChatClient(`<em>Uploading file to chat: ${file.name} - ${file.size} bytes, ${file.type} format.</em>`);
      let reader = new FileReader();
      let rawData = new ArrayBuffer();
      reader.onload = (e) => {
        rawData = e.target.result;
        let fileByteArray = [], u8array = new Uint8Array(rawData);
        for (let i2 = 0; i2 < u8array.length; i2++) {
          fileByteArray.push(u8array[i2]);
        }
        msg.message = file.name;
        msg.bytes = fileByteArray;
        this.client.send(msg);
      };
      reader.readAsArrayBuffer(file);
    },
    // The image upload button handler.
    uploadFile() {
      let input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = (e) => {
        let file = e.target.files[0];
        this.onFileUpload(file);
      };
      input.click();
    },
    // Invoke the Profile Modal
    showProfileModal(username) {
      if (this.whoMap[username] != void 0) {
        this.profileModal.user = this.whoMap[username];
        this.profileModal.username = username;
        this.profileModal.visible = true;
      }
    },
    // Scale the video zoom setting up or down.
    scaleVideoSize(bigger) {
      let currentSize = 0;
      for (let option of this.webcam.videoScaleOptions) {
        if (option[0] === this.webcam.videoScale) {
          break;
        }
        currentSize++;
      }
      if (bigger) {
        currentSize++;
      } else {
        currentSize--;
      }
      if (currentSize < 0) {
        currentSize = 0;
      } else if (currentSize >= this.webcam.videoScaleOptions.length) {
        currentSize = this.webcam.videoScale.length - 1;
      }
      this.webcam.videoScale = this.webcam.videoScaleOptions[currentSize][0];
    },
    /**
     * Sound effect concerns.
     */
    setupSounds() {
      if (this.config.sounds.audioContext) {
        if (this.config.sounds.audioContext.state === "suspended") {
          this.config.sounds.audioContext.resume();
        }
        return;
      }
      try {
        if (AudioContext) {
          this.config.sounds.audioContext = new AudioContext();
        } else {
          this.config.sounds.audioContext = window.AudioContext || window.webkitAudioContext;
        }
      } catch {
      }
      if (!this.config.sounds.audioContext) {
        console.error("Couldn't set up AudioContext! No sound effects will be supported.");
        return;
      }
      for (let effect2 of this.config.sounds.available) {
        if (!effect2.filename)
          continue;
        let elem = document.createElement("audio");
        elem.autoplay = false;
        elem.src = `/static/sfx/${effect2.filename}`;
        document.body.appendChild(elem);
        let track2 = this.config.sounds.audioContext.createMediaElementSource(elem);
        track2.connect(this.config.sounds.audioContext.destination);
        this.config.sounds.audioTracks[effect2.name] = elem;
      }
      for (let setting of Object.keys(this.config.sounds.settings)) {
        if (localStorage[`sound:${setting}`] != void 0) {
          this.config.sounds.settings[setting] = localStorage[`sound:${setting}`];
        }
      }
    },
    playSound(event) {
      if (this.prefs.muteSounds)
        return;
      let filename = this.config.sounds.settings[event];
      if (this.config.sounds.audioTracks[filename] != void 0) {
        let track2 = this.config.sounds.audioTracks[filename];
        track2.play();
      }
    },
    setSoundPref(event) {
      this.playSound(event);
      localStorage[`sound:${event}`] = this.config.sounds.settings[event];
    },
    // Make all links in chat open in new windows
    makeLinksExternal() {
      window.requestAnimationFrame(() => {
        let $history = document.querySelector("#chatHistory");
        if ($history === null)
          return;
        ($history.querySelectorAll("a") || []).forEach((node) => {
          let href = node.attributes.href, target = node.attributes.target;
          if (href == void 0 || target != void 0)
            return;
          node.target = "_blank";
        });
      });
    },
    /*
     * Idle Detection methods
     */
    setupIdleDetection() {
      window.addEventListener("keypress", this.deidle);
      window.addEventListener("mousemove", this.deidle);
    },
    // Common "de-idle" event handler
    deidle(e) {
      if (this.status === "idle") {
        this.status = "online";
      }
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
      }
      this.idleTimeout = setTimeout(this.goIdle, 1e3 * this.idleThreshold);
    },
    goIdle() {
      if (this.status === "online") {
        this.status = "idle";
      }
    },
    /*
     * Direct Message History Loading
     */
    initDirectMessageHistory(channel, ignoreID) {
      if (this.directMessageHistory[channel] == void 0) {
        this.directMessageHistory[channel] = {
          busy: false,
          beforeID: 0,
          ignoreID,
          remaining: -1
        };
        let disclaimer = this.config.dmDisclaimer;
        this.pushHistory({
          channel,
          username: "ChatServer",
          message: disclaimer,
          action: "notification"
        });
        window.requestAnimationFrame(() => {
          this.loadDirectMessageHistory(channel).then(() => {
            setTimeout(() => {
              this.scrollHistory(channel);
            }, 200);
          });
        });
      }
    },
    async loadDirectMessageHistory(channel) {
      if (!this.jwt.valid)
        return;
      this.directMessageHistory[channel].busy = true;
      return fetch("/api/message/history", {
        method: "POST",
        mode: "same-origin",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          "JWTToken": this.jwt.token,
          "Username": this.normalizeUsername(channel),
          "BeforeID": this.directMessageHistory[channel].beforeID
        })
      }).then((response) => response.json()).then((data) => {
        if (data.Error) {
          console.error("DirectMessageHistory: ", data.Error);
          return;
        }
        if (data.Messages.length === 0) {
          this.directMessageHistory[channel].remaining = data.Remaining;
          return;
        }
        if (this.directMessageHistory[channel].remaining === -1) {
          this.pushHistory({
            channel,
            username: "ChatServer",
            action: "presence",
            message: "Messages from your past chat session are available above this line.",
            unshift: true
          });
        }
        let beforeID = 0;
        for (let msg of data.Messages) {
          beforeID = msg.msgID;
          if (msg.msgID === this.directMessageHistory[channel].ignoreID) {
            continue;
          }
          this.pushHistory({
            channel,
            username: msg.username,
            message: msg.message,
            messageID: msg.msgID,
            timestamp: msg.timestamp,
            unshift: true
          });
        }
        this.directMessageHistory[channel].remaining = data.Remaining;
        this.directMessageHistory[channel].beforeID = beforeID;
      }).catch((resp) => {
        console.error("DirectMessageHistory: ", resp);
      }).finally(() => {
        this.directMessageHistory[channel].busy = false;
      });
    },
    async clearMessageHistory() {
      if (!this.jwt.valid || this.clearDirectMessages.busy)
        return;
      this.modalConfirm({
        title: "Clear all DMs",
        icon: "fa fa-exclamation-triangle",
        message: "This will delete all of your DMs history stored on the server. People you have chatted with will have their past messages sent to you erased as well.\n\nNote: messages that are currently displayed on your chat partner's screen will NOT be removed by this action -- if this is a concern and you want to 'take back' a message from their screen, use the 'take back' button (red arrow circle) on the message you sent to them. The 'clear history' button only clears the database, but does not send takebacks to pull the message from everybody else's screen.\n\nAre you sure you want to clear your stored DMs history on the server?"
      }).then(async () => {
        if (this.clearDirectMessages.timeout !== null) {
          clearTimeout(this.clearDirectMessages.timeout);
        }
        this.clearDirectMessages.busy = true;
        return fetch("/api/message/clear", {
          method: "POST",
          mode: "same-origin",
          cache: "no-cache",
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            "JWTToken": this.jwt.token
          })
        }).then((response) => response.json()).then((data) => {
          if (data.Error) {
            console.error("ClearMessageHistory: ", data.Error);
            return;
          }
          this.clearDirectMessages.ok = true;
          this.clearDirectMessages.messagesErased = data.MessagesErased;
          this.clearDirectMessages.timeout = setTimeout(() => {
            this.clearDirectMessages.ok = false;
          }, 15e3);
          this.ChatClient(
            "Your direct message history has been cleared from the server's database. (" + data.MessagesErased + " messages erased)"
          );
        }).catch((resp) => {
          console.error("DirectMessageHistory: ", resp);
          this.ChatClient("Error clearing your chat history: " + resp);
        }).finally(() => {
          this.clearDirectMessages.busy = false;
        });
      });
    },
    /*
     * Webhook methods
     */
    isWebhookEnabled(name) {
      for (let webhook of this.config.webhookURLs) {
        if (webhook.Name === name && webhook.Enabled) {
          return true;
        }
      }
      return false;
    },
    reportMessage(message, force = false) {
      if (message.reported && !force) {
        this.modalConfirm({
          title: "Report Message",
          icon: "fa fa-info-circle",
          message: "You have already reported this message. Do you want to report it again?"
        }).then(() => {
          this.reportMessage(message, true);
        });
        return;
      }
      let user = {
        avatar: this.avatarForUsername(message.username),
        nickname: this.nicknameForUsername(message.username)
      };
      let clone = Object.assign({}, message);
      clone.message = clone.message.replace(/<img .+?>/g, "[inline image]");
      this.reportModal.message = clone;
      this.reportModal.user = user;
      this.reportModal.origMessage = message;
      this.reportModal.visible = true;
    },
    doReport({ classification, comment }) {
      if (this.reportModal.busy)
        return;
      this.reportModal.busy = true;
      let msg = this.reportModal.message;
      this.client.send({
        action: "report",
        channel: msg.channel,
        username: msg.username,
        timestamp: "" + msg.at,
        reason: classification,
        message: msg.message,
        comment
      });
      this.reportModal.busy = false;
      this.reportModal.visible = false;
      this.reportModal.origMessage.reported = true;
    },
    doCustomReport({ message, classification, comment }) {
      this.reportModal.message = message;
      this.doReport({ classification, comment });
    }
  }
};
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<div class="modal" id="drop-modal"><div class="modal-background"></div><div class="modal-content"><div class="box content has-text-centered"><h1><i class="fa fa-upload mr-2"></i> Drop image to share it on chat</h1></div></div></div>', 1);
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1);
const _hoisted_3 = { class: "modal-content" };
const _hoisted_4 = { class: "card" };
const _hoisted_5 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-info" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "Chat Settings")
], -1);
const _hoisted_6 = { class: "card-content" };
const _hoisted_7 = { class: "tabs" };
const _hoisted_8 = { key: 0 };
const _hoisted_9 = { class: "field is-horizontal" };
const _hoisted_10 = /* @__PURE__ */ createBaseVNode("div", { class: "field-label is-normal" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Theme")
], -1);
const _hoisted_11 = { class: "field-body" };
const _hoisted_12 = { class: "field" };
const _hoisted_13 = { class: "control" };
const _hoisted_14 = { class: "radio" };
const _hoisted_15 = { class: "radio" };
const _hoisted_16 = { class: "radio" };
const _hoisted_17 = { class: "field is-horizontal" };
const _hoisted_18 = /* @__PURE__ */ createBaseVNode("div", { class: "field-label is-normal" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Video size")
], -1);
const _hoisted_19 = { class: "field-body" };
const _hoisted_20 = { class: "field" };
const _hoisted_21 = { class: "control" };
const _hoisted_22 = { class: "select is-fullwidth" };
const _hoisted_23 = ["value"];
const _hoisted_24 = { class: "field is-horizontal" };
const _hoisted_25 = /* @__PURE__ */ createBaseVNode("div", { class: "field-label is-normal" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Text size")
], -1);
const _hoisted_26 = { class: "field-body" };
const _hoisted_27 = { class: "field" };
const _hoisted_28 = { class: "control" };
const _hoisted_29 = { class: "select is-fullwidth" };
const _hoisted_30 = ["value"];
const _hoisted_31 = { class: "field is-horizontal" };
const _hoisted_32 = /* @__PURE__ */ createBaseVNode("div", { class: "field-label is-normal" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Text style")
], -1);
const _hoisted_33 = { class: "field-body" };
const _hoisted_34 = { class: "field" };
const _hoisted_35 = { class: "control" };
const _hoisted_36 = { class: "select is-fullwidth" };
const _hoisted_37 = ["value"];
const _hoisted_38 = { class: "field is-horizontal" };
const _hoisted_39 = /* @__PURE__ */ createBaseVNode("div", { class: "field-label is-normal" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Images")
], -1);
const _hoisted_40 = { class: "field-body" };
const _hoisted_41 = { class: "field" };
const _hoisted_42 = { class: "control" };
const _hoisted_43 = { class: "select is-fullwidth" };
const _hoisted_44 = ["value"];
const _hoisted_45 = { class: "field" };
const _hoisted_46 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Scrollback buffer", -1);
const _hoisted_47 = { class: "control" };
const _hoisted_48 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, ` How many chat history messages to keep at once (per channel/DM thread). Older messages will be removed so your web browser doesn't run low on memory. A value of zero (0) will mean "unlimited" and the chat history is never trimmed. `, -1);
const _hoisted_49 = { key: 1 };
const _hoisted_50 = { class: "columns mb-4" };
const _hoisted_51 = { class: "column" };
const _hoisted_52 = { class: "checkbox" };
const _hoisted_53 = { class: "column" };
const _hoisted_54 = { class: "checkbox" };
const _hoisted_55 = { class: "columns is-mobile" };
const _hoisted_56 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "DM chat")
], -1);
const _hoisted_57 = { class: "column" };
const _hoisted_58 = { class: "select is-fullwidth" };
const _hoisted_59 = ["value"];
const _hoisted_60 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "Public chat")
], -1);
const _hoisted_61 = { class: "column" };
const _hoisted_62 = { class: "select is-fullwidth" };
const _hoisted_63 = ["value"];
const _hoisted_64 = { class: "columns is-mobile" };
const _hoisted_65 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "Room enter")
], -1);
const _hoisted_66 = { class: "column" };
const _hoisted_67 = { class: "select is-fullwidth" };
const _hoisted_68 = ["value"];
const _hoisted_69 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "Room leave")
], -1);
const _hoisted_70 = { class: "column" };
const _hoisted_71 = { class: "select is-fullwidth" };
const _hoisted_72 = ["value"];
const _hoisted_73 = { class: "columns is-mobile" };
const _hoisted_74 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "Watched")
], -1);
const _hoisted_75 = { class: "column" };
const _hoisted_76 = { class: "select is-fullwidth" };
const _hoisted_77 = ["value"];
const _hoisted_78 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "Unwatched")
], -1);
const _hoisted_79 = { class: "column" };
const _hoisted_80 = { class: "select is-fullwidth" };
const _hoisted_81 = ["value"];
const _hoisted_82 = { class: "columns is-mobile" };
const _hoisted_83 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label is-size-7" }, "@ Mentioned")
], -1);
const _hoisted_84 = { class: "column" };
const _hoisted_85 = { class: "select is-fullwidth pr-2" };
const _hoisted_86 = ["value"];
const _hoisted_87 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-2 pr-1" }, "   ", -1);
const _hoisted_88 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-4" }, "   ", -1);
const _hoisted_89 = { key: 2 };
const _hoisted_90 = /* @__PURE__ */ createBaseVNode("h3", { class: "subtitle mb-2" }, " Camera Settings ", -1);
const _hoisted_91 = /* @__PURE__ */ createBaseVNode("p", { class: "block mb-1 is-size-7" }, " The settings on this tab will be relevant only when you are already broadcasting your camera. They allow you to modify your broadcast settings while you are already live (for example, to change your mutual camera preference or select another audio/video device to broadcast from). ", -1);
const _hoisted_92 = {
  key: 0,
  class: "block mb-1"
};
const _hoisted_93 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Explicit webcam options", -1);
const _hoisted_94 = [
  _hoisted_93
];
const _hoisted_95 = {
  key: 1,
  class: "field mb-1"
};
const _hoisted_96 = { class: "checkbox" };
const _hoisted_97 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-fire has-text-danger mr-2" }, null, -1);
const _hoisted_98 = /* @__PURE__ */ createBaseVNode("span", { class: "has-text-danger" }, "Explicit", -1);
const _hoisted_99 = {
  key: 2,
  class: "field"
};
const _hoisted_100 = { class: "checkbox" };
const _hoisted_101 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " Don't auto-open explicit cameras when they open mine; and automatically close a camera I am watching if it toggles to become explicit. ", -1);
const _hoisted_102 = /* @__PURE__ */ createBaseVNode("p", { class: "block mb-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Mutual webcam options")
], -1);
const _hoisted_103 = { class: "field mb-1" };
const _hoisted_104 = { class: "checkbox" };
const _hoisted_105 = { class: "field mb-1" };
const _hoisted_106 = { class: "checkbox" };
const _hoisted_107 = { class: "field mb-1" };
const _hoisted_108 = { class: "checkbox" };
const _hoisted_109 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-microphone-slash mx-1" }, null, -1);
const _hoisted_110 = {
  key: 3,
  class: "field mb-1"
};
const _hoisted_111 = { class: "checkbox" };
const _hoisted_112 = ["innerHTML"];
const _hoisted_113 = { class: "field" };
const _hoisted_114 = { class: "checkbox" };
const _hoisted_115 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " If I click the 'X' button to expressly close a webcam, that video won't auto-open again in case that person reopened my camera. ", -1);
const _hoisted_116 = {
  key: 4,
  class: "subtitle mb-2"
};
const _hoisted_117 = {
  key: 5,
  class: "columns is-mobile"
};
const _hoisted_118 = { class: "column" };
const _hoisted_119 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Video source", -1);
const _hoisted_120 = { class: "select is-fullwidth" };
const _hoisted_121 = ["value"];
const _hoisted_122 = { class: "column" };
const _hoisted_123 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Audio source", -1);
const _hoisted_124 = { class: "select is-fullwidth" };
const _hoisted_125 = ["value"];
const _hoisted_126 = {
  key: 6,
  class: "block mb-1"
};
const _hoisted_127 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Miscellaneous", -1);
const _hoisted_128 = [
  _hoisted_127
];
const _hoisted_129 = {
  key: 7,
  class: "field mb-1"
};
const _hoisted_130 = { class: "checkbox" };
const _hoisted_131 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, [
  /* @__PURE__ */ createTextVNode(" Note: be sure that your web browser has "),
  /* @__PURE__ */ createBaseVNode("strong", null, "remembered"),
  /* @__PURE__ */ createTextVNode(" your webcam and mic permission! This option can automatically share your webcam when you log onto chat again from this device. ")
], -1);
const _hoisted_132 = { key: 3 };
const _hoisted_133 = { class: "field" };
const _hoisted_134 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, [
  /* @__PURE__ */ createTextVNode("Presence messages "),
  /* @__PURE__ */ createBaseVNode("small", null, "('has joined the room')"),
  /* @__PURE__ */ createTextVNode(" in public channels")
], -1);
const _hoisted_135 = { class: "columns is-mobile mb-0" };
const _hoisted_136 = { class: "column py-1" };
const _hoisted_137 = {
  class: "checkbox",
  title: "Show 'has joined the room' messages in public channels"
};
const _hoisted_138 = { class: "column py-1" };
const _hoisted_139 = {
  class: "checkbox",
  title: "Show 'has exited the room' messages in public channels"
};
const _hoisted_140 = { class: "field" };
const _hoisted_141 = /* @__PURE__ */ createBaseVNode("label", { class: "label mb-0" }, "Server notification messages", -1);
const _hoisted_142 = {
  class: "checkbox",
  title: "Show 'has joined the room' messages in public channels"
};
const _hoisted_143 = { class: "field" };
const _hoisted_144 = /* @__PURE__ */ createBaseVNode("label", { class: "label mb-0" }, "Direct Messages", -1);
const _hoisted_145 = { class: "checkbox mb-0" };
const _hoisted_146 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " If you check this box, other chatters may not initiate DMs with you: their messages will be (silently) ignored. You may still initiate DM chats with others, unless they also have closed their DMs with this setting. ", -1);
const _hoisted_147 = {
  key: 0,
  class: "field"
};
const _hoisted_148 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-trash mr-1" }, null, -1);
const _hoisted_149 = {
  key: 0,
  class: "has-text-success mt-2 is-size-7"
};
const _hoisted_150 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-spinner fa-spin mr-1" }, null, -1);
const _hoisted_151 = {
  key: 1,
  class: "has-text-success mt-2 is-size-7"
};
const _hoisted_152 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-check mr-1" }, null, -1);
const _hoisted_153 = { key: 4 };
const _hoisted_154 = { class: "field" };
const _hoisted_155 = /* @__PURE__ */ createBaseVNode("label", { class: "label mb-0" }, " Server Connection Method ", -1);
const _hoisted_156 = { class: "checkbox" };
const _hoisted_157 = { class: "checkbox" };
const _hoisted_158 = { class: "help" };
const _hoisted_159 = {
  key: 0,
  class: "has-text-danger"
};
const _hoisted_160 = {
  key: 0,
  class: "field"
};
const _hoisted_161 = /* @__PURE__ */ createBaseVNode("label", { class: "label mb-0" }, " Stats for nerds ", -1);
const _hoisted_162 = { class: "checkbox" };
const _hoisted_163 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " This enables a channel where under-the-hood debug messages may be posted, e.g. to debug WebRTC connection problems. ", -1);
const _hoisted_164 = { class: "card-footer" };
const _hoisted_165 = { class: "card-footer-item" };
const _hoisted_166 = /* @__PURE__ */ createBaseVNode("div", { class: "modal-background" }, null, -1);
const _hoisted_167 = { class: "modal-content" };
const _hoisted_168 = { class: "card" };
const _hoisted_169 = /* @__PURE__ */ createBaseVNode("header", { class: "card-header has-background-info" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "card-header-title" }, "Select Webcam Options")
], -1);
const _hoisted_170 = { class: "card-content" };
const _hoisted_171 = /* @__PURE__ */ createBaseVNode("p", { class: "block mb-1" }, [
  /* @__PURE__ */ createTextVNode(" You can turn on your webcam and enable others in the room to connect to yours. The controls to "),
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-stop has-text-danger" }),
  /* @__PURE__ */ createTextVNode(" stop and "),
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-microphone-slash has-text-danger" }),
  /* @__PURE__ */ createTextVNode(" mute audio will be at the top of the page. ")
], -1);
const _hoisted_172 = { class: "field" };
const _hoisted_173 = { class: "checkbox" };
const _hoisted_174 = {
  key: 0,
  class: "block mb-1"
};
const _hoisted_175 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "'Explicit' webcam options", -1);
const _hoisted_176 = [
  _hoisted_175
];
const _hoisted_177 = {
  key: 1,
  class: "field"
};
const _hoisted_178 = { class: "checkbox" };
const _hoisted_179 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-fire has-text-danger mr-2" }, null, -1);
const _hoisted_180 = /* @__PURE__ */ createBaseVNode("span", { class: "has-text-danger" }, "Explicit", -1);
const _hoisted_181 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, [
  /* @__PURE__ */ createTextVNode(" You can toggle this at any time by clicking on the '"),
  /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-fire" }),
  /* @__PURE__ */ createTextVNode(" Explicit' button at the top of the page. ")
], -1);
const _hoisted_182 = {
  key: 2,
  class: "field"
};
const _hoisted_183 = { class: "checkbox" };
const _hoisted_184 = /* @__PURE__ */ createBaseVNode("p", { class: "help" }, " Close, and don't automatically open, other peoples' cameras when they toggle to become explicit. ", -1);
const _hoisted_185 = /* @__PURE__ */ createBaseVNode("p", { class: "block mb-1" }, [
  /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Mutual webcam options")
], -1);
const _hoisted_186 = { class: "field mb-1" };
const _hoisted_187 = { class: "checkbox" };
const _hoisted_188 = { class: "field mb-1" };
const _hoisted_189 = { class: "checkbox" };
const _hoisted_190 = {
  key: 3,
  class: "field"
};
const _hoisted_191 = { class: "checkbox" };
const _hoisted_192 = ["innerHTML"];
const _hoisted_193 = {
  key: 4,
  class: "columns is-mobile"
};
const _hoisted_194 = { class: "column" };
const _hoisted_195 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Video source", -1);
const _hoisted_196 = { class: "select is-fullwidth" };
const _hoisted_197 = /* @__PURE__ */ createBaseVNode("option", {
  value: null,
  disabled: "",
  selected: ""
}, "Select default camera", -1);
const _hoisted_198 = ["value"];
const _hoisted_199 = { class: "column" };
const _hoisted_200 = /* @__PURE__ */ createBaseVNode("label", { class: "label" }, "Audio source", -1);
const _hoisted_201 = { class: "select is-fullwidth" };
const _hoisted_202 = /* @__PURE__ */ createBaseVNode("option", {
  value: null,
  disabled: "",
  selected: ""
}, "Select default microphone", -1);
const _hoisted_203 = ["value"];
const _hoisted_204 = { class: "field" };
const _hoisted_205 = { class: "control has-text-centered" };
const _hoisted_206 = { class: "chat-container" };
const _hoisted_207 = { class: "chat-header" };
const _hoisted_208 = { class: "columns is-mobile" };
const _hoisted_209 = { class: "column is-narrow pr-1" };
const _hoisted_210 = { class: "is-6" };
const _hoisted_211 = ["innerHTML"];
const _hoisted_212 = { class: "column px-1" };
const _hoisted_213 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-stop mr-2" }, null, -1);
const _hoisted_214 = ["disabled"];
const _hoisted_215 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-video mr-2" }, null, -1);
const _hoisted_216 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-microphone mr-2" }, null, -1);
const _hoisted_217 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-microphone-slash mr-2" }, null, -1);
const _hoisted_218 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-eye mr-2" }, null, -1);
const _hoisted_219 = {
  class: "column dropdown is-right is-narrow pl-1",
  id: "chat-settings-hamburger-menu"
};
const _hoisted_220 = /* @__PURE__ */ createBaseVNode("div", { class: "dropdown-trigger" }, [
  /* @__PURE__ */ createBaseVNode("button", {
    type: "button",
    class: "button is-small is-link px-2",
    "aria-haspopup": "true",
    "aria-controls": "chat-settings-menu"
  }, [
    /* @__PURE__ */ createBaseVNode("span", null, [
      /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-bars" })
    ])
  ])
], -1);
const _hoisted_221 = {
  class: "dropdown-menu mr-3",
  id: "chat-settings-menu",
  role: "menu"
};
const _hoisted_222 = { class: "dropdown-content" };
const _hoisted_223 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-gear mr-1" }, null, -1);
const _hoisted_224 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-video-slash mr-1" }, null, -1);
const _hoisted_225 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-microphone-slash mr-1" }, null, -1);
const _hoisted_226 = /* @__PURE__ */ createStaticVNode('<hr class="dropdown-divider"><a href="/about" target="_blank" class="dropdown-item"><i class="fa fa-info-circle mr-1"></i> About </a><a href="/logout" class="dropdown-item"><i class="fa fa-arrow-right-from-bracket mr-1"></i> Log out </a>', 3);
const _hoisted_229 = { class: "left-column" };
const _hoisted_230 = { class: "card grid-card" };
const _hoisted_231 = { class: "card-header has-background-success" };
const _hoisted_232 = { class: "columns is-mobile card-header-title" };
const _hoisted_233 = { class: "column is-narrow mobile-only" };
const _hoisted_234 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-arrow-left" }, null, -1);
const _hoisted_235 = [
  _hoisted_234
];
const _hoisted_236 = /* @__PURE__ */ createBaseVNode("div", { class: "column" }, "Channels", -1);
const _hoisted_237 = { class: "card-content" };
const _hoisted_238 = { class: "menu" };
const _hoisted_239 = /* @__PURE__ */ createBaseVNode("p", { class: "menu-label" }, " Public Channels ", -1);
const _hoisted_240 = { class: "menu-list" };
const _hoisted_241 = ["href", "onClick"];
const _hoisted_242 = /* @__PURE__ */ createBaseVNode("p", { class: "menu-label" }, " Direct Messages ", -1);
const _hoisted_243 = { class: "menu-list" };
const _hoisted_244 = ["href", "onClick"];
const _hoisted_245 = { class: "columns is-mobile" };
const _hoisted_246 = {
  class: "column is-narrow pr-0",
  style: { "position": "relative" }
};
const _hoisted_247 = ["src"];
const _hoisted_248 = {
  key: 1,
  src: _imports_0,
  width: "24",
  height: "24"
};
const _hoisted_249 = { class: "column" };
const _hoisted_250 = {
  class: "forcibly-truncate-wrapper forcibly-single-line",
  style: { "height": "24px" }
};
const _hoisted_251 = { class: "forcibly-truncate-body" };
const _hoisted_252 = {
  key: 0,
  class: "tag is-danger mr-1"
};
const _hoisted_253 = { key: 1 };
const _hoisted_254 = { key: 2 };
const _hoisted_255 = { class: "tag mt-2" };
const _hoisted_256 = { class: "checkbox" };
const _hoisted_257 = /* @__PURE__ */ createBaseVNode("a", {
  href: "#",
  onclick: "alert('When checked, your DMs will be closed to new conversations. You may still initiate new DMs with others.'); return false",
  class: "fa fa-info-circle ml-2"
}, null, -1);
const _hoisted_258 = { class: "chat-column" };
const _hoisted_259 = { class: "card grid-card" };
const _hoisted_260 = { class: "columns is-mobile card-header-title has-text-light" };
const _hoisted_261 = { class: "column is-narrow mobile-only pr-0" };
const _hoisted_262 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-comments" }, null, -1);
const _hoisted_263 = {
  key: 0,
  class: "column is-narrow pr-0"
};
const _hoisted_264 = ["title"];
const _hoisted_265 = { class: "column" };
const _hoisted_266 = { class: "forcibly-truncate-wrapper" };
const _hoisted_267 = { class: "forcibly-truncate-body" };
const _hoisted_268 = { key: 0 };
const _hoisted_269 = { key: 1 };
const _hoisted_270 = {
  key: 1,
  class: "column is-narrow is-hidden-mobile"
};
const _hoisted_271 = ["disabled"];
const _hoisted_272 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-gear" }, null, -1);
const _hoisted_273 = [
  _hoisted_272
];
const _hoisted_274 = ["disabled"];
const _hoisted_275 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-magnifying-glass-plus" }, null, -1);
const _hoisted_276 = [
  _hoisted_275
];
const _hoisted_277 = ["disabled"];
const _hoisted_278 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-magnifying-glass-minus" }, null, -1);
const _hoisted_279 = [
  _hoisted_278
];
const _hoisted_280 = {
  key: 2,
  class: "column is-narrow"
};
const _hoisted_281 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-trash" }, null, -1);
const _hoisted_282 = [
  _hoisted_281
];
const _hoisted_283 = { class: "column is-narrow pl-0 mobile-only" };
const _hoisted_284 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-user-group" }, null, -1);
const _hoisted_285 = [
  _hoisted_284
];
const _hoisted_286 = {
  key: 0,
  class: "user-status-dm-field tag is-info"
};
const _hoisted_287 = /* @__PURE__ */ createBaseVNode("strong", { class: "mr-2 has-text-light" }, "Status:", -1);
const _hoisted_288 = { key: 0 };
const _hoisted_289 = { key: 1 };
const _hoisted_290 = { class: "autoscroll-field tag" };
const _hoisted_291 = {
  class: "checkbox is-size-6",
  title: "Automatically scroll when new chat messages come in."
};
const _hoisted_292 = { key: 0 };
const _hoisted_293 = { key: 0 };
const _hoisted_294 = { key: 1 };
const _hoisted_295 = {
  key: 1,
  class: "mb-2"
};
const _hoisted_296 = {
  key: 0,
  class: "notification is-info is-light"
};
const _hoisted_297 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-spinner fa-spin mr-1" }, null, -1);
const _hoisted_298 = { key: 1 };
const _hoisted_299 = { key: 0 };
const _hoisted_300 = {
  key: 1,
  class: "has-text-danger"
};
const _hoisted_301 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-comment-slash" }, null, -1);
const _hoisted_302 = /* @__PURE__ */ createBaseVNode("strong", null, "muted", -1);
const _hoisted_303 = { class: "chat-footer" };
const _hoisted_304 = { class: "card" };
const _hoisted_305 = { class: "card-content p-2" };
const _hoisted_306 = { class: "columns is-mobile" };
const _hoisted_307 = {
  key: 0,
  class: "column pr-1 is-narrow"
};
const _hoisted_308 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-image" }, null, -1);
const _hoisted_309 = [
  _hoisted_308
];
const _hoisted_310 = ["disabled"];
const _hoisted_311 = /* @__PURE__ */ createBaseVNode("div", { class: "has-text-grey m-2" }, " No result ", -1);
const _hoisted_312 = { class: "has-text-link m-2" };
const _hoisted_313 = { class: "has-text-grey" };
const _hoisted_314 = { class: "dropdown-trigger" };
const _hoisted_315 = /* @__PURE__ */ createBaseVNode("span", null, [
  /* @__PURE__ */ createBaseVNode("i", { class: "fa-regular fa-smile" })
], -1);
const _hoisted_316 = [
  _hoisted_315
];
const _hoisted_317 = {
  class: "dropdown-menu",
  id: "input-emoji-picker",
  role: "menu",
  style: { "z-index": "9000" }
};
const _hoisted_318 = { class: "dropdown-content p-0" };
const _hoisted_319 = { class: "column pl-1 is-narrow" };
const _hoisted_320 = ["disabled"];
const _hoisted_321 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-paper-plane" }, null, -1);
const _hoisted_322 = [
  _hoisted_321
];
const _hoisted_323 = { class: "right-column" };
const _hoisted_324 = { class: "card grid-card" };
const _hoisted_325 = { class: "card-header has-background-success" };
const _hoisted_326 = { class: "columns is-mobile card-header-title" };
const _hoisted_327 = /* @__PURE__ */ createBaseVNode("div", { class: "column" }, "Who Is Online", -1);
const _hoisted_328 = { class: "column is-narrow mobile-only" };
const _hoisted_329 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-arrow-left" }, null, -1);
const _hoisted_330 = [
  _hoisted_329
];
const _hoisted_331 = { class: "card-content p-2" };
const _hoisted_332 = { class: "columns is-mobile mb-0" };
const _hoisted_333 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-one-quarter" }, " Status: ", -1);
const _hoisted_334 = { class: "column" };
const _hoisted_335 = { class: "select is-small is-fullwidth" };
const _hoisted_336 = ["label"];
const _hoisted_337 = ["value"];
const _hoisted_338 = { class: "columns is-mobile mb-0" };
const _hoisted_339 = /* @__PURE__ */ createBaseVNode("div", { class: "column is-one-quarter" }, " Sort: ", -1);
const _hoisted_340 = { class: "column" };
const _hoisted_341 = { class: "select is-small is-fullwidth" };
const _hoisted_342 = /* @__PURE__ */ createBaseVNode("option", { value: "a-z" }, "Username (a-z)", -1);
const _hoisted_343 = /* @__PURE__ */ createBaseVNode("option", { value: "z-a" }, "Username (z-a)", -1);
const _hoisted_344 = /* @__PURE__ */ createBaseVNode("option", { value: "login" }, "Login Time", -1);
const _hoisted_345 = /* @__PURE__ */ createBaseVNode("option", { value: "broadcasting" }, "Broadcasting", -1);
const _hoisted_346 = { value: "nsfw" };
const _hoisted_347 = /* @__PURE__ */ createBaseVNode("option", { value: "status" }, "Status", -1);
const _hoisted_348 = /* @__PURE__ */ createBaseVNode("option", { value: "emoji" }, "Emoji/country flag", -1);
const _hoisted_349 = /* @__PURE__ */ createBaseVNode("option", { value: "gender" }, "Gender", -1);
const _hoisted_350 = /* @__PURE__ */ createBaseVNode("option", { value: "op" }, "User level (operators)", -1);
const _hoisted_351 = { class: "tabs has-text-small" };
const _hoisted_352 = /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-eye mr-2" }, null, -1);
const _hoisted_353 = { key: 0 };
const _hoisted_354 = { key: 1 };
const _hoisted_355 = /* @__PURE__ */ createBaseVNode("div", { style: { "width": "1px", "height": "1px", "overflow": "hidden", "position": "absolute", "bottom": "0", "right": "0" } }, [
  /* @__PURE__ */ createBaseVNode("canvas", { id: "darkVideoCanvas" })
], -1);
const _hoisted_356 = {
  key: 0,
  rel: "stylesheet",
  type: "text/css",
  href: "/static/css/bulma-no-dark-mode.min.css?{{.config.cacheHash}}"
};
const _hoisted_357 = {
  key: 1,
  rel: "stylesheet",
  type: "text/css",
  href: "/static/css/bulma-dark-theme.css?{{.config.cacheHash}}"
};
const _hoisted_358 = {
  key: 2,
  rel: "stylesheet",
  type: "text/css",
  href: "/static/css/chat-prefers-dark.css?{{.config.cacheHash}}"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AlertModal = resolveComponent("AlertModal");
  const _component_LoginModal = resolveComponent("LoginModal");
  const _component_ExplicitOpenModal = resolveComponent("ExplicitOpenModal");
  const _component_ReportModal = resolveComponent("ReportModal");
  const _component_ProfileModal = resolveComponent("ProfileModal");
  const _component_VideoFeed = resolveComponent("VideoFeed");
  const _component_MessageBox = resolveComponent("MessageBox");
  const _component_Mentionable = resolveComponent("Mentionable");
  const _component_EmojiPicker = resolveComponent("EmojiPicker");
  const _component_WhoListRow = resolveComponent("WhoListRow");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_AlertModal, {
      visible: $data.alertModal.visible,
      "is-confirm": $data.alertModal.isConfirm,
      title: $data.alertModal.title,
      icon: $data.alertModal.icon,
      message: $data.alertModal.message,
      onCallback: $data.alertModal.callback,
      onClose: _cache[0] || (_cache[0] = ($event) => $options.modalClose())
    }, null, 8, ["visible", "is-confirm", "title", "icon", "message", "onCallback"]),
    createVNode(_component_LoginModal, {
      visible: $data.loginModal.visible,
      onSignIn: $options.signIn
    }, null, 8, ["visible", "onSignIn"]),
    _hoisted_1,
    createBaseVNode("div", {
      class: normalizeClass(["modal", { "is-active": $data.settingsModal.visible }])
    }, [
      _hoisted_2,
      createBaseVNode("div", _hoisted_3, [
        createBaseVNode("div", _hoisted_4, [
          _hoisted_5,
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("div", _hoisted_7, [
              createBaseVNode("ul", null, [
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.settingsModal.tab === "prefs" })
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $data.settingsModal.tab = "prefs", ["prevent"]))
                  }, " Display ")
                ], 2),
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.settingsModal.tab === "sounds" })
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $data.settingsModal.tab = "sounds", ["prevent"]))
                  }, " Sounds ")
                ], 2),
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.settingsModal.tab === "webcam" })
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[3] || (_cache[3] = withModifiers(($event) => $data.settingsModal.tab = "webcam", ["prevent"]))
                  }, " Camera ")
                ], 2),
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.settingsModal.tab === "misc" })
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[4] || (_cache[4] = withModifiers(($event) => $data.settingsModal.tab = "misc", ["prevent"]))
                  }, " Misc ")
                ], 2),
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.settingsModal.tab === "advanced" })
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[5] || (_cache[5] = withModifiers(($event) => $data.settingsModal.tab = "advanced", ["prevent"]))
                  }, " Advanced ")
                ], 2)
              ])
            ]),
            $data.settingsModal.tab === "prefs" ? (openBlock(), createElementBlock("div", _hoisted_8, [
              createBaseVNode("div", _hoisted_9, [
                _hoisted_10,
                createBaseVNode("div", _hoisted_11, [
                  createBaseVNode("div", _hoisted_12, [
                    createBaseVNode("div", _hoisted_13, [
                      createBaseVNode("label", _hoisted_14, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.prefs.theme = $event),
                          value: "auto"
                        }, null, 512), [
                          [vModelRadio, $data.prefs.theme]
                        ]),
                        createTextVNode(" Automatic ")
                      ]),
                      createBaseVNode("label", _hoisted_15, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.prefs.theme = $event),
                          value: "light"
                        }, null, 512), [
                          [vModelRadio, $data.prefs.theme]
                        ]),
                        createTextVNode(" Light ")
                      ]),
                      createBaseVNode("label", _hoisted_16, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.prefs.theme = $event),
                          value: "dark"
                        }, null, 512), [
                          [vModelRadio, $data.prefs.theme]
                        ]),
                        createTextVNode(" Dark ")
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_17, [
                _hoisted_18,
                createBaseVNode("div", _hoisted_19, [
                  createBaseVNode("div", _hoisted_20, [
                    createBaseVNode("div", _hoisted_21, [
                      createBaseVNode("div", _hoisted_22, [
                        withDirectives(createBaseVNode("select", {
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.webcam.videoScale = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList($data.webcam.videoScaleOptions, (s2) => {
                            return openBlock(), createElementBlock("option", {
                              key: s2[0],
                              value: s2[0]
                            }, toDisplayString(s2[1]), 9, _hoisted_23);
                          }), 128))
                        ], 512), [
                          [vModelSelect, $data.webcam.videoScale]
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_24, [
                _hoisted_25,
                createBaseVNode("div", _hoisted_26, [
                  createBaseVNode("div", _hoisted_27, [
                    createBaseVNode("div", _hoisted_28, [
                      createBaseVNode("div", _hoisted_29, [
                        withDirectives(createBaseVNode("select", {
                          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.fontSizeClass = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.fontSizeClasses, (s2) => {
                            return openBlock(), createElementBlock("option", {
                              key: s2[0],
                              value: s2[0]
                            }, toDisplayString(s2[1]), 9, _hoisted_30);
                          }), 128))
                        ], 512), [
                          [vModelSelect, $data.fontSizeClass]
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_31, [
                _hoisted_32,
                createBaseVNode("div", _hoisted_33, [
                  createBaseVNode("div", _hoisted_34, [
                    createBaseVNode("div", _hoisted_35, [
                      createBaseVNode("div", _hoisted_36, [
                        withDirectives(createBaseVNode("select", {
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $data.messageStyle = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.messageStyleSettings, (s2) => {
                            return openBlock(), createElementBlock("option", {
                              key: s2[0],
                              value: s2[0]
                            }, toDisplayString(s2[1]), 9, _hoisted_37);
                          }), 128))
                        ], 512), [
                          [vModelSelect, $data.messageStyle]
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_38, [
                _hoisted_39,
                createBaseVNode("div", _hoisted_40, [
                  createBaseVNode("div", _hoisted_41, [
                    createBaseVNode("div", _hoisted_42, [
                      createBaseVNode("div", _hoisted_43, [
                        withDirectives(createBaseVNode("select", {
                          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.imageDisplaySetting = $event)
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.imageDisplaySettings, (s2) => {
                            return openBlock(), createElementBlock("option", {
                              key: s2[0],
                              value: s2[0]
                            }, toDisplayString(s2[1]), 9, _hoisted_44);
                          }), 128))
                        ], 512), [
                          [vModelSelect, $data.imageDisplaySetting]
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_45, [
                _hoisted_46,
                createBaseVNode("div", _hoisted_47, [
                  withDirectives(createBaseVNode("input", {
                    type: "number",
                    class: "input",
                    "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.scrollback = $event),
                    min: "0",
                    inputmode: "numeric"
                  }, null, 512), [
                    [vModelText, $data.scrollback]
                  ])
                ]),
                _hoisted_48
              ])
            ])) : $data.settingsModal.tab === "sounds" ? (openBlock(), createElementBlock("div", _hoisted_49, [
              createBaseVNode("div", _hoisted_50, [
                createBaseVNode("div", _hoisted_51, [
                  createBaseVNode("label", _hoisted_52, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.prefs.muteSounds = $event),
                      value: true
                    }, null, 512), [
                      [vModelCheckbox, $data.prefs.muteSounds]
                    ]),
                    createTextVNode(" Mute all sound effects ")
                  ])
                ]),
                createBaseVNode("div", _hoisted_53, [
                  createBaseVNode("label", _hoisted_54, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => $data.webcam.autoMuteWebcams = $event),
                      value: true
                    }, null, 512), [
                      [vModelCheckbox, $data.webcam.autoMuteWebcams]
                    ]),
                    createTextVNode(" Automatically mute webcams ")
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_55, [
                _hoisted_56,
                createBaseVNode("div", _hoisted_57, [
                  createBaseVNode("div", _hoisted_58, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.config.sounds.settings.DM = $event),
                      onChange: _cache[17] || (_cache[17] = ($event) => $options.setSoundPref("DM"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_59);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.DM]
                    ])
                  ])
                ]),
                _hoisted_60,
                createBaseVNode("div", _hoisted_61, [
                  createBaseVNode("div", _hoisted_62, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => $data.config.sounds.settings.Chat = $event),
                      onChange: _cache[19] || (_cache[19] = ($event) => $options.setSoundPref("Chat"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_63);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Chat]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_64, [
                _hoisted_65,
                createBaseVNode("div", _hoisted_66, [
                  createBaseVNode("div", _hoisted_67, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.config.sounds.settings.Enter = $event),
                      onChange: _cache[21] || (_cache[21] = ($event) => $options.setSoundPref("Enter"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_68);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Enter]
                    ])
                  ])
                ]),
                _hoisted_69,
                createBaseVNode("div", _hoisted_70, [
                  createBaseVNode("div", _hoisted_71, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => $data.config.sounds.settings.Leave = $event),
                      onChange: _cache[23] || (_cache[23] = ($event) => $options.setSoundPref("Leave"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_72);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Leave]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_73, [
                _hoisted_74,
                createBaseVNode("div", _hoisted_75, [
                  createBaseVNode("div", _hoisted_76, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => $data.config.sounds.settings.Watch = $event),
                      onChange: _cache[25] || (_cache[25] = ($event) => $options.setSoundPref("Watch"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_77);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Watch]
                    ])
                  ])
                ]),
                _hoisted_78,
                createBaseVNode("div", _hoisted_79, [
                  createBaseVNode("div", _hoisted_80, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => $data.config.sounds.settings.Unwatch = $event),
                      onChange: _cache[27] || (_cache[27] = ($event) => $options.setSoundPref("Unwatch"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_81);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Unwatch]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_82, [
                _hoisted_83,
                createBaseVNode("div", _hoisted_84, [
                  createBaseVNode("div", _hoisted_85, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => $data.config.sounds.settings.Mentioned = $event),
                      onChange: _cache[29] || (_cache[29] = ($event) => $options.setSoundPref("Mentioned"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.config.sounds.available, (s2) => {
                        return openBlock(), createElementBlock("option", {
                          key: s2.name,
                          value: s2.name
                        }, toDisplayString(s2.name), 9, _hoisted_86);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.config.sounds.settings.Mentioned]
                    ])
                  ])
                ]),
                _hoisted_87,
                _hoisted_88
              ])
            ])) : createCommentVNode("", true),
            $data.settingsModal.tab === "webcam" ? (openBlock(), createElementBlock("div", _hoisted_89, [
              _hoisted_90,
              _hoisted_91,
              $data.config.permitNSFW ? (openBlock(), createElementBlock("p", _hoisted_92, _hoisted_94)) : createCommentVNode("", true),
              $data.config.permitNSFW ? (openBlock(), createElementBlock("div", _hoisted_95, [
                createBaseVNode("label", _hoisted_96, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[30] || (_cache[30] = ($event) => $data.webcam.nsfw = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.nsfw]
                  ]),
                  createTextVNode(" Mark my camera as featuring "),
                  _hoisted_97,
                  _hoisted_98,
                  createTextVNode(" or sexual content ")
                ])
              ])) : createCommentVNode("", true),
              $data.config.permitNSFW ? (openBlock(), createElementBlock("div", _hoisted_99, [
                createBaseVNode("label", _hoisted_100, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => $data.webcam.nonExplicit = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.nonExplicit]
                  ]),
                  createTextVNode(" I prefer not to see Explicit cameras from other chatters ")
                ]),
                _hoisted_101
              ])) : createCommentVNode("", true),
              _hoisted_102,
              createBaseVNode("div", _hoisted_103, [
                createBaseVNode("label", _hoisted_104, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[32] || (_cache[32] = ($event) => $data.webcam.mutual = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.mutual]
                  ]),
                  createTextVNode(" People must be sharing their own camera before they can open mine ")
                ])
              ]),
              createBaseVNode("div", _hoisted_105, [
                createBaseVNode("label", _hoisted_106, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[33] || (_cache[33] = ($event) => $data.webcam.mutualOpen = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.mutualOpen]
                  ]),
                  createTextVNode(" When someone opens my camera, I also open their camera automatically ")
                ])
              ]),
              createBaseVNode("div", _hoisted_107, [
                createBaseVNode("label", _hoisted_108, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[34] || (_cache[34] = ($event) => $data.webcam.autoMuteWebcams = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.autoMuteWebcams]
                  ]),
                  _hoisted_109,
                  createTextVNode(" Automatically mute audio on other peoples' webcams ")
                ])
              ]),
              $options.isVIP ? (openBlock(), createElementBlock("div", _hoisted_110, [
                createBaseVNode("label", _hoisted_111, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[35] || (_cache[35] = ($event) => $data.webcam.vipOnly = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.vipOnly]
                  ]),
                  createTextVNode(" Only "),
                  createBaseVNode("span", {
                    innerHTML: $data.config.VIP.Branding
                  }, null, 8, _hoisted_112),
                  createTextVNode(),
                  createBaseVNode("sup", {
                    class: normalizeClass(["is-size-7", $data.config.VIP.Icon])
                  }, null, 2),
                  createTextVNode(" members can see that my camera is broadcasting ")
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_113, [
                createBaseVNode("label", _hoisted_114, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[36] || (_cache[36] = ($event) => $data.webcam.rememberExpresslyClosed = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.rememberExpresslyClosed]
                  ]),
                  createTextVNode(" Don't (automatically) reopen cameras that I have expressly closed ")
                ]),
                _hoisted_115
              ]),
              $data.webcam.videoDevices.length > 0 || $data.webcam.audioDevices.length > 0 ? (openBlock(), createElementBlock("h3", _hoisted_116, [
                createTextVNode(" Webcam Devices "),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-primary is-small is-outlined ml-2",
                  onClick: _cache[37] || (_cache[37] = ($event) => $options.getDevices()),
                  title: "Refresh list of devices"
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["fa fa-arrows-rotate", { "fa-spin": $data.webcam.gettingDevices }])
                  }, null, 2)
                ])
              ])) : createCommentVNode("", true),
              $data.webcam.videoDevices.length > 0 || $data.webcam.audioDevices.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_117, [
                createBaseVNode("div", _hoisted_118, [
                  _hoisted_119,
                  createBaseVNode("div", _hoisted_120, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[38] || (_cache[38] = ($event) => $data.webcam.videoDeviceID = $event),
                      onChange: _cache[39] || (_cache[39] = ($event) => $options.startVideo({ changeCamera: true, force: true }))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.webcam.videoDevices, (d2, i2) => {
                        return openBlock(), createElementBlock("option", {
                          value: d2.id,
                          key: i2
                        }, toDisplayString(d2.label || `Camera ${i2}`), 9, _hoisted_121);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.webcam.videoDeviceID]
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_122, [
                  _hoisted_123,
                  createBaseVNode("div", _hoisted_124, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[40] || (_cache[40] = ($event) => $data.webcam.audioDeviceID = $event),
                      onChange: _cache[41] || (_cache[41] = ($event) => $options.startVideo({ changeCamera: true, force: true }))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.webcam.audioDevices, (d2, i2) => {
                        return openBlock(), createElementBlock("option", {
                          value: d2.id,
                          key: i2
                        }, toDisplayString(d2.label || `Microphone ${i2}`), 9, _hoisted_125);
                      }), 128))
                    ], 544), [
                      [vModelSelect, $data.webcam.audioDeviceID]
                    ])
                  ])
                ])
              ])) : createCommentVNode("", true),
              $data.webcam.videoDevices.length > 0 ? (openBlock(), createElementBlock("p", _hoisted_126, _hoisted_128)) : createCommentVNode("", true),
              $data.webcam.videoDevices.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_129, [
                createBaseVNode("label", _hoisted_130, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[42] || (_cache[42] = ($event) => $data.webcam.autoshare = $event)
                  }, null, 512), [
                    [vModelCheckbox, $data.webcam.autoshare]
                  ]),
                  createTextVNode(" Automatically go on camera when I log onto the chat room ")
                ]),
                _hoisted_131
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            $data.settingsModal.tab === "misc" ? (openBlock(), createElementBlock("div", _hoisted_132, [
              createBaseVNode("div", _hoisted_133, [
                _hoisted_134,
                createBaseVNode("div", _hoisted_135, [
                  createBaseVNode("div", _hoisted_136, [
                    createBaseVNode("label", _hoisted_137, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => $data.prefs.joinMessages = $event),
                        value: true
                      }, null, 512), [
                        [vModelCheckbox, $data.prefs.joinMessages]
                      ]),
                      createTextVNode(" Join room ")
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_138, [
                    createBaseVNode("label", _hoisted_139, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => $data.prefs.exitMessages = $event),
                        value: true
                      }, null, 512), [
                        [vModelCheckbox, $data.prefs.exitMessages]
                      ]),
                      createTextVNode(" Exit room ")
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_140, [
                _hoisted_141,
                createBaseVNode("label", _hoisted_142, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[45] || (_cache[45] = ($event) => $data.prefs.watchNotif = $event),
                    value: true
                  }, null, 512), [
                    [vModelCheckbox, $data.prefs.watchNotif]
                  ]),
                  createTextVNode(" Notify when somebody opens my camera ")
                ])
              ]),
              createBaseVNode("div", _hoisted_143, [
                _hoisted_144,
                createBaseVNode("label", _hoisted_145, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[46] || (_cache[46] = ($event) => $data.prefs.closeDMs = $event),
                    value: true
                  }, null, 512), [
                    [vModelCheckbox, $data.prefs.closeDMs]
                  ]),
                  createTextVNode(" Ignore unsolicited DMs from others ")
                ]),
                _hoisted_146
              ]),
              this.jwt.valid ? (openBlock(), createElementBlock("div", _hoisted_147, [
                createBaseVNode("a", {
                  href: "#",
                  onClick: _cache[47] || (_cache[47] = withModifiers(($event) => $options.clearMessageHistory(), ["prevent"])),
                  class: "button is-small has-text-danger"
                }, [
                  _hoisted_148,
                  createTextVNode(" Clear direct message history ")
                ]),
                $data.clearDirectMessages.busy ? (openBlock(), createElementBlock("div", _hoisted_149, [
                  _hoisted_150,
                  createTextVNode(" Working... ")
                ])) : $data.clearDirectMessages.ok ? (openBlock(), createElementBlock("div", _hoisted_151, [
                  _hoisted_152,
                  createTextVNode(" History cleared (" + toDisplayString($data.clearDirectMessages.messagesErased) + " message" + toDisplayString($data.clearDirectMessages.messagesErased === 1 ? "" : "s") + " erased) ", 1)
                ])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            $data.settingsModal.tab === "advanced" ? (openBlock(), createElementBlock("div", _hoisted_153, [
              createBaseVNode("div", _hoisted_154, [
                _hoisted_155,
                createBaseVNode("label", _hoisted_156, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[48] || (_cache[48] = ($event) => $data.prefs.usePolling = $event),
                    value: false
                  }, null, 512), [
                    [vModelRadio, $data.prefs.usePolling]
                  ]),
                  createTextVNode(" WebSockets (realtime connection; recommended for most people) ")
                ]),
                createBaseVNode("label", _hoisted_157, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[49] || (_cache[49] = ($event) => $data.prefs.usePolling = $event),
                    value: true
                  }, null, 512), [
                    [vModelRadio, $data.prefs.usePolling]
                  ]),
                  createTextVNode(" Polling (check for new messages every 5 seconds) ")
                ]),
                createBaseVNode("p", _hoisted_158, [
                  createTextVNode(' By default the chat server requires a constant WebSockets connection to stay online. If you are experiencing frequent disconnects (e.g. because you are on a slow or unstable network connection), try switching to the "Polling" method which will be more robust, at the cost of up to 5-seconds latency to receive new messages. '),
                  !$options.connected ? (openBlock(), createElementBlock("span", _hoisted_159, " Notice: you may need to refresh the chat page after changing this setting. ")) : createCommentVNode("", true)
                ])
              ]),
              $options.isOp || $data.prefs.debug ? (openBlock(), createElementBlock("div", _hoisted_160, [
                _hoisted_161,
                createBaseVNode("label", _hoisted_162, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[50] || (_cache[50] = ($event) => $data.prefs.debug = $event),
                    value: true
                  }, null, 512), [
                    [vModelCheckbox, $data.prefs.debug]
                  ])
                ]),
                createTextVNode(' Enable the "Debug Log" channel. '),
                _hoisted_163
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("footer", _hoisted_164, [
            createBaseVNode("div", _hoisted_165, [
              createBaseVNode("button", {
                type: "button",
                class: "button is-primary",
                onClick: _cache[51] || (_cache[51] = ($event) => $options.hideSettings())
              }, " Close ")
            ])
          ])
        ])
      ])
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(["modal", { "is-active": $data.nsfwModalCast.visible }])
    }, [
      _hoisted_166,
      createBaseVNode("div", _hoisted_167, [
        createBaseVNode("div", _hoisted_168, [
          _hoisted_169,
          createBaseVNode("div", _hoisted_170, [
            _hoisted_171,
            createBaseVNode("div", _hoisted_172, [
              createBaseVNode("label", _hoisted_173, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[52] || (_cache[52] = ($event) => $data.webcam.autoMute = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.autoMute]
                ]),
                createTextVNode(" Start with my microphone on mute by default ")
              ])
            ]),
            $data.config.permitNSFW ? (openBlock(), createElementBlock("p", _hoisted_174, _hoisted_176)) : createCommentVNode("", true),
            $data.config.permitNSFW ? (openBlock(), createElementBlock("div", _hoisted_177, [
              createBaseVNode("label", _hoisted_178, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[53] || (_cache[53] = ($event) => $data.webcam.nsfw = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.nsfw]
                ]),
                createTextVNode(" Mark my camera as featuring "),
                _hoisted_179,
                _hoisted_180,
                createTextVNode(" or sexual content ")
              ]),
              _hoisted_181
            ])) : createCommentVNode("", true),
            $data.config.permitNSFW ? (openBlock(), createElementBlock("div", _hoisted_182, [
              createBaseVNode("label", _hoisted_183, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[54] || (_cache[54] = ($event) => $data.webcam.nonExplicit = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.nonExplicit]
                ]),
                createTextVNode(" I prefer not to see Explicit cameras from other chatters ")
              ]),
              _hoisted_184
            ])) : createCommentVNode("", true),
            _hoisted_185,
            createBaseVNode("div", _hoisted_186, [
              createBaseVNode("label", _hoisted_187, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[55] || (_cache[55] = ($event) => $data.webcam.mutual = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.mutual]
                ]),
                createTextVNode(" People must be sharing their own camera before they can open mine ")
              ])
            ]),
            createBaseVNode("div", _hoisted_188, [
              createBaseVNode("label", _hoisted_189, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[56] || (_cache[56] = ($event) => $data.webcam.mutualOpen = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.mutualOpen]
                ]),
                createTextVNode(" When someone opens my camera, I also open their camera automatically ")
              ])
            ]),
            $options.isVIP ? (openBlock(), createElementBlock("div", _hoisted_190, [
              createBaseVNode("label", _hoisted_191, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[57] || (_cache[57] = ($event) => $data.webcam.vipOnly = $event)
                }, null, 512), [
                  [vModelCheckbox, $data.webcam.vipOnly]
                ]),
                createTextVNode(" Only "),
                createBaseVNode("span", {
                  innerHTML: $data.config.VIP.Branding
                }, null, 8, _hoisted_192),
                createTextVNode(),
                createBaseVNode("sup", {
                  class: normalizeClass(["is-size-7", $data.config.VIP.Icon])
                }, null, 2),
                createTextVNode(" members can see that my camera is broadcasting ")
              ])
            ])) : createCommentVNode("", true),
            $data.webcam.videoDevices.length > 0 || $data.webcam.audioDevices.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_193, [
              createBaseVNode("div", _hoisted_194, [
                _hoisted_195,
                createBaseVNode("div", _hoisted_196, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[58] || (_cache[58] = ($event) => $data.webcam.videoDeviceID = $event)
                  }, [
                    _hoisted_197,
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.webcam.videoDevices, (d2, i2) => {
                      return openBlock(), createElementBlock("option", {
                        value: d2.id,
                        key: i2
                      }, toDisplayString(d2.label || `Camera ${i2}`), 9, _hoisted_198);
                    }), 128))
                  ], 512), [
                    [vModelSelect, $data.webcam.videoDeviceID]
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_199, [
                _hoisted_200,
                createBaseVNode("div", _hoisted_201, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[59] || (_cache[59] = ($event) => $data.webcam.audioDeviceID = $event)
                  }, [
                    _hoisted_202,
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.webcam.audioDevices, (d2, i2) => {
                      return openBlock(), createElementBlock("option", {
                        value: d2.id,
                        key: i2
                      }, toDisplayString(d2.label || `Microphone ${i2}`), 9, _hoisted_203);
                    }), 128))
                  ], 512), [
                    [vModelSelect, $data.webcam.audioDeviceID]
                  ])
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_204, [
              createBaseVNode("div", _hoisted_205, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[60] || (_cache[60] = ($event) => $data.nsfwModalCast.visible = false)
                }, "Cancel"),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-success ml-2",
                  onClick: _cache[61] || (_cache[61] = ($event) => {
                    $options.startVideo({ force: true });
                    $data.nsfwModalCast.visible = false;
                  })
                }, "Start webcam")
              ])
            ])
          ])
        ])
      ])
    ], 2),
    createVNode(_component_ExplicitOpenModal, {
      visible: $data.nsfwModalView.visible,
      user: $data.nsfwModalView.user,
      onAccept: _cache[62] || (_cache[62] = ($event) => $options.openVideo($data.nsfwModalView.user, true)),
      onCancel: _cache[63] || (_cache[63] = ($event) => $data.nsfwModalView.visible = false),
      onDontShowAgain: _cache[64] || (_cache[64] = ($event) => $options.setSkipNSFWModal())
    }, null, 8, ["visible", "user"]),
    createVNode(_component_ReportModal, {
      visible: $data.reportModal.visible,
      busy: $data.reportModal.busy,
      user: $data.reportModal.user,
      message: $data.reportModal.message,
      onAccept: $options.doReport,
      onCancel: _cache[65] || (_cache[65] = ($event) => $data.reportModal.visible = false)
    }, null, 8, ["visible", "busy", "user", "message", "onAccept"]),
    createVNode(_component_ProfileModal, {
      visible: $data.profileModal.visible,
      user: $data.profileModal.user,
      username: $data.username,
      "is-viewer-op": $options.isOp,
      jwt: $data.jwt.token,
      "website-url": $data.config.website,
      "is-dnd": $options.isUsernameDND($data.profileModal.username),
      "is-muted": $options.isMutedUser($data.profileModal.username),
      "is-booted": $options.isBooted($data.profileModal.username),
      "profile-webhook-enabled": $options.isWebhookEnabled("profile"),
      "vip-config": $data.config.VIP,
      onSendDm: $options.openDMs,
      onMuteUser: $options.muteUser,
      onBootUser: $options.bootUser,
      onSendCommand: $options.sendCommand,
      onReport: $options.doCustomReport,
      onCancel: _cache[66] || (_cache[66] = ($event) => $data.profileModal.visible = false)
    }, null, 8, ["visible", "user", "username", "is-viewer-op", "jwt", "website-url", "is-dnd", "is-muted", "is-booted", "profile-webhook-enabled", "vip-config", "onSendDm", "onMuteUser", "onBootUser", "onSendCommand", "onReport"]),
    createBaseVNode("div", _hoisted_206, [
      createBaseVNode("header", _hoisted_207, [
        createBaseVNode("div", _hoisted_208, [
          createBaseVNode("div", _hoisted_209, [
            createBaseVNode("strong", _hoisted_210, [
              createBaseVNode("span", {
                innerHTML: $data.config.branding
              }, null, 8, _hoisted_211)
            ])
          ]),
          createBaseVNode("div", _hoisted_212, [
            $data.webcam.active ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              class: "button is-small is-danger px-1",
              onClick: _cache[67] || (_cache[67] = ($event) => $options.stopVideo())
            }, [
              _hoisted_213,
              createTextVNode(" Stop ")
            ])) : (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "button is-small is-success px-1",
              onClick: _cache[68] || (_cache[68] = ($event) => $options.startVideo({})),
              disabled: $data.webcam.busy
            }, [
              _hoisted_215,
              createTextVNode(" Share webcam ")
            ], 8, _hoisted_214)),
            $data.webcam.active && !$data.webcam.muted ? (openBlock(), createElementBlock("button", {
              key: 2,
              type: "button",
              class: "button is-small is-success ml-1 px-1",
              onClick: _cache[69] || (_cache[69] = ($event) => $options.muteMe())
            }, [
              _hoisted_216,
              createTextVNode(" Mute ")
            ])) : createCommentVNode("", true),
            $data.webcam.active && $data.webcam.muted ? (openBlock(), createElementBlock("button", {
              key: 3,
              type: "button",
              class: "button is-small is-danger ml-1 px-1",
              onClick: _cache[70] || (_cache[70] = ($event) => $options.muteMe())
            }, [
              _hoisted_217,
              createTextVNode(" Unmute ")
            ])) : createCommentVNode("", true),
            $data.webcam.active ? (openBlock(), createElementBlock("button", {
              key: 4,
              type: "button",
              class: "button is-small is-link is-outlined ml-1 px-1",
              onClick: _cache[71] || (_cache[71] = ($event) => $options.showViewers())
            }, [
              _hoisted_218,
              createTextVNode(" " + toDisplayString(Object.keys($data.webcam.watching).length), 1)
            ])) : createCommentVNode("", true),
            $data.webcam.active && $data.config.permitNSFW ? (openBlock(), createElementBlock("button", {
              key: 5,
              type: "button",
              class: normalizeClass(["button is-small px-1 ml-1", {
                "is-outlined is-dark": !$data.webcam.nsfw,
                "is-danger": $data.webcam.nsfw
              }]),
              onClick: _cache[72] || (_cache[72] = withModifiers(($event) => $options.topNavExplicitButtonClicked(), ["prevent"])),
              title: "Toggle the NSFW setting for your camera broadcast"
            }, [
              createBaseVNode("i", {
                class: normalizeClass(["fa fa-fire mr-1", { "has-text-danger": !$data.webcam.nsfw }])
              }, null, 2),
              createTextVNode(" Explicit ")
            ], 2)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_219, [
            _hoisted_220,
            createBaseVNode("div", _hoisted_221, [
              createBaseVNode("div", _hoisted_222, [
                createBaseVNode("a", {
                  href: "#",
                  class: "dropdown-item",
                  onClick: _cache[73] || (_cache[73] = withModifiers(($event) => $options.showSettings(), ["prevent"]))
                }, [
                  _hoisted_223,
                  createTextVNode(" Chat Settings ")
                ]),
                $options.numVideosOpen > 0 ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  href: "#",
                  class: "dropdown-item",
                  onClick: _cache[74] || (_cache[74] = withModifiers(($event) => $options.closeOpenVideos(), ["prevent"]))
                }, [
                  _hoisted_224,
                  createTextVNode(" Close all cameras ")
                ])) : createCommentVNode("", true),
                $options.numVideosOpen > 0 ? (openBlock(), createElementBlock("a", {
                  key: 1,
                  href: "#",
                  class: "dropdown-item",
                  onClick: _cache[75] || (_cache[75] = withModifiers(($event) => $options.muteAllVideos(), ["prevent"]))
                }, [
                  _hoisted_225,
                  createTextVNode(" Mute all cameras ")
                ])) : createCommentVNode("", true),
                _hoisted_226
              ])
            ])
          ])
        ])
      ]),
      createBaseVNode("div", _hoisted_229, [
        createBaseVNode("div", _hoisted_230, [
          createBaseVNode("header", _hoisted_231, [
            createBaseVNode("div", _hoisted_232, [
              createBaseVNode("div", _hoisted_233, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-success px-2 py-1",
                  onClick: _cache[76] || (_cache[76] = (...args) => $options.openChatPanel && $options.openChatPanel(...args))
                }, _hoisted_235)
              ]),
              _hoisted_236
            ])
          ]),
          createBaseVNode("div", _hoisted_237, [
            createBaseVNode("aside", _hoisted_238, [
              _hoisted_239,
              createBaseVNode("ul", _hoisted_240, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.activeChannels, (c2) => {
                  return openBlock(), createElementBlock("li", {
                    key: c2.ID
                  }, [
                    createBaseVNode("a", {
                      href: "#" + c2.ID,
                      onClick: withModifiers(($event) => $options.setChannel(c2), ["prevent"]),
                      class: normalizeClass({ "is-active": c2.ID == $data.channel })
                    }, [
                      createTextVNode(toDisplayString(c2.Name) + " ", 1),
                      c2.Unread ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(["tag", { "is-success": !c2.Urgent, "is-danger": c2.Urgent }])
                      }, toDisplayString(c2.Unread), 3)) : createCommentVNode("", true)
                    ], 10, _hoisted_241)
                  ]);
                }), 128))
              ]),
              _hoisted_242,
              createBaseVNode("ul", _hoisted_243, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.activeDMs, (c2) => {
                  return openBlock(), createElementBlock("li", {
                    key: c2.channel
                  }, [
                    createBaseVNode("a", {
                      href: "#" + c2.channel,
                      onClick: withModifiers(($event) => $options.setChannel(c2.channel), ["prevent"]),
                      class: normalizeClass({ "is-active": c2.channel == $data.channel })
                    }, [
                      createBaseVNode("div", _hoisted_245, [
                        createBaseVNode("div", _hoisted_246, [
                          $options.avatarForUsername($options.normalizeUsername(c2.channel)) ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            src: $options.avatarForUsername($options.normalizeUsername(c2.channel)),
                            width: "24",
                            height: "24",
                            alt: ""
                          }, null, 8, _hoisted_247)) : (openBlock(), createElementBlock("img", _hoisted_248))
                        ]),
                        createBaseVNode("div", _hoisted_249, [
                          createBaseVNode("div", _hoisted_250, [
                            createBaseVNode("div", _hoisted_251, [
                              c2.unread ? (openBlock(), createElementBlock("span", _hoisted_252, toDisplayString(c2.unread), 1)) : createCommentVNode("", true),
                              $options.isUserOffline(c2.name) ? (openBlock(), createElementBlock("del", _hoisted_253, toDisplayString(c2.name), 1)) : (openBlock(), createElementBlock("span", _hoisted_254, toDisplayString(c2.name), 1))
                            ])
                          ])
                        ])
                      ])
                    ], 10, _hoisted_244)
                  ]);
                }), 128))
              ])
            ]),
            createBaseVNode("div", _hoisted_255, [
              createBaseVNode("label", _hoisted_256, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[77] || (_cache[77] = ($event) => $data.prefs.closeDMs = $event),
                  value: true
                }, null, 512), [
                  [vModelCheckbox, $data.prefs.closeDMs]
                ]),
                createTextVNode(" Ignore unsolicited DMs "),
                _hoisted_257
              ])
            ])
          ])
        ])
      ]),
      createBaseVNode("div", _hoisted_258, [
        createBaseVNode("div", _hoisted_259, [
          createBaseVNode("header", {
            class: normalizeClass(["card-header", { "has-background-private": $options.isDM, "has-background-link": !$options.isDM }])
          }, [
            createBaseVNode("div", _hoisted_260, [
              createBaseVNode("div", _hoisted_261, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-success px-2 py-1",
                  onClick: _cache[78] || (_cache[78] = (...args) => $options.openChannelsPanel && $options.openChannelsPanel(...args))
                }, [
                  _hoisted_262,
                  $options.hasAnyUnread() > 0 ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(["tag ml-1", { "is-danger": $options.anyUnreadDMs() }])
                  }, toDisplayString($options.hasAnyUnread()), 3)) : createCommentVNode("", true)
                ])
              ]),
              $options.isDM && $options.isUsernameOnCamera($options.currentDMPartner.username) ? (openBlock(), createElementBlock("div", _hoisted_263, [
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass(["button px-2 py-1", $options.webcamButtonClass($options.currentDMPartner.username)]),
                  title: `View ${$data.channel}'s camera`,
                  onClick: _cache[79] || (_cache[79] = ($event) => $options.openVideo($options.currentDMPartner))
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["fa", $options.webcamIconClass($options.currentDMPartner)])
                  }, null, 2)
                ], 10, _hoisted_264)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_265, [
                createBaseVNode("div", _hoisted_266, [
                  createTextVNode("   "),
                  createBaseVNode("div", _hoisted_267, [
                    $options.isDM ? (openBlock(), createElementBlock("div", _hoisted_268, [
                      createBaseVNode("a", {
                        href: "#",
                        class: "has-text-light",
                        onClick: _cache[80] || (_cache[80] = withModifiers(($event) => $options.showProfileModal($options.currentDMPartner.username), ["prevent"]))
                      }, toDisplayString($options.channelName), 1)
                    ])) : (openBlock(), createElementBlock("div", _hoisted_269, toDisplayString($options.channelName), 1))
                  ])
                ])
              ]),
              $options.anyVideosOpen ? (openBlock(), createElementBlock("div", _hoisted_270, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-small is-outlined mr-1",
                  disabled: $data.webcam.videoScale === "x4",
                  onClick: _cache[81] || (_cache[81] = ($event) => {
                    $data.settingsModal.tab = "webcam";
                    $options.showSettings();
                  })
                }, _hoisted_273, 8, _hoisted_271),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-small is-outlined mr-1",
                  disabled: $data.webcam.videoScale === "x4",
                  onClick: _cache[82] || (_cache[82] = ($event) => $options.scaleVideoSize(true))
                }, _hoisted_276, 8, _hoisted_274),
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-small is-outlined",
                  disabled: $data.webcam.videoScale === "",
                  onClick: _cache[83] || (_cache[83] = ($event) => $options.scaleVideoSize(false))
                }, _hoisted_279, 8, _hoisted_277)
              ])) : createCommentVNode("", true),
              $options.isDM ? (openBlock(), createElementBlock("div", _hoisted_280, [
                createBaseVNode("button", {
                  type: "button",
                  class: "float-right button is-small is-warning is-outlined",
                  onClick: _cache[84] || (_cache[84] = ($event) => $options.leaveDM($data.channel))
                }, _hoisted_282)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_283, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-success px-2 py-1",
                  onClick: _cache[85] || (_cache[85] = (...args) => $options.openWhoPanel && $options.openWhoPanel(...args))
                }, _hoisted_285)
              ])
            ])
          ], 2),
          withDirectives(createBaseVNode("div", {
            id: "video-feeds",
            class: normalizeClass(["video-feeds", $data.webcam.videoScale])
          }, [
            withDirectives(createVNode(_component_VideoFeed, {
              "local-video": true,
              username: $data.username,
              "popped-out": $data.WebRTC.poppedOut[$data.username],
              "is-explicit": $data.webcam.nsfw,
              "is-muted": $data.webcam.muted,
              "is-source-muted": $data.webcam.muted,
              "is-speaking": $data.WebRTC.speaking[$data.username],
              "watermark-image": $data.webcam.watermark,
              onMuteVideo: _cache[86] || (_cache[86] = ($event) => $options.muteMe()),
              onPopout: $options.popoutVideo,
              onOpenProfile: $options.showProfileModal,
              onSetVolume: $options.setVideoVolume
            }, null, 8, ["username", "popped-out", "is-explicit", "is-muted", "is-source-muted", "is-speaking", "watermark-image", "onPopout", "onOpenProfile", "onSetVolume"]), [
              [vShow, $data.webcam.active]
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.WebRTC.streams, (stream, username) => {
              return openBlock(), createBlock(_component_VideoFeed, {
                key: username,
                username,
                "popped-out": $data.WebRTC.poppedOut[username],
                "is-speaking": $data.WebRTC.speaking[username],
                "is-explicit": $options.isUsernameCamNSFW(username),
                "is-source-muted": $options.isSourceMuted(username),
                "is-muted": $options.isMuted(username),
                "is-watching-me": $options.isWatchingMe(username),
                "is-frozen": $data.WebRTC.frozenStreamDetected[username],
                "watermark-image": $data.webcam.watermark,
                onReopenVideo: $options.openVideoByUsername,
                onMuteVideo: $options.muteVideo,
                onPopout: $options.popoutVideo,
                onCloseVideo: $options.expresslyCloseVideo,
                onSetVolume: $options.setVideoVolume,
                onOpenProfile: $options.showProfileModal
              }, null, 8, ["username", "popped-out", "is-speaking", "is-explicit", "is-source-muted", "is-muted", "is-watching-me", "is-frozen", "watermark-image", "onReopenVideo", "onMuteVideo", "onPopout", "onCloseVideo", "onSetVolume", "onOpenProfile"]);
            }), 128))
          ], 2), [
            [vShow, $data.webcam.active || Object.keys($data.WebRTC.streams).length > 0]
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["card-content", {
              "has-background-dm": $options.isDM,
              "p-1 pb-5": $data.messageStyle.indexOf("compact") === 0
            }]),
            id: "chatHistory"
          }, [
            $options.isChatPartnerAway ? (openBlock(), createElementBlock("div", _hoisted_286, [
              _hoisted_287,
              $options.chatPartnerStatusMessage ? (openBlock(), createElementBlock("span", _hoisted_288, toDisplayString($options.chatPartnerStatusMessage.emoji) + " " + toDisplayString($options.chatPartnerStatusMessage.label), 1)) : (openBlock(), createElementBlock("em", _hoisted_289, "undefined"))
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_290, [
              createBaseVNode("label", _hoisted_291, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[87] || (_cache[87] = ($event) => $data.autoscroll = $event),
                  value: true
                }, null, 512), [
                  [vModelCheckbox, $data.autoscroll]
                ]),
                createTextVNode(" Auto-scroll ")
              ])
            ]),
            createBaseVNode("div", {
              class: normalizeClass($data.fontSizeClass)
            }, [
              $options.chatHistory.length === 0 || $options.chatHistory.length === 1 && $options.chatHistory[0].action === "notification" ? (openBlock(), createElementBlock("div", _hoisted_292, [
                $options.isDM ? (openBlock(), createElementBlock("em", _hoisted_293, " Starting a direct message chat with " + toDisplayString($data.channel) + ". Type a message and say hello! ", 1)) : (openBlock(), createElementBlock("em", _hoisted_294, " There are no messages in this channel yet. "))
              ])) : createCommentVNode("", true),
              $options.isDM && $data.directMessageHistory[$data.channel] != void 0 && $data.jwt.valid ? (openBlock(), createElementBlock("div", _hoisted_295, [
                $data.directMessageHistory[$data.channel].busy ? (openBlock(), createElementBlock("div", _hoisted_296, [
                  _hoisted_297,
                  createTextVNode(" Loading... ")
                ])) : $data.directMessageHistory[$data.channel].remaining !== 0 ? (openBlock(), createElementBlock("div", _hoisted_298, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[88] || (_cache[88] = withModifiers(($event) => $options.loadDirectMessageHistory($data.channel), ["prevent"]))
                  }, [
                    createTextVNode(" Load more messages "),
                    $data.directMessageHistory[$data.channel].remaining > 0 ? (openBlock(), createElementBlock("span", _hoisted_299, " (" + toDisplayString($data.directMessageHistory[$data.channel].remaining) + " remaining) ", 1)) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.chatHistory, (msg, i2) => {
                return openBlock(), createElementBlock("div", { key: i2 }, [
                  createVNode(_component_MessageBox, {
                    message: msg,
                    action: msg.action,
                    appearance: $data.messageStyle,
                    position: i2,
                    user: $options.getUser(msg.username),
                    "is-offline": $options.isUserOffline(msg.username),
                    username: $data.username,
                    "website-url": $data.config.website,
                    "is-dnd": $options.isUsernameDND(msg.username),
                    "is-muted": $options.isMutedUser(msg.username),
                    reactions: $options.getReactions(msg),
                    "report-enabled": $options.isWebhookEnabled("report"),
                    "is-dm": $options.isDM,
                    "is-op": $options.isOp,
                    onOpenProfile: $options.showProfileModal,
                    onSendDm: $options.openDMs,
                    onMuteUser: $options.muteUser,
                    onTakeback: $options.takeback,
                    onRemove: $options.removeMessage,
                    onReport: $options.reportMessage,
                    onReact: $options.sendReact
                  }, null, 8, ["message", "action", "appearance", "position", "user", "is-offline", "username", "website-url", "is-dnd", "is-muted", "reactions", "report-enabled", "is-dm", "is-op", "onOpenProfile", "onSendDm", "onMuteUser", "onTakeback", "onRemove", "onReport", "onReact"])
                ]);
              }), 128))
            ], 2),
            $options.isDM && $options.isMutedUser($data.channel) ? (openBlock(), createElementBlock("div", _hoisted_300, [
              _hoisted_301,
              createBaseVNode("strong", null, toDisplayString($data.channel), 1),
              createTextVNode(" is currently "),
              _hoisted_302,
              createTextVNode(" so you have not been seeing their recent chat messages or DMs. "),
              createBaseVNode("a", {
                href: "#",
                onClick: _cache[89] || (_cache[89] = withModifiers(($event) => $options.muteUser($data.channel), ["prevent"]))
              }, "Unmute them?")
            ])) : createCommentVNode("", true)
          ], 2)
        ])
      ]),
      createBaseVNode("div", _hoisted_303, [
        createBaseVNode("div", _hoisted_304, [
          createBaseVNode("div", _hoisted_305, [
            createBaseVNode("div", _hoisted_306, [
              $options.canUploadFile ? (openBlock(), createElementBlock("div", _hoisted_307, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  onClick: _cache[90] || (_cache[90] = ($event) => $options.uploadFile()),
                  title: "Upload a picture to share in chat"
                }, _hoisted_309)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass(["column pr-1", { "pl-1": $options.canUploadFile }])
              }, [
                createBaseVNode("form", {
                  onSubmit: _cache[93] || (_cache[93] = withModifiers(($event) => $options.sendMessage(), ["prevent"]))
                }, [
                  createVNode(_component_Mentionable, {
                    keys: ["@"],
                    items: $options.atMentionItems,
                    offset: "12",
                    "insert-space": ""
                  }, {
                    "no-result": withCtx(() => [
                      _hoisted_311
                    ]),
                    "item-@": withCtx(({ item }) => [
                      createBaseVNode("div", _hoisted_312, [
                        createTextVNode(" @" + toDisplayString(item.value) + " ", 1),
                        createBaseVNode("span", _hoisted_313, toDisplayString(item.label), 1)
                      ])
                    ]),
                    default: withCtx(() => [
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "input",
                        id: "messageBox",
                        "onUpdate:modelValue": _cache[91] || (_cache[91] = ($event) => $data.message = $event),
                        placeholder: "Write a message",
                        onKeydown: _cache[92] || (_cache[92] = ($event) => $options.sendTypingNotification()),
                        autocomplete: "off",
                        disabled: !$data.client.connected
                      }, null, 40, _hoisted_310), [
                        [vModelText, $data.message]
                      ])
                    ]),
                    _: 1
                  }, 8, ["items"])
                ], 32)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["column px-1 is-narrow dropdown is-right is-up", { "is-active": $data.showEmojiPicker }]),
                onClick: _cache[95] || (_cache[95] = ($event) => $data.showEmojiPicker = true)
              }, [
                createBaseVNode("div", _hoisted_314, [
                  createBaseVNode("button", {
                    type: "button",
                    class: "button",
                    "aria-haspopup": "true",
                    "aria-controls": "input-emoji-picker",
                    onClick: _cache[94] || (_cache[94] = ($event) => $options.hideEmojiPicker())
                  }, _hoisted_316)
                ]),
                createBaseVNode("div", _hoisted_317, [
                  createBaseVNode("div", _hoisted_318, [
                    createVNode(_component_EmojiPicker, {
                      native: true,
                      "display-recent": true,
                      "disable-skin-tones": true,
                      theme: $data.prefs.theme !== "auto" ? $data.prefs.theme : "auto",
                      onSelect: $options.onSelectEmoji
                    }, null, 8, ["theme", "onSelect"])
                  ])
                ])
              ], 2),
              createBaseVNode("div", _hoisted_319, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button",
                  disabled: $data.message.length === 0,
                  title: "Click to send your message",
                  onClick: _cache[96] || (_cache[96] = ($event) => $options.sendMessage())
                }, _hoisted_322, 8, _hoisted_320)
              ])
            ])
          ])
        ])
      ]),
      createBaseVNode("div", _hoisted_323, [
        createBaseVNode("div", _hoisted_324, [
          createBaseVNode("header", _hoisted_325, [
            createBaseVNode("div", _hoisted_326, [
              _hoisted_327,
              createBaseVNode("div", _hoisted_328, [
                createBaseVNode("button", {
                  type: "button",
                  class: "button is-success px-2 py-1",
                  onClick: _cache[97] || (_cache[97] = (...args) => $options.openChatPanel && $options.openChatPanel(...args))
                }, _hoisted_330)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_331, [
            createBaseVNode("div", _hoisted_332, [
              _hoisted_333,
              createBaseVNode("div", _hoisted_334, [
                createBaseVNode("div", _hoisted_335, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[98] || (_cache[98] = ($event) => $data.status = $event)
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.StatusMessage.iterSelectOptGroups(), (group) => {
                      return openBlock(), createElementBlock("optgroup", {
                        key: group.category,
                        label: group.category
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList($data.StatusMessage.iterSelectOptions(group.category), (item) => {
                          return openBlock(), createElementBlock("option", {
                            key: item.name,
                            value: item.name
                          }, toDisplayString(item.emoji) + " " + toDisplayString(item.label), 9, _hoisted_337);
                        }), 128))
                      ], 8, _hoisted_336);
                    }), 128))
                  ], 512), [
                    [vModelSelect, $data.status]
                  ])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_338, [
              _hoisted_339,
              createBaseVNode("div", _hoisted_340, [
                createBaseVNode("div", _hoisted_341, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[99] || (_cache[99] = ($event) => $data.whoSort = $event)
                  }, [
                    _hoisted_342,
                    _hoisted_343,
                    _hoisted_344,
                    _hoisted_345,
                    withDirectives(createBaseVNode("option", _hoisted_346, "Red cameras", 512), [
                      [vShow, $data.config.permitNSFW]
                    ]),
                    _hoisted_347,
                    _hoisted_348,
                    _hoisted_349,
                    _hoisted_350
                  ], 512), [
                    [vModelSelect, $data.whoSort]
                  ])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_351, [
              createBaseVNode("ul", null, [
                createBaseVNode("li", {
                  class: normalizeClass({ "is-active": $data.whoTab === "online" })
                }, [
                  createBaseVNode("a", {
                    class: "is-size-7",
                    onClick: _cache[100] || (_cache[100] = withModifiers(($event) => $data.whoTab = "online", ["prevent"]))
                  }, " Online (" + toDisplayString($data.whoList.length) + ") ", 1)
                ], 2),
                $data.webcam.active ? (openBlock(), createElementBlock("li", {
                  key: 0,
                  class: normalizeClass({ "is-active": $data.whoTab === "watching" })
                }, [
                  createBaseVNode("a", {
                    class: "is-size-7",
                    onClick: _cache[101] || (_cache[101] = withModifiers(($event) => $data.whoTab = "watching", ["prevent"]))
                  }, [
                    _hoisted_352,
                    createTextVNode(" Watching (" + toDisplayString(Object.keys($data.webcam.watching).length) + ") ", 1)
                  ])
                ], 2)) : createCommentVNode("", true)
              ])
            ]),
            $data.whoTab === "online" ? (openBlock(), createElementBlock("div", _hoisted_353, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortedWhoList, (u2, i2) => {
                return openBlock(), createElementBlock("div", { key: i2 }, [
                  createVNode(_component_WhoListRow, {
                    user: u2,
                    username: $data.username,
                    "website-url": $data.config.website,
                    "is-dnd": $options.isUsernameDND(u2.username),
                    "is-muted": $options.isMutedUser(u2.username),
                    "is-blocked": $options.isBlockedUser(u2.username),
                    "is-booted": $options.isBooted(u2.username),
                    "is-op": $options.isOp,
                    "is-video-not-allowed": $options.isVideoNotAllowed(u2),
                    "video-icon-class": $options.webcamIconClass(u2),
                    "vip-config": $data.config.VIP,
                    "status-message": $data.StatusMessage,
                    onSendDm: $options.openDMs,
                    onMuteUser: $options.muteUser,
                    onOpenVideo: $options.openVideo,
                    onOpenProfile: $options.showProfileModal
                  }, null, 8, ["user", "username", "website-url", "is-dnd", "is-muted", "is-blocked", "is-booted", "is-op", "is-video-not-allowed", "video-icon-class", "vip-config", "status-message", "onSendDm", "onMuteUser", "onOpenVideo", "onOpenProfile"])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            $data.whoTab === "watching" ? (openBlock(), createElementBlock("div", _hoisted_354, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortedWatchingList, (u2, i2) => {
                return openBlock(), createElementBlock("div", { key: i2 }, [
                  createVNode(_component_WhoListRow, {
                    "is-watching-tab": true,
                    user: u2,
                    username: $data.username,
                    "website-url": $data.config.website,
                    "is-dnd": $options.isUsernameDND($data.username),
                    "is-muted": $options.isMutedUser($data.username),
                    "is-blocked": $options.isBlockedUser(u2.username),
                    "is-booted": $options.isBooted(u2.username),
                    "is-op": $options.isOp,
                    "is-video-not-allowed": $options.isVideoNotAllowed(u2),
                    "video-icon-class": $options.webcamIconClass(u2),
                    "vip-config": $data.config.VIP,
                    "status-message": $data.StatusMessage,
                    onSendDm: $options.openDMs,
                    onMuteUser: $options.muteUser,
                    onOpenVideo: $options.openVideo,
                    onBootUser: $options.bootUser,
                    onOpenProfile: $options.showProfileModal
                  }, null, 8, ["user", "username", "website-url", "is-dnd", "is-muted", "is-blocked", "is-booted", "is-op", "is-video-not-allowed", "video-icon-class", "vip-config", "status-message", "onSendDm", "onMuteUser", "onOpenVideo", "onBootUser", "onOpenProfile"])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ])
        ])
      ])
    ]),
    _hoisted_355,
    $data.prefs.theme === "light" ? (openBlock(), createElementBlock("link", _hoisted_356)) : $data.prefs.theme === "dark" ? (openBlock(), createElementBlock("link", _hoisted_357)) : (openBlock(), createElementBlock("link", _hoisted_358))
  ], 64);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
createApp(App).mount("#app");
//# sourceMappingURL=index-d29f67c6.js.map
